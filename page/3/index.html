<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/R-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/R-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rancho333.gitee.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="No pain, no gain!">
<meta property="og:type" content="website">
<meta property="og:title" content="Rancho Blog">
<meta property="og:url" content="https://rancho333.gitee.io/page/3/index.html">
<meta property="og:site_name" content="Rancho Blog">
<meta property="og:description" content="No pain, no gain!">
<meta property="og:locale">
<meta property="article:author" content="Rancho">
<meta property="article:tag" content="Racncho, Rancho Blog, 嵌入式">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rancho333.gitee.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Rancho Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rancho Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知行合一，致良知！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Rancho333" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">ARP协议简述及应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-25 13:22:08" itemprop="dateCreated datePublished" datetime="2020-12-25T13:22:08+00:00">2020-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-06 09:59:09" itemprop="dateModified" datetime="2021-04-06T09:59:09+00:00">2021-04-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇文章分为两个部分ARP协议简介以及ARP协议的实际应用。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/21/%E5%8A%A0%E5%BC%98%E8%B7%91%E5%9B%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/%E5%8A%A0%E5%BC%98%E8%B7%91%E5%9B%A2/" class="post-title-link" itemprop="url">加弘跑团</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-21 13:12:08" itemprop="dateCreated datePublished" datetime="2020-12-21T13:12:08+00:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要跑步？<br>我最开始跑步是为了减肥，现在我更多的认为规律性的跑步是一种健康的生活方式，是一种极易获取的运动。对跑步，我谈不上热爱，但我已经习惯了生活有它的一席之地。我知道跑步之前的生活状态，也知道现在的生活状态，所以我离不开跑步。</p>
<p>提及跑步，可以轻易找到各种各样的好处，这里不赘述。但是随便跑个几公里，一周只跑一两次其实很难看到你想要的效果。如果加大跑量，跑步有时候可能会损伤你的膝盖，还会让你得上一些奇奇怪怪的病，什么足底筋膜炎，跟腱炎，髂胫束摩擦综合症，跑完一个半马，你可能下楼梯都困难。</p>
<p>跑步是痛苦的，长跑更是意志力的对抗赛。只有在熬过最初的苦痛，可以边跑边聊天，可以只用鼻子呼吸的时候，你才不会感觉那么煎熬，这之前是可以称作跑步痛苦期。如果想着提高配速，增加距离，再突破瓶颈，那便得再痛苦一番。跑步也不能拯救我们，跑步是花钱的运动，专业跑鞋很贵，所以好好工作才能好好跑步。</p>
<p>跑步是痛苦的，只有认识到跑步的痛苦之后，然后依然热爱并且坚定的选择，才能持久的进行。跑步的快乐，只有在获得正向反馈之后，熬过跑步痛苦期之后，才能真正体会到。</p>
<p>所以，为什么要跑步？请寻找你内心的信念，让它支撑你熬过开始跑步时的痛苦。</p>
<p>什么叫跑步？<br>跑步，跑马拉松并不会让我们高人一等，也不是只有跑十公里以上才叫跑步。每个人跑步的需求也是不一样的。有严肃跑者，将跑步当作兴趣来培养，动辄全马百公里超马越野跑，追求成绩追求PB；也有休闲跑者，三五好友或携妻带子，三两公里，微风微汗，也是开心畅快。<br>不用神话跑步，学音乐，学舞蹈，学英语都可以让我们变得更好。无论是严肃的跑者还是休闲的跑者，跑起来，都是跑步。跑步是一项包容性很大的活动。不用管配速，不用管距离，跑起来就好。</p>
<p>了解了一下，加弘跑团中有跑过上马的老马, 有早起晨跑的大佬，有希望进阶的跑者，有刚接触跑步的菜鸟。大家相聚一起，一起跑，想来是件很欢快的事情。加弘跑团刚成立，需要大家一起去将跑团运行起来。下面对跑团的运行以及接下来的安排做一些简要说明，欢迎大家补充优化。</p>
<ol>
<li><p>本周4（12月24号）进行加弘跑团第一次分享会，具体时间地点会通知，有以下几点：</p>
<ol>
<li>大家相互认识一下，确定跑团人员，购买跑团队服，还有大家赶紧拉人头</li>
<li>分享跑步基础知识，包括但不限于跑步姿势，预防伤害，跑步场地，跑步时间与饮食</li>
<li>跑步装备介绍，包括但不限于跑鞋（袜子），跑衣，手表<br>备注：分享人待定</li>
</ol>
</li>
<li><p>活动组织形式</p>
<ol>
<li>每月组织一次线下活动，时间可以是周末或者有意义的节假日或其它，地点待确定。不能参加的可以通过线上方式参与</li>
<li>线下活动会视经费情况安排补给，供大家补充体力</li>
<li>不定期安排比赛活动，视经费情况安排奖品</li>
</ol>
</li>
<li><p>暂定元旦进行加弘跑团第一次线下活动</p>
</li>
</ol>
<p>为了跑团的良好运行，请大家以任何形式联系我提供建议。关于知识分享，请大佬主动认领！<br>期待大家越跑越健康；期待大家跑一个冬天，帅一个夏天；期待有一天在马拉松的赛道上看到加弘跑团的旗帜！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/18/sonic-testbed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/18/sonic-testbed/" class="post-title-link" itemprop="url">sonic-testbed</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-18 15:29:56" itemprop="dateCreated datePublished" datetime="2020-12-18T15:29:56+00:00">2020-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最初，SONiC的所有测试用例都是用ansible playbook写的。2019年开始使用pytest， 2020年9月份之后，只有用pytest写的测试用例才被采纳。<br>但是ansible依然很重要，pytest-ansible插件连接pytest与ansible。pytest通过ansible进行多设备协同工作。</p>
<h2 id="物理拓扑"><a href="#物理拓扑" class="headerlink" title="物理拓扑"></a>物理拓扑</h2><p><img src="https://rancho333.gitee.io/uploads/physical-topology.png"></p>
<ol>
<li>DUT和leaf fanout的端口一一互联</li>
<li>leaf fanout与DUT相连的端口进行VLAN隔离</li>
<li>root fanout连接leaf fanout与testbed server</li>
<li>root fanout的端口工作在vlan trunk模式下</li>
<li>任一testbed server可以发送带有vlan tag的包到达DUT端口（root fanout的trunk口需要使能该vlan tag）</li>
</ol>
<h3 id="Fanout-switch"><a href="#Fanout-switch" class="headerlink" title="Fanout switch"></a>Fanout switch</h3><p><em>Fanout switch是使能了vlan trunking的物理交换机</em></p>
<ul>
<li>Et33是一个vlan trunking端口，并且和linux host的eth0连接</li>
<li>Et1-Et32是vlan access端口，并且与DUT连接</li>
<li>使能LACP/LLDP</li>
<li>关闭STP功能</li>
</ul>
<h3 id="Testbed-server"><a href="#Testbed-server" class="headerlink" title="Testbed server"></a>Testbed server</h3><p><img src="https://rancho333.gitee.io/uploads/testbed_server.png"></p>
<h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><ul>
<li>testbed server有两个网络接口<ul>
<li>trunk端口连接root fanout</li>
<li>management port管理服务器以及服务器上的VMs和PTF容器</li>
</ul>
</li>
</ul>
<h3 id="VMs"><a href="#VMs" class="headerlink" title="VMs"></a>VMs</h3><p>VMs使用的是Arista的vEOS。它们用来设置测试协议，例如BGP、LACP、LLDP等。它们通过<code>testbed-cli.sh start-vms</code>进行创建。每一个VM使用2G内存并且拥有10个网络接口。<br>    * 8个前面板端口。这些端口用来连接到openvswitch网桥，连接到vlan interfaces.vlan interface通过物理接口连接到fanout。<br>    * 一个后背板端口。所有VMs通过这个背板口互联。<br>    * 一个管理网口。用来管理VMs.</p>
<h3 id="PTF"><a href="#PTF" class="headerlink" title="PTF"></a>PTF</h3><p>PTF容器通过发送和接收数据包来验证DUT的数据面。<br>PTF with direct port<br><img src="https://rancho333.gitee.io/uploads/testbed-direct.png"></p>
<p>DUT的前面板口直连到一个PTF容器的端口。一般的PTF容器的eth0连接到DUT的Ethernet0，eth1连接到Ethernet4。这一般在PTF拓扑中用来连接DUT端口和PTF容器端口。</p>
<p><img src="https://rancho333.gitee.io/uploads/testbed-injected.png"></p>
<p>DUT的前面板口和一个VM的接口直连。但是我们在这个连接上有个tap。从vlan interface中收到的包被发送给VMs和PTF容器。从VM和PTF容器中发出的包被送到vlan interface。这允许我们可以同时从PTF host往DUT注入包和维持VM与DUT之间的BGP会话。</p>
<h3 id="SONiC-Tested-with-keysight-IxNetwork-as-Traffic-Generator"><a href="#SONiC-Tested-with-keysight-IxNetwork-as-Traffic-Generator" class="headerlink" title="SONiC Tested with keysight IxNetwork as Traffic Generator"></a>SONiC Tested with keysight IxNetwork as Traffic Generator</h3><p>TO BE DONE！！</p>
<h2 id="Testbed设置"><a href="#Testbed设置" class="headerlink" title="Testbed设置"></a>Testbed设置</h2><p>下面讲述testbed的设置步骤以及拓扑的部署。</p>
<h3 id="准备testbed服务器"><a href="#准备testbed服务器" class="headerlink" title="准备testbed服务器"></a>准备testbed服务器</h3><ul>
<li>系统要求：ubuntu 18.04 amd64</li>
<li>设置管理口，使用如下示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@server-1:~# cat &#x2F;etc&#x2F;network&#x2F;interfaces</span><br><span class="line"># The management network interface</span><br><span class="line">auto ma0</span><br><span class="line">iface ma0 inet manual</span><br><span class="line"></span><br><span class="line"># Server, VM and PTF management interface</span><br><span class="line">auto br1</span><br><span class="line">iface br1 inet static</span><br><span class="line">    bridge_ports ma0</span><br><span class="line">    bridge_stp off</span><br><span class="line">    bridge_maxwait 0</span><br><span class="line">    bridge_fd 0</span><br><span class="line">    address 10.250.0.245</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    network 10.250.0.0</span><br><span class="line">    broadcast 10.250.0.255</span><br><span class="line">    gateway 10.250.0.1</span><br><span class="line">    dns-nameservers 10.250.0.1 10.250.0.2</span><br><span class="line">    # dns-* options are implemented by the resolvconf package, if installed</span><br></pre></td></tr></table></figure></li>
<li>安装python2.7（Ansible需要）</li>
<li>添加Docker的官方GPG key：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为docker-pth设置docker仓库"><a href="#为docker-pth设置docker仓库" class="headerlink" title="为docker-pth设置docker仓库"></a>为<code>docker-pth</code>设置docker仓库</h3><ol>
<li>build <code>docker-pth</code>镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;sonic-buildimage.git</span><br><span class="line">cd sonic-buildimage</span><br><span class="line">make configure PLATFORM&#x3D;generic</span><br><span class="line">make target&#x2F;docker-ptf.gz</span><br></pre></td></tr></table></figure></li>
<li>设置自己的docker仓库并将<code>docker-ptf</code>上传</li>
</ol>
<h3 id="创建并且运行docker-sonic-mgmt"><a href="#创建并且运行docker-sonic-mgmt" class="headerlink" title="创建并且运行docker-sonic-mgmt"></a>创建并且运行<code>docker-sonic-mgmt</code></h3><p>管理testbed和运行测试用例需要很多依赖。将所有的依赖部署到<code>docker-sonic-mgmt</code>中，这样就可以很方便的使用<code>ansible-playbook</code>，<code>pytest</code>，<code>spytest</code>。</p>
<ol>
<li><p>构建<code>docker-sonic-mgmt</code>镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;sonic-buildimage.git</span><br><span class="line">cd sonic-buildimage</span><br><span class="line">make configure PLATFORM&#x3D;generic</span><br><span class="line">make target&#x2F;docker-sonic-mgmt.gz</span><br></pre></td></tr></table></figure>
<p>或者从<a target="_blank" rel="noopener" href="https://sonic-jenkins.westus2.cloudapp.azure.com/job/bldenv/job/docker-sonic-mgmt/lastSuccessfulBuild/artifact/sonic-buildimage/target/docker-sonic-mgmt.gz">这里</a>下载事先编译好的镜像。</p>
</li>
<li><p>克隆<code>sonic-mgmt</code>库到testbed server的工作目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;sonic-mgmt</span><br></pre></td></tr></table></figure></li>
<li><p>创建<code>docker-sonic-mgmt</code>容器，注意需要将上面克隆的<code>sonic-mgmt</code>挂载到容器中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; docker-sonic-mgmt.gz</span><br><span class="line">docker run -v $PWD:&#x2F;data -it docker-sonic-mgmt bash</span><br><span class="line">cd ~&#x2F;sonic-mgmt</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>注意：之后的所有操作都是在<code>docker-sonic-mgmt</code>容器中操作</em></p>
<h3 id="准备Testbed配置"><a href="#准备Testbed配置" class="headerlink" title="准备Testbed配置"></a>准备Testbed配置</h3><p>进入到容器之后，我们需要修改testbed的配置文件使之与实验拓扑映射起来。</p>
<ul>
<li><p>Testbed Server</p>
<ul>
<li>在<code>ansible/veos</code>中更新server的管理IP</li>
<li>在<code>ansible/group_vars/vm_host/creds.yml</code>中更新server的凭证</li>
<li>在<code>ansible/host_vars/STA-ACS-SERV-01.yml</code>中更新server的网络配置（for VMs和PTF management）<ul>
<li><code>external_port</code>：server的trunk口名称（连接到fanout switch）</li>
<li><code>mgmt_gw</code>：VM管理端口的网关IP</li>
<li><code>mgmt_prefixlen</code>: 管理网口子网掩码</li>
</ul>
</li>
<li>检查ansible可以与这个host连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible -m ping -i veos vm_host_1 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>VMs</p>
<ul>
<li>从Arista下载<a target="_blank" rel="noopener" href="https://www.arista.com/en/support/software-download">vEOS</a></li>
<li>将镜像文件拷贝到<code>ansible/veos</code><ul>
<li><code>Aboot-veos-serial-8.0.0.iso</code></li>
<li><code>vEOS-lab-4.20.15M.vmdk</code></li>
</ul>
</li>
<li>将VM的IP地址更新到<code>ansible/veos</code>. 这个IP地址应该和定义的管理IP在同一个子网中</li>
<li>在<code>ansible/group_vars/eos/creds.yml</code>中更新VM的凭证</li>
</ul>
</li>
<li><p>PTF容器</p>
<ul>
<li>在<code>vars/docker_registry.yml</code>中更新docker仓库信息</li>
</ul>
</li>
</ul>
<h3 id="设置VMs"><a href="#设置VMs" class="headerlink" title="设置VMs"></a>设置VMs</h3><ol>
<li>开启VMs：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh start-vms server_1 password.txt</span><br></pre></td></tr></table></figure>
<code>password.txt</code>是ansible的密码文件，如果不使用直接创建一个空文件即可。</li>
</ol>
<ol start="2">
<li>检查所有的VMs是否启动并且在运行中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible -m ping -i veos server_1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="部署Fanout交换机的Vlan"><a href="#部署Fanout交换机的Vlan" class="headerlink" title="部署Fanout交换机的Vlan"></a>部署Fanout交换机的Vlan</h3><p>在部署Fanout和运行测试用例之前需要明确环境中的所有物理连接。<br>在<code>roles/fanout</code>下的playbook只是用来部署Arista的Vlan配置。如果使用其它类型的交换机，请手动配置Vlan，或者部署一个2层交换机。</p>
<h3 id="部署拓扑"><a href="#部署拓扑" class="headerlink" title="部署拓扑"></a>部署拓扑</h3><ul>
<li>使用自己的数据更新<code>testbed.csv</code>。至少需要更新PTF管理接口的配置。</li>
<li>部署拓扑请运行：<code>/testbed-cli.sh add-topo vms-t1 ~/.password</code></li>
<li>移除拓扑请运行: <code>./testbed-cli.sh remove-topo vms-t1 ~/.password</code></li>
</ul>
<p>注意：<code>testbed-cli.sh</code>的最后一步试图在root fanout中重新部署vlan范围（与拓扑中规定的相匹配）。Arista的正常工作，其它型号的需要手动修改？</p>
<h2 id="Docker容器设置"><a href="#Docker容器设置" class="headerlink" title="Docker容器设置"></a>Docker容器设置</h2><p>使用<code>setup-container.sh</code>脚本去自动创建和配置sonic-mgmt的docker容器。使用普通用户user创建即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;setuo-container.sh -n container_name -i image_id -d directory</span><br><span class="line">image_id是在sonic-buildimage中创建的docker-sonic-mgmt.tar</span><br><span class="line">directory是主机与docker进行mount的文件夹</span><br></pre></td></tr></table></figure>
<p>创建完dokcer容器之后，可以进入容器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -u &lt;user&gt; -it &lt;container name&gt; bash</span><br></pre></td></tr></table></figure>

<h2 id="KVM-testbed设置"><a href="#KVM-testbed设置" class="headerlink" title="KVM testbed设置"></a>KVM testbed设置</h2><p>可以给testbed创建虚拟的交换机，在上面部署T0拓扑，运行一个快速测试去验证是否符合预期。<br>即物理设备都虚拟化在服务器上，对内存资源要求比较高，我们现在使用物理设备连接，暂不研究这块内容。<br>这里面有vEOS与cEOS的介绍，分别是基于KVM和docker的技术。</p>
<h2 id="cEOS"><a href="#cEOS" class="headerlink" title="cEOS"></a>cEOS</h2><p>如何使用cEOS作为DUT的邻居设备。<br>cEOS是容器化的EOS。所有的软件在容器中运行。与vEOS相比，cEOS内存暂用更少。</p>
<h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><p>首先创建一个基容器<code>net_$&#123;testbed_name&#125;_$&#123;vm_name&#125;</code>，在基容器中创建6个以太口。然后在基容器基础上启动cEOS<code>ceos_$&#123;testbed_name&#125;_$&#123;vm_name&#125;</code>容器。这6个网口分别用来：</p>
<ul>
<li>一个管理网口</li>
<li>4个前面板端口用来连接DUT</li>
<li>一个背板口连接PTF容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+------------+                      +----+</span><br><span class="line">|  cEOS  Ma0 +--------- VM0100-m ---+ br |</span><br><span class="line">|            |                      +----+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et1 +----------VM0100-t0---+  br-VM0100-0 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et2 +----------VM0100-t1---+  br-VM0100-1 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et3 +----------VM0100-t2---+  br-VM0100-2 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et4 +----------VM0100-t3---+  br-VM0100-3 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                       +--------------+</span><br><span class="line">|        Et5 +----------VM0100-back--+  br-b-vms6-1 |</span><br><span class="line">|            |                       +--------------+</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>cEOS容器中的<code>/mnt/flash</code>挂载到主机的<code>/data/ceos/ceos_$&#123;testbed_name&#125;_$&#123;vm_name&#125;</code>。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>两种方式登录到cEOS容器。</p>
<ol>
<li><p>docker exec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ceos_vms6-1_VM0100 Cli</span><br></pre></td></tr></table></figure></li>
<li><p>ssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lgh@jenkins-worker-15:~$ ssh admin@10.250.0.51</span><br><span class="line">Password: </span><br><span class="line">ARISTA01T1&gt;show int status</span><br><span class="line">Port       Name      Status       Vlan     Duplex Speed  Type            Flags Encapsulation</span><br><span class="line">Et1                  connected    in Po1   full   unconf EbraTestPhyPort                    </span><br><span class="line">Et2                  connected    1        full   unconf EbraTestPhyPort                    </span><br><span class="line">Et3                  connected    1        full   unconf EbraTestPhyPort                    </span><br><span class="line">Et4                  connected    1        full   unconf EbraTestPhyPort                    </span><br><span class="line">Et5        backplane connected    routed   full   unconf EbraTestPhyPort                    </span><br><span class="line">Ma0                  connected    routed   full   10G    10&#x2F;100&#x2F;1000                        </span><br><span class="line">Po1                  connected    routed   full   unconf N&#x2F;A                                </span><br><span class="line"></span><br><span class="line">ARISTA01T1&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="testbed路由设计"><a href="#testbed路由设计" class="headerlink" title="testbed路由设计"></a>testbed路由设计</h2><p>下面说明testbed中的BGP路由设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              +------+</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+         |</span><br><span class="line">                               |</span><br><span class="line">              +------+         |</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+         |</span><br><span class="line">+-------+                  +---+---+     </span><br><span class="line">|  PTF  +------------------+  DUT  |</span><br><span class="line">+-------+                  +---+---+</span><br><span class="line">              +------+         |</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+         |</span><br><span class="line">                               |</span><br><span class="line">              +------+         |</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+</span><br></pre></td></tr></table></figure>
<p>在这个拓扑中，VMs（vEOS）充当DUT的BGP邻居。VMs生成并且宣告BGP路由给DUT.这种方式有几个问题：</p>
<ul>
<li>在vEOS很难生成任意路由，例如，写一个复杂的路由表，过滤生成需要的路由</li>
<li>消耗很多内存在vENOS中</li>
<li>特定的NOS规则。如果我们打算从VN切换到SONiC，我们需要重写所有的路由表。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              +------+</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">    |         +------+         |</span><br><span class="line">    |                          |</span><br><span class="line">    |         +------+         |</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">    |         +------+         |</span><br><span class="line">+---+---+                  +---+---+     </span><br><span class="line">|  PTF  |                  |  DUT  |</span><br><span class="line">+---+---+                  +---+---+</span><br><span class="line">    |         +------+         |</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">    |         +------+         |</span><br><span class="line">    |                          |</span><br><span class="line">    |         +------+         |</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">              +------+</span><br></pre></td></tr></table></figure>
新的方法是将VM作为一个透传设备，我们在PTF容器上运行exabgp,exabgp通告如有信息给VM，VM再将路由信息通告给DUT。这种方式有几个好处：</li>
<li>VM模板变得简单很多。只有基础的端口，lag，BGP配置</li>
<li>VM的内存开销变小</li>
<li>exbgp可以生成复杂路由条目</li>
<li>容易支持不同的NOS作为邻居设备，例如SONiC vm</li>
</ul>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><ol>
<li>配置testbed的拓扑定义在一个文件中：<code>testbed.csv</code></li>
<li>一个脚本去操作所有的testbed:<code>testbed-cli.sh</code></li>
<li>灵活的拓扑允许将VM_SET和PTF容器作为一个实体看待</li>
<li>所有的VM管理网口ip定义在：<code>veos</code></li>
<li>PTF容器在所有拓扑中被使用</li>
<li>自动构建fanout switch的配置（需要被重构）</li>
<li>请看示例模块如果你想设置任意的testbed的拓扑</li>
</ol>
<h3 id="testbed拓扑配置"><a href="#testbed拓扑配置" class="headerlink" title="testbed拓扑配置"></a>testbed拓扑配置</h3><ul>
<li><code>testbed.csv</code>文件由以下组成：<ul>
<li>物理拓扑；VMs和PTF容器的端口如何与DUT连接</li>
<li>VMs的配置模板</li>
</ul>
</li>
<li>拓扑在<code>vars/topo_*.yml</code>文件中</li>
<li>当前的拓扑有：<ul>
<li>t1:32个VMs + 用来端口注入的PTF容器</li>
<li>t1-lag：24个VMs + 用来端口注入的PTF容器。其中8个VMs在每一LAG中有两个端口</li>
<li>ptf32: 拥有32个个端口的PTF容器与DUT端口直连</li>
<li>ptf64: 和ptf32相同，但是拥有64个端口</li>
<li>t0：4个VMs + PTF容器（4个用来端口注入，28个用来直连DUT）</li>
</ul>
</li>
</ul>
<h3 id="当前的拓扑"><a href="#当前的拓扑" class="headerlink" title="当前的拓扑"></a>当前的拓扑</h3><h4 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-t1.png"></p>
<ul>
<li>需要32个VMs</li>
<li>所有的DUT端口直连VMs</li>
<li>PTF容器只有注入端口</li>
</ul>
<h4 id="t1-lag"><a href="#t1-lag" class="headerlink" title="t1-lag"></a>t1-lag</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-ti-lag.png"></p>
<ul>
<li>需要24个VMs</li>
<li>所有的DUT端口直连VMs</li>
<li>PTF容器只有注入端口</li>
</ul>
<h4 id="ptf32"><a href="#ptf32" class="headerlink" title="ptf32"></a>ptf32</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-ptf32.png"></p>
<ul>
<li>不需要VMs</li>
<li>所有的DUT端口直连PTF容器</li>
<li>PTF容器没有注入端口</li>
</ul>
<h4 id="ptf64"><a href="#ptf64" class="headerlink" title="ptf64"></a>ptf64</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-ptf64.png"><br>和ptf32一样</p>
<h4 id="t0"><a href="#t0" class="headerlink" title="t0"></a>t0</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-t0.png"></p>
<ul>
<li>需要4个VMs</li>
<li>4个DUT端口连接到VMs</li>
<li>PTF容器有4个注入端口与28个直连端口</li>
</ul>
<h2 id="testbed配置"><a href="#testbed配置" class="headerlink" title="testbed配置"></a>testbed配置</h2><h3 id="testbed清单"><a href="#testbed清单" class="headerlink" title="testbed清单"></a>testbed清单</h3><ul>
<li><code>ansible/lab</code>：包含实验的所有DUTs， fanout switch, testbed server拓扑</li>
<li><code>ansible/veos</code>：所有的server和VMs</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Sonic-Mgmt-testbed设置"><a href="#Sonic-Mgmt-testbed设置" class="headerlink" title="Sonic-Mgmt testbed设置"></a>Sonic-Mgmt testbed设置</h2><p>从github上将sonic testbed设置到自己的环境中将会是一个冗长的过程。在将测试用例跑起来之前有十多个文件需要更新。<br>然而，这个过程可以通过testbed.yaml和TestbedProcessing.py自动完成。testbed.yaml是一个配置文件（编译所有需要运行testcase的数据到一个文件中）。TestbedProcess.py的工作原理是：从配置文件拉取信息，然后将信息推送到它们属于的文件中去。这篇指南将会勾勒并简易化testbed的设置。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>通过使用testbed.yaml和TestbedProcessing.py来完成testbed的设置。这篇指南结束后，应该完成sonic-mgmt testbed的设置并且将testcases跑起来。</p>
<h3 id="预迁移设置"><a href="#预迁移设置" class="headerlink" title="预迁移设置"></a>预迁移设置</h3><p> sonic-mgmt启动并运行测试用例需要下述的设备：</p>
<ul>
<li>Linux服务器</li>
<li>root fanout</li>
<li>leaf fanout</li>
<li>DUT (device under test)<br>testbed的信息和拓扑可以从overview中获取到。</li>
</ul>
<h3 id="修改-Testbed-yaml配置文件"><a href="#修改-Testbed-yaml配置文件" class="headerlink" title="修改 Testbed.yaml配置文件"></a>修改 Testbed.yaml配置文件</h3><p>在testbed.yaml中有7个主要的部分需要编辑：</p>
<ol>
<li>device_groups</li>
<li>devices</li>
<li>host_vars</li>
<li>veos_groups</li>
<li>veos</li>
<li>testbed</li>
<li>topology<br>每一部分文件的作用都需要按顺序的写好。具体信息在Sonic-Mgmt testbed Configuration中有描述</li>
</ol>
<p>对于testbed.yaml文件（在ansible下面有个testbed-new.yaml文件）：</p>
<h4 id="（可选）testbed-config部分："><a href="#（可选）testbed-config部分：" class="headerlink" title="（可选）testbed_config部分："></a>（可选）testbed_config部分：</h4><ul>
<li>name - 给testbed配置文件选择一个名字</li>
<li>alias - 给testbed配置文件选择一个别名</li>
</ul>
<h5 id="device-groups部分"><a href="#device-groups部分" class="headerlink" title="device_groups部分"></a>device_groups部分</h5><p>用法：lab</p>
<p>device_group部分生成lab文件，是用来设置testbed的的必须清单文件。配置文件的格式是yaml格式，脚本会将之转换成INI格式。device_group部分包含实验室中所有DUTs, fanout switchs，testbed server拓扑。组子节点从下面的device部分介绍。在大多数情况下可以不用管这一部分。</p>
<h4 id="devices部分"><a href="#devices部分" class="headerlink" title="devices部分"></a>devices部分</h4><p>用法：files/sonic_lab_devices, group_vars/fanout/secrets, group_vars/lab/secrets, lab</p>
<p>device部分是包含所有设备和主机的字典。这部分不包含PTF容器的信息。关于PTF容器的信息，查看testbed.csv文件。<br>对每一个你添加的设备，添加下面的信息：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th>ansible_host</th>
<th>ansible_ssh_user</th>
<th>ansible_ssh_pass</th>
<th>HwSKU</th>
<th>device_type</th>
</tr>
</thead>
<tbody><tr>
<td>str-msn2700-01</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>DevSonic</td>
<td>DevSonic</td>
</tr>
<tr>
<td>str-7260-10</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>Arista-7260QX-64</td>
<td>FanoutRoot</td>
</tr>
<tr>
<td>str-7260-10</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>Arista-7260QX-64</td>
<td>FanoutLeaf</td>
</tr>
<tr>
<td>str-acs-serv-01</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>TestServ</td>
<td>Server</td>
</tr>
</tbody></table>
<ul>
<li>hostname - 设备名称</li>
<li>ansible_host - 设备的管理IP</li>
<li>ansible_ssh_user - 设备登录名称</li>
<li>ansible_ssh_pass - 设备登录密码</li>
<li>hesku - 这是用来查阅验证的值（在/group_vars/all/labinfo.json）。没有这部分，就爱那个会失败。确保这部分在labinfo.json中有准确的数据。</li>
<li>device_type - 设备类型。如果只有4种设备，可以将提供标签留白不填写。</li>
</ul>
<p>lab server部分需要不同的字段输入：ansible_become_pass, sonicadmin_user(用户名), sonicadmin_password, sonic_inital_password. 这些字段是可选的，因为它们是直接从group_var/lab/secrets.yml中获取的变量。所以为了便利，这部分的配置文件作为一个拷贝。</p>
<h4 id="host-vars部分"><a href="#host-vars部分" class="headerlink" title="host_vars部分"></a>host_vars部分</h4><p>用法：所有的host_val数据</p>
<p>host的参数在此处设置。在这篇指南中，我们在此处定义server（str-acs-serv-01）：<br>对于每一个你添加的host，定义或确认如下数据：</p>
<ul>
<li>mgmt_bridge</li>
<li>mgmt_prefixlen (这个应该和mgmt_subnet_mask_length匹配)</li>
<li>mgmt_gw</li>
<li>external_about</li>
</ul>
<h4 id="veos-groups部分"><a href="#veos-groups部分" class="headerlink" title="veos_groups部分"></a>veos_groups部分</h4><p>用法：veos</p>
<h4 id="veos部分"><a href="#veos部分" class="headerlink" title="veos部分"></a>veos部分</h4><p>用法：group_vars/eos/cred, main.yml, group_vars/vm_host/creds</p>
<h4 id="testbed部分"><a href="#testbed部分" class="headerlink" title="testbed部分"></a>testbed部分</h4><p>用法： testbed.csv</p>
<h4 id="拓扑部分"><a href="#拓扑部分" class="headerlink" title="拓扑部分"></a>拓扑部分</h4><p>用法： files/sonic_lab_links.csv</p>
<h4 id="docker-registry部分"><a href="#docker-registry部分" class="headerlink" title="docker_registry部分"></a>docker_registry部分</h4><p>用法： /vars/docker_registry.yml</p>
<h3 id="testbed运行脚本"><a href="#testbed运行脚本" class="headerlink" title="testbed运行脚本"></a>testbed运行脚本</h3><p>当testbed.yaml文件配置好后，将TestbedProcess.py和testbed.yaml文件放在sonic-mgmt/ansible下面。</p>
<p>运行TestbedProcessing.py脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python TestbedProcessing.py -i testbed.yaml</span><br><span class="line">options:</span><br><span class="line">-i &#x3D; 解析testbed.yaml文件</span><br><span class="line">-basedir &#x3D; 项目的根目录</span><br><span class="line">-backup &#x3D; 文件的备份文件夹</span><br></pre></td></tr></table></figure>

<h4 id="VMS命令"><a href="#VMS命令" class="headerlink" title="VMS命令"></a>VMS命令</h4><p>开启VMS（使用vms_1）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh start-vms vms_1 password.txt</span><br></pre></td></tr></table></figure>
<p>停止VMS（使用vms_1）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh stop-vms vms_1 password.txt</span><br></pre></td></tr></table></figure>

<h3 id="部署（PTF32）拓扑容器"><a href="#部署（PTF32）拓扑容器" class="headerlink" title="部署（PTF32）拓扑容器"></a>部署（PTF32）拓扑容器</h3><p>在这篇指南中，将会使用testbed-cli.sh添加ptf32-1作为示例</p>
<p>移除拓扑 ptf32-1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh remove-topo ptf32-1 password.txt</span><br></pre></td></tr></table></figure>

<p>添加拓扑 ptf32-1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh add-topo ptf32-1 password.txt</span><br></pre></td></tr></table></figure>
<p>可以使用”docker ps”或者”dokcer container ls”命令去检查是否添加或移除。</p>
<h3 id="运行第一个测试用例（Neighbour）"><a href="#运行第一个测试用例（Neighbour）" class="headerlink" title="运行第一个测试用例（Neighbour）"></a>运行第一个测试用例（Neighbour）</h3><p>当VMs和ptf32-1拓扑成功添加后，第一个测试用例“neighbour”就可以运行起来了。testbed的名字和测试用例的名字需要通过变量声明出来。请检查一下，之后，playbook就可以运行了。<br>运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export TESTBED_NAME&#x3D;ptf32-1</span><br><span class="line">export TESTCASE_NAME&#x3D;neighbour</span><br><span class="line">echo $TESTBED_NAME</span><br><span class="line">echo $TESTCASE_NAME</span><br><span class="line">ansible-playbook -i lab -l sonic-ag9032 test_sonic.ynl -e testbed_name&#x3D;$TESTBED_NAME -e testcase_name&#x3D;$TESTCASE_NAME</span><br></pre></td></tr></table></figure>

<h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><p>问题：Testbed命令行提示没有password文件<br>解决方式：创建一个空的password文件去绕过这个问题</p>
<p>问题：即使在我运行完stop-vms命令后IPs不可达<br>解决方式：如果运行了stop-vms命令后这个问题依然存在，运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virsh</span><br><span class="line">list</span><br><span class="line">destory VM_Name (删除占用这个IP的VM)</span><br><span class="line">exit(退出virsh)，在永久删除这个IPs前请确保没有其它VM使用这个IPs</span><br></pre></td></tr></table></figure>

<p>问题：任务设置失败。SSH Error：data could not be sent to the remote host<br>解决方式：导致这个现象的问题可能有很多。<br>    1. 确保这台主机可以通过SSH到达<br>    2. group_vars/all/lab_info.json文件中包含了正确的凭证吗？<br>    3. 设备在files/sonic_lab_devices.cav中有正确的hwsku吗？<br>    4. 确保lab文件中在IPs后面没有”/“，INI文件无法识别<br>    5. 重新检查testbed.yaml配置文件，是否获取了IPs和正确的凭证</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/15/SONiC%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/SONiC%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">SONiC编译简述及优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-15 09:58:41" itemprop="dateCreated datePublished" datetime="2020-12-15T09:58:41+00:00">2020-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SONiC/" itemprop="url" rel="index"><span itemprop="name">SONiC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>SONiC在docker中完成编译，docker image基于debian(jessie, stretch, buster)完成构建。201807及其之前的版本使用的是jessie, 202006及其之后的版本使用的是buster, 我们现阶段主要使用stretch。SONiC的编译大致分成三个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. git submodules初始化。对应make init</span><br><span class="line">2. 编译环境构建。对应的是Makefile.work中的DOCKER_BASE_BUILD与DOCKER_BUILD，编译环境只需要在第一次使用时进行构建。</span><br><span class="line">3. 主目标编译（sonic-platform.bin）。这里面可以分为kernel编译，外部功能编译（platform, src等），根文件系统的构建。对应的是make target&#x2F;sonic-platform.bin.</span><br></pre></td></tr></table></figure>

<h1 id="submodules初始化优化建议"><a href="#submodules初始化优化建议" class="headerlink" title="submodules初始化优化建议"></a>submodules初始化优化建议</h1><p>执行<code>make init</code>之前，项目文件大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[rancho git]$ du -h --max-depth&#x3D;1</span><br><span class="line">76M     .&#x2F;bytedance-sonic</span><br></pre></td></tr></table></figure>
<p>执行之后的项目文件大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[rancho git]$ du -h --max-depth&#x3D;1</span><br><span class="line">1.9G     .&#x2F;bytedance-sonic</span><br></pre></td></tr></table></figure>
<p>整个过程耗时约22分钟（网络环境不同会有差异），总共27个外部modules。只会在第一次编译项目时进行构建。基于项目管控以及子模块自开发的角度，后续可以将modules迁移到内部gitlab上。字节项目中的sonic-platform-common模块现在就是这样管理的。</p>
<h1 id="编译环境构建的优化"><a href="#编译环境构建的优化" class="headerlink" title="编译环境构建的优化"></a>编译环境构建的优化</h1><p>SONiC通过Dockerfile对每个用户都构建一个编译环境，对于单用户环境这种方式合适，对于使用Linux服务器的<strong>多用户环境</strong>而言，这种方式很不合适，docker image应该给所有用户复用，而不是针对每个用户构建一个内容相同只是名字不同的image。</p>
<h2 id="缺点说明"><a href="#缺点说明" class="headerlink" title="缺点说明"></a>缺点说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 消耗大量存储资源。可使用docker images | grep sonic 查看。</span><br><span class="line">2. 消耗大量网络资源，构建时下载重复数据</span><br><span class="line">3. 消耗大量时间，通过源码完成编译环境的构建大概需要一小时，使用优化后的方法只需要一分钟乃至更少</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>复用相同版本的docker镜像进行编译</p>
<h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><h3 id="对于复用docker镜像搭建编译环境的用户"><a href="#对于复用docker镜像搭建编译环境的用户" class="headerlink" title="对于复用docker镜像搭建编译环境的用户"></a>对于复用docker镜像搭建编译环境的用户</h3><ol>
<li><p><code>docker images</code>查看服务器上是否有所需版本的image, image命名规则为:sonic-version-debian_version, tag为public，例如:sonic-201911-stretch:public，如果有了,跳过步骤2；</p>
</li>
<li><p>获取对应版本image的tar.gz文件</p>
<ol>
<li>我在10.204.112.46上搭建了一个文件服务器，201911-stretch的编译镜像存放在上面，可以通过该链接<code>http://10.204.112.46:8081/sonic-201911/sonic-201911-stretch.tar.gz</code>获取</li>
<li><code>gzip -d sonic-version-debian_version.tar.gz</code></li>
<li><code>docker load --input sonic-version-debian_version.tar</code></li>
</ol>
</li>
<li><p>修改Makefile, 文件位于项目根目录下</p>
<ol>
<li><p>修改Makefile文件如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;Makefile b&#x2F;Makefile</span><br><span class="line">index 13a3f247..542f4077 100644--- a&#x2F;Makefile+++ b&#x2F;Makefile</span><br><span class="line">@@ -1,6 +1,6 @@ </span><br><span class="line"># SONiC make file </span><br><span class="line">-NOJESSIE ?&#x3D; 0</span><br><span class="line">+NOJESSIE ?&#x3D; 1</span><br></pre></td></tr></table></figure>
<p>如果是202006及其之后的版本，将stretch也注释掉。我们只需要用于编译的环境。</p>
</li>
<li><p>修改Makefile.work文件如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;Makefile.work b&#x2F;Makefile.work</span><br><span class="line">index 14c433e4..e7232264 100644</span><br><span class="line">--- a&#x2F;Makefile.work</span><br><span class="line">+++ b&#x2F;Makefile.work</span><br><span class="line">@@ -78,10 +78,12 @@ SLAVE_DIR &#x3D; sonic-slave-stretch</span><br><span class="line">endif</span><br><span class="line">-   SLAVE_BASE_TAG &#x3D; $(shell CONFIGURED_ARCH&#x3D;$(CONFIGURED_ARCH) j2 $(SLAVE_DIR)&#x2F;Dockerfile.j2 &gt; $(SLAVE_DIR)&#x2F;Dockerfile &amp;&amp; sha1sum $(SLAVE_DIR)&#x2F;Dockerfile | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">-   SLAVE_TAG &#x3D; $(shell cat $(SLAVE_DIR)&#x2F;Dockerfile.user $(SLAVE_DIR)&#x2F;Dockerfile | sha1sum | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">-   SLAVE_BASE_IMAGE &#x3D; $(SLAVE_DIR)</span><br><span class="line">-   SLAVE_IMAGE &#x3D; $(SLAVE_BASE_IMAGE)-$(USER)</span><br><span class="line">+   #SLAVE_BASE_TAG &#x3D; $(shell CONFIGURED_ARCH&#x3D;$(CONFIGURED_ARCH) j2 $(SLAVE_DIR)&#x2F;Dockerfile.j2 &gt; $     (SLAVE_DIR)&#x2F;Dockerfile &amp;&amp; sha1sum $(SLAVE_DIR)&#x2F;Dockerfile | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">+   #SLAVE_TAG &#x3D; $(shell cat $(SLAVE_DIR)&#x2F;Dockerfile.user $(SLAVE_DIR)&#x2F;Dockerfile | sha1sum | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">+   SLAVE_TAG &#x3D; public</span><br><span class="line">+   #SLAVE_BASE_IMAGE &#x3D; $(SLAVE_DIR)</span><br><span class="line">+   #SLAVE_IMAGE &#x3D; $(SLAVE_BASE_IMAGE)-$(USER)</span><br><span class="line">+   SLAVE_IMAGE &#x3D; sonic-201911-stretch</span><br><span class="line"> </span><br><span class="line">OVERLAY_MODULE_CHECK :&#x3D; \</span><br><span class="line"> lsmod | grep -q &quot;^overlay &quot; &amp;&gt;&#x2F;dev&#x2F;null || \</span><br><span class="line">@@ -113,6 +115,7 @@ DOCKER_RUN :&#x3D; docker run --rm&#x3D;true --privileged \</span><br><span class="line"> -w $(DOCKER_BUILDER_WORKDIR) \</span><br><span class="line"> -e &quot;http_proxy&#x3D;$(http_proxy)&quot; \</span><br><span class="line"> -e &quot;https_proxy&#x3D;$(https_proxy)&quot; \</span><br><span class="line">+   -u root \</span><br><span class="line"> -i$(if $(TERM),t,)</span><br><span class="line"></span><br><span class="line">@@ -200,9 +202,9 @@ endif</span><br><span class="line">    @$(OVERLAY_MODULE_CHECK)</span><br><span class="line">    </span><br><span class="line">-       @docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">-           &#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">-           $(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">+       #@docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">+           #&#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">+           #$(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">        @docker inspect --type image $(SLAVE_IMAGE):$(SLAVE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">            &#123; echo Image $(SLAVE_IMAGE):$(SLAVE_TAG) not found. Building... ; \</span><br><span class="line">            $(DOCKER_BUILD) ; &#125;</span><br><span class="line">@@ -222,9 +224,9 @@ sonic-slave-build :</span><br><span class="line"> </span><br><span class="line">sonic-slave-bash :</span><br><span class="line">        @$(OVERLAY_MODULE_CHECK)</span><br><span class="line">-       @docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">-           &#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">-           $(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">+       #@docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">+           #&#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">+           #$(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">        @docker inspect --type image $(SLAVE_IMAGE):$(SLAVE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">            &#123; echo Image $(SLAVE_IMAGE):$(SLAVE_TAG) not found. Building... ; \</span><br><span class="line">            $(DOCKER_BUILD) ; &#125;</span><br><span class="line">@@ -232,7 +234,7 @@ sonic-slave-bash :</span><br><span class="line"> </span><br><span class="line">showtag:</span><br><span class="line">        @echo $(SLAVE_IMAGE):$(SLAVE_TAG)</span><br><span class="line">-       @echo $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG)</span><br><span class="line">+       #@echo $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将SLAVE_IMAGE和SLAVE_TAG修改为复用image及其tag，抛弃SLAVE_BASE_IMAGE的使用。</p>
</li>
<li><p>通过<code>make showtag</code>检查编译环境是否加载正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+++ Making showtag +++</span><br><span class="line">BLDENV&#x3D;stretch make -f Makefile.work showtag</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;home&#x2F;rancho&#x2F;workdir&#x2F;SONIC-DEV&#x2F;sonic-buildimage&#39;</span><br><span class="line">sonic-201911-stretch:public</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;rancho&#x2F;workdir&#x2F;SONIC-DEV&#x2F;sonic-buildimage&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="对于发布docker编译环境供大家使用的用户"><a href="#对于发布docker编译环境供大家使用的用户" class="headerlink" title="对于发布docker编译环境供大家使用的用户"></a>对于发布docker编译环境供大家使用的用户</h3><ol>
<li><p>按照原有的方式完成编译环境的构建</p>
</li>
<li><p>发布编译环境</p>
<ol>
<li>使用<code>docker tag image-id sonic-version-debian_version:tag</code>进行规法镜像命名</li>
<li>使用<code>docker rmi old_name:old_tag</code>删除生成的镜像tag</li>
<li>使用<code>docker save -o ~/sonic-version-debian_version.tar sonic-version-debian_version:public</code>提取镜像</li>
<li>使用<code>gzip sonic-version-debian_version.tar</code>压缩</li>
<li>将sonic-version-debian_version.tar.gz文件放到文件服务器上供大家使用</li>
</ol>
</li>
</ol>
<h1 id="对于主目标编译"><a href="#对于主目标编译" class="headerlink" title="对于主目标编译"></a>对于主目标编译</h1><p>这里面有个<code>target groups</code>的概念, 在slave.mk里面定义了很多目标组，如SONIC_MAKE_DEBS, SONIC_MAKE_FILES，这些目标组在具体的功能模块中被填充，之后被该组的cmd所执行。参见README.buildsystem.md将会有更好的理解。<br>对于根文件系统的构建，时间很久，主要是每次都会删除之前构建的rootfs然后使用<code>debootstrap</code>重新构建，后续如果需要进行上层功能调试这明显效率很低。这里可以通过替换调试功能所在docker完成快速版本迭代。以路由协议frr举例。</p>
<pre><code>1. make list | grep frr 找到 target/docker-fpm-frr.gz
2. 修改src/sonic-frr中的代码
3. make target/docker-fpm-frr.gz生成新的frr镜像
4. 在SONiC设备上`service bgp stop`停止docker-fpm-frr，并删除该container，删除docker-fpm-frr:latest镜像
5. 将新的镜像拷贝到设备中`docker load -i docker-fpm-frr.gz`，并为之打上latest的tag
6. `service bgp start`重启frr服务，进行代码验证
7. service bgp如果找不到对应的container，则会根据docker-fpm-frr:latest重新创建一个，所以如果需要版本回退，重4,5,6的动作即可
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/08/05/Linux%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/05/Linux%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">Linux下程序调试方法简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-05 14:58:02" itemprop="dateCreated datePublished" datetime="2020-08-05T14:58:02+00:00">2020-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文旨在综合性的描述Linux下程序调试的方法和思路，不会过于细节的描述某种工具的使用，如gdb，这些方法通过man以及google都能找到答案。包含知识点：strip, addr2line, strace, gdb, readelf。</p>
<h2 id="strip相关"><a href="#strip相关" class="headerlink" title="strip相关"></a>strip相关</h2><p>嵌入式系统要求小巧精简，最大限度去除冗余数据。Linux下编译出来elf文件是带有符号表的，通过<code>nm</code>命令可以查看，如：<br><img src="https://rancho333.gitee.io/uploads/nm.png"><br>这些符号表是进行程序调试的关键，例如通过<code>addr2line</code>进行地址和文件名或行数的转换，例如在<code>gdb</code>中通过<code>bt</code>显示函数调用栈信息，没有符号表这些工具都无法提供有价值信息。<br><code>strip</code>命令可以去掉这些符号信息，进而减小文件大小，同时不会影响elf的正常执行。<br><img src="https://rancho333.gitee.io/uploads/compare.png"><br>可以看到，<code>strip app</code>之后，app中没有符号表相关信息了。<br>在进行rootfs制作时，对于发行版本，我们进行<code>strip</code>操作，对于开发人员调试版本，我们保留符号表信息。<br><img src="https://rancho333.gitee.io/uploads/strip.png"></p>
<h2 id="gdb简述"><a href="#gdb简述" class="headerlink" title="gdb简述"></a>gdb简述</h2><p>遇到<code>core dump</code>最常使用的就是<code>gdb</code>了，<code>gdb</code>的一般使用方法<code>gdb app core</code>。常见子命令如下：</p>
<table>
<thead>
<tr>
<th align="left">cmd</th>
<th align="left">function</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bt</td>
<td align="left">回溯显示app堆栈</td>
</tr>
<tr>
<td align="left">bt full</td>
<td align="left">不仅仅显示栈帧，还显示局部变量</td>
</tr>
<tr>
<td align="left">info reg</td>
<td align="left">显示寄存器内容</td>
</tr>
<tr>
<td align="left">run</td>
<td align="left">执行app</td>
</tr>
<tr>
<td align="left">print val</td>
<td align="left">打印变量val的值</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">设置断点</td>
</tr>
</tbody></table>
<p>gdb一般使用<em>断点</em>和<em>堆栈</em>进行程序调试，注意调试的程序一定要是<code>not stripped</code>的。<br>简单示例如下：<br><img src="https://rancho333.gitee.io/uploads/gdb.png"></p>
<h2 id="strace介绍"><a href="#strace介绍" class="headerlink" title="strace介绍"></a>strace介绍</h2><p>strace可以跟踪app的<code>system call</code>和<code>signals</code>，一般使用方法<code>strace app</code>，常见参数如下：</p>
<table>
<thead>
<tr>
<th align="left">cmd</th>
<th align="left">function</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-tt</td>
<td align="left">在每行输出的前面，显示毫秒级别的时间</td>
</tr>
<tr>
<td align="left">-T</td>
<td align="left">显示每次系统调用所花费的时间</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">对于某些相关调用，把完整的环境变量，文件stat结构等打出来</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">跟踪目标进程，以及目标进程创建的所有子进程</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">控制要跟踪的事件和跟踪行为,比如指定要跟踪的系统调用名称</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">把strace的输出单独写到指定的文件</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是32个字节</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">指定要跟踪的进程pid, 要同时跟踪多个pid, 重复多次-p选项即可</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">在打印系统调用同时打印指令指针</td>
</tr>
</tbody></table>
<p>举个之前在ENOS飞腾移植过程中的一个例子，先使用gdb做一个基本的错误定位</p>

<p>看起来像是没有进入main函数就已经挂了。<br>使用strace查看命令执行过程中的系统调用和信号：<br><img src="https://rancho333.gitee.io/uploads/strace2.png"><br>找到源码中的对应位置：<br><img src="https://rancho333.gitee.io/uploads/strace3.png"><br>iv_signal_init在main函数之前会执行并挂掉，将之注释掉测试通过。</p>
<h2 id="so库相关"><a href="#so库相关" class="headerlink" title="so库相关"></a>so库相关</h2><p>使用<code>ldd</code>命令可以查看app的依赖库，<code>readelf</code>命令可以获取到更多的内容<br><img src="https://rancho333.gitee.io/uploads/so.png"></p>
<p>如果app的依赖库找不到，报错格式一般如下：<br><img src="https://rancho333.gitee.io/uploads/find.png"></p>
<p>这里面缺少一些动态库，二进制可执行文件，分3种情况：</p>
<ol>
<li>文件不存在</li>
<li>文件存在但路径不对, /etc/ld.so.conf 此文件记录了编译时使用的动态库的路径</li>
<li>有些文件不必须，可以注释掉，参考<br>根据不同的情况处理之。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/16/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">Linux系统移植简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 14:12:38" itemprop="dateCreated datePublished" datetime="2020-03-16T14:12:38+00:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>之前也做过一些移植性的东西，不过都是别人搭好框架，自己填充一些模块，这次有机会完成系统级的移植，非常感谢张总以及胡老师的指点帮助，收获良多！</p>
<h1 id="移植总述"><a href="#移植总述" class="headerlink" title="移植总述"></a>移植总述</h1><p>嵌入式系统移植分为四个大块，分别是构建交叉编译工具，rootfs的制作，kernel的配置、编译、移植，BootLoader的移植。需要移植的系统可以在MIPS上跑起来，我只需要顺着原有的编译框架完成ARM64的编译，之后再上板子做具体的调试。</p>
<h2 id="构建交叉编译工具"><a href="#构建交叉编译工具" class="headerlink" title="构建交叉编译工具"></a>构建交叉编译工具</h2><p>toolchain一般芯片厂家会提供，当然自己通过buildroot构建也是可以的。<br>使用buildroot构建交叉编译工具，下载buildroot2015</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;buildroot.uclibc.org&#x2F;downloads&#x2F;buildroot-2015.08.tar.gz</span><br></pre></td></tr></table></figure>
<p><code>make menuconfig ARCH=arm64</code>配置buildroot，将target和toolchain两项配置成如下所示<br><img src="https://rancho333.gitee.io/uploads/buildroot.png"><br>之后<code>make</code>等待完成即可，buildroot有些源码下载速度很慢，下载网站也不尽相同，比较麻烦，不像Linux发行版可以改成国内镜像软件源，有的可能会等待比较长的时间。<br>将生成的toolchain打包，释放到服务器docker编译环境中，如下所示：<br><img src="https://rancho333.gitee.io/uploads/toolchain.png"><br>之后可以根据container构建image将编译环境发布出去，大家就可以直接使用了。</p>
<h2 id="kernel的配置、编译、移植"><a href="#kernel的配置、编译、移植" class="headerlink" title="kernel的配置、编译、移植"></a>kernel的配置、编译、移植</h2><p>kernel的配置结果保存在<code>.config</code>文件中，根据实际的需求会选配一些内核选项，如开启nat以及veth相关的配置<br><img src="https://rancho333.gitee.io/uploads/nat.png"><br><img src="https://rancho333.gitee.io/uploads/veth.png"><br>这些配置实际上是系统构建完成后跑起来报错才知道需要的，只需要在<code>make menuconfig</code>中搜索对应关键字即可找到编译选项。<br>关于内核编译的一些说明，可以参考这篇文章<br><a href="https://rancho333.gitee.io/2020/03/11/kernel%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/">kernel编译简述</a></p>
<h2 id="rootfs的制作"><a href="#rootfs的制作" class="headerlink" title="rootfs的制作"></a>rootfs的制作</h2><p>在这一步其实花的时间是最多的，因为这里涉及到大量的上层应用模块的编译，然后这些模块的依赖库在交叉工具链中是不存在的，还有部分是需要编译一些独立的Linux命令。解决办法很简单，下载源码，编译出库，之后放到交叉工具链和文件系统中即可。<br>这里说下开源代码交叉编译的经典三部曲<code>configure, make, make install</code>，在configure中会指定交叉编译工具，编译生成文件的install路径,关于动态库的一些理解可以查看这篇文章<br><a href="https://rancho333.gitee.io/2020/02/26/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E5%BA%93%E4%BB%A5%E5%8F%8Aconstructor%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/">关于动态库以及constructor属性的使用</a><br>嗯，rootfs以前一直用buildroot来制作，这里发现一个不一样的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用mktemp命令创建一个临时文件</span><br><span class="line">2. 使用shell命令构建文件系统，就是echo命令然后重定向到临时文件</span><br><span class="line">3. 使用gen_init_cpio和压缩软件构建cpio格式的压缩包</span><br><span class="line">4. 删除临时文件</span><br></pre></td></tr></table></figure>
<p><img src="https://rancho333.gitee.io/uploads/rootfs.png"></p>
<h2 id="BootLoader的移植"><a href="#BootLoader的移植" class="headerlink" title="BootLoader的移植"></a>BootLoader的移植</h2><p>给的开发板上直接烧有uboot，所以这里不涉及自己构建bootloader了。在bring up的过程中遇到一个问题卡了很久：<br><img src="https://rancho333.gitee.io/uploads/panic.png"><br>返回错误8的含义<code>文件没有可执行权限</code>,确认过busybox的执行权限，并且是静态编译，并且可以在同平台的其它机器上执行。<br>真实的错误是kernel在rootfs中没有找到文件系统，比较详细的描述见上文提到的<code>kernel编译简述</code>。</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kernel-style/p/3397705.html">linux init启动分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/11/kernel%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/kernel%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">kernel编译简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-11 15:48:46" itemprop="dateCreated datePublished" datetime="2020-03-11T15:48:46+00:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在ENOS系统移植的过程中，对于Linux kernel，涉及到kernel的配置，编译，以及二进制镜像uImage的生成。这篇文章分为两块：</p>
<ol>
<li>内核配置系统浅析</li>
<li>vmlinux,uImage,Image的关系或区别</li>
</ol>
<h1 id="内核配置系统浅析"><a href="#内核配置系统浅析" class="headerlink" title="内核配置系统浅析"></a>内核配置系统浅析</h1><p>Linux采用模块化的内核配置系统，保证了内核的可扩展性。Linux内核的配置系统由三个部分组成，分别是：</p>
<ol>
<li>Makefile：分部在Linux内核源码中的Makefile，定义Linux内核的编译规则</li>
<li>配置文件（.config, Kconfig等）</li>
<li>配置工具<ol>
<li>配置命令解释器，对配置脚本中使用的配置命令进行解释</li>
<li>配置用户界面，分为基于字符（make config）,基于Ncurses图形界面（make menuconfig），基于Xwindows图形界面（make xconfig）</li>
</ol>
</li>
</ol>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>Makefile的作用是根据配置的情况，构造出需要编译的源文件列表，然后分别编译，并把目标代码链接到一起，最终形成Linux内核二进制文件。kernel中Makefile相关的文件有：</p>
<ol>
<li>顶层Makefile，是整个内核配置、编译的总体控制文件，产生vmlinux文件和内核模块（module）</li>
<li>.config：内核配置文件，是执行完内核配置的结果，如果没有指定kernel根目录下没有.config，可以在make时指定特定的配置文件进行编译，之后也会在根目录下产生.config</li>
<li>arch/*/Makefile：不同CPU体系的Makefile，系统移植需要多关注一些这部分</li>
<li>各子目录下的Makefile，如drivers下的，负责所在子目录下源代码的管理</li>
<li>Rules.make：规则文件，被所有的Makefile使用</li>
</ol>
<p>用户通过make config后，这里实际就是收集各目录下的Kconfig/deconfig文件生成配置界面，供用户进行功能选择，最后产生<code>.config</code>，如果.config文件存在，则是直接通过.config生成配置界面。顶层Makefile读入.config中的配置选择进行具体模块的编译。顶层Makefiel中会包含具体arch的Makefile<br><img src="https://rancho333.gitee.io/uploads/arch.png"><br>Rules.make其实就是不同模块之间会共用到的Makefile规则。</p>
<p>在ENOS中，系统架构人员将生成好的ARCH的config文件存放ARCH的目录下，上层开发人员编译时直接使用指定的config文件编译即可。<br><img src="https://rancho333.gitee.io/uploads/config.png"><br>之后在指定的<code>O</code>目录下会生成编译过程中生成的文件，这样可以避免污染源码（make clean不能清除么），或者是更便于管理和模块化考虑。<br>如果需要进行kernel的二次配置，需要到<code>O</code>目录下去执行make menuconfig，之后将重新生成的<code>.config</code>拷回<code>ARCH</code>目录覆盖之前的配置文件。这是基于ARCH缺省配置的一种应用，在向内核代码增加了新的功能后，如果新功能对于这个ARCH是必需的，就需要修改此ARCH的缺省配置，修改方法如下：</p>
<ol>
<li>备份.config文件</li>
<li>cp arch/arm/deconfig .config</li>
<li>修改.config</li>
<li>cp .config arch/arm/deconfig</li>
<li>恢复.config</li>
</ol>
<h3 id="配置变量CONFIG"><a href="#配置变量CONFIG" class="headerlink" title="配置变量CONFIG_*"></a>配置变量CONFIG_*</h3><p>.config文件中用配置变量等式来说明用户的配置结果，等式左边是模块/功能,右侧是控制选项，有三种：</p>
<ol>
<li><code>y</code>表示后本编译选项对用的内核代码被静态编译进Linux内核</li>
<li><code>m</code> 表示本编译选项对应的内核代码被编译成模块</li>
<li><code>n</code>表示不选择此编译选项<br>如果根本没有选择某模块，该模块是被注释掉的</li>
</ol>
<h1 id="vmlinux-uImage-Image的关系或区别"><a href="#vmlinux-uImage-Image的关系或区别" class="headerlink" title="vmlinux,uImage,Image的关系或区别"></a>vmlinux,uImage,Image的关系或区别</h1><p>Linux内核有多种格式的镜像，包括vmlinux、Image、zImage、bzImage、uImage、xipImage、bootpImage等。<br>vmlinux是编译出来的最原始的内核文件，未经压缩，vm代表virtual memory Linux支持虚拟内存；<br>Image是经过objcopy处理的只包含二进制数据的内核代码，未经压缩，不是elf格式；objcopy的实质是将所有的符号和 重定位信息都抛弃，只剩下二进制数据。<br>zImage是vmlinux加上解压代码经gzip压缩而成，是ARM linux常用的一种压缩镜像文件。这种格式的Linux镜像多存放在NAND上。bzImage与之类似，只不过是采用了压缩率更高的算法。<br>uImage是uboot专用的镜像文件，它是在zImage之前加上一个长度为0x40的tag，里面包含了镜像文件的类型、加载位置、生成时间、大小等信息。通过mkimage命令可以制作uImage。<br>xipImage多放在NorFlash上直接运行。<br>这里只是一些简单的描述，有待在今后的项目中去加深理解各种格式的使用，存在肯定是有其对应的使用场景的！<br><img src="https://rancho333.gitee.io/uploads/vmlinux.png"></p>
<h1 id="对于文件系统的一点理解"><a href="#对于文件系统的一点理解" class="headerlink" title="对于文件系统的一点理解"></a>对于文件系统的一点理解</h1><p>加在这里可能不是很符合这篇文章的主题！<br>Linux下一切皆文件。Linux系统中任何文件系统的挂载必须满足两个条件：挂载点和文件系统。rootfs之所以存在，是因为需要在VFS机制下给系统提供最原始的挂载点。<br>rootfs其实就是文件系统顶层的<code>/</code>，使用pwd命令后看到的第一个字符，它有三个特点：</p>
<ol>
<li>它是系统自己创建并加载的第一个文件系统，是Linux内核自己创建的，并不是我们常说的外部根文件系统，将外部根文件系统解压或者说挂载到<code>/</code>后就是用户能看到的Linux文件系统，里面有很多的文件夹，如’etc’、’bin’等。<em>不能被unmount或者删除</em>，通过<code>cat /proc/mounts</code>也可以看出。下述的rootfs特指<code>/</code></li>
<li>该文件系统的挂载点就是它自己的根目录项对象</li>
<li>该文件系统仅仅存在于内存中<br>VFS是Linux文件系统实现遵循的一种机制，rootfs是一种是一种具体实现的文件系统，Linux下所有文件系统的实现都必须符合VFS机制（符合VFS的接口），这是二者的真正关系。</li>
</ol>
<p>Linux系统移植过程有一项是制作根文件系统，这里所谓的根文件系统实际上是外部根文件系统，用来释放到rootfs里面。有几个概念<code>ramfs initramfs</code>，ramfs是linux中的一个内存文件系统,initramfs是一种压缩（可以是lzma，zip等，看kernel的支持情况）的cpio格式的归档文件，initrd（initramdisk）也是一中ramfs镜像文件，它是用来在启动过程中初始化系统的，它可以被卸载。区别如下：</p>
<ol>
<li>它必须是和kernel分离的一种形式存在</li>
<li>他只是一个zip压缩的文件系统，而不是cpio文件</li>
<li>initrd中的/initrd程序只是做一些setup操作并最后返回到kernel中执行，而initramfs中的/init执行完后不返回到kernel</li>
</ol>
<p>对于initramfs，也就是系统移植时需要制作的文件系统。它存在于两处，一种是内核编译后自动生成的内部initramfs(在/usr目录下)，另一种是用户自己制作的，通过cmdline将地址传递给kernel的外部initramfs<br>对于内部initramfs，这个文件系统里面实际上啥也没有：<br><img src="https://rancho333.gitee.io/uploads/initramfs_kernel.png"><br>rootfs挂载之后，首先会先释放这个内部的initramfs到rootfs（很显然啥也干不了！<em>没搞清楚为什么会存在，但肯定有原因！</em>）,然后kernel会尝试在rootfs中寻找/init，一旦找到就执行init，kernel也就完成了启动工作，之后init就会接管接下来的工作。如果kernel找不到，就会去找外部initramfs然后释放（uboot下通过initrd参数指定位置）或者按照标准做法解析参数<code>root=</code>（这里面是解压好到某个介质分区的文件系统），试图找到一个文件系统并挂载到rootfs，之后就init。</p>
<p>所以我们实际使用的肯定是外部文件系统了，对于外部的文件系统，我们可以通过不同的方法将它挂载到rootfs。</p>
<ol>
<li>制作一个独立的cpio.lzma包，然后告诉bootloader它的地址，通过cmdline将参数传递给kernel</li>
<li>制作一个独立的包，通过mkimge(只针对于uboot)将kernel+initramfs+dtb打包成一个文件，在uboot下启动（实验过可行）</li>
<li>用外部的initramfs替换kernel自动生成的initramfs，有两种方法：<ol>
<li>先编译kernel，让它生成内部intramfs，然后制作外部initramfs，拷贝替换掉，最后重新编译内核。外部initramfs就会和kernel编成一个文件。ENOS里面使用的是这种方法。</li>
<li>使用内核编译选项CONFIG_INITRAMFS_SOURCE指定根文件系统路径，即kernel会根据给定的文件生成内部initramfs，这里面又有集中不同的给定方式，这里不表。<br><img src="https://rancho333.gitee.io/uploads/kernel_initramfs.png"><br>外部initramfs替换内部initramfs之后，kernel会在第一时间找到/init,所以<code>root=，initrd=</code>这些参数都不会起作用了。</li>
</ol>
</li>
</ol>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/kernel/l-kerconf/">Linux内核配置系统浅析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ultraman_hs/article/details/52838989">zImage和uImage的区别联系</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rikeyone/article/details/52048972">ramfs,rootfs,initramfs,initrd</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunjing_/article/details/53081306">initramfs的使用方法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/10/%E4%B8%AD%E6%96%AD%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/%E4%B8%AD%E6%96%AD%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">中断学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-10 16:07:13" itemprop="dateCreated datePublished" datetime="2020-03-10T16:07:13+00:00">2020-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在ENOS系统移植的过程中需要调试CPU和交换芯片的中断，这里记录一下对中断的学习！</p>
<h1 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h1><p>Linux内核需要对连接到计算机上的所有硬件设备进行管理，他们之间需要互相通信，一般有两种方案可以实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 轮询（polling）内核定期对设备的状态进行查询，然后做出相应的处理</span><br><span class="line">2. 中断（interrupt）让硬件在需要的时候向内核发出信号（变内核主动为硬件主动）</span><br></pre></td></tr></table></figure>
<p>轮询是周期性的重复执行，大量耗用CPU的时间，效率比较低，对于实时性比较高的操作，肯定是不适用的。</p>
<p>从物理学的角度看，中断是一种电信号，由硬件设备产生，并直接送入中断控制器（如8259A）的输入引脚上，然后再由中断控制器向CPU发送相应的信号。处理器检测到该信号，便中断当前正在处理的工作，转而去处理中断。对于软件开发人员，一般需要用到的就是中断号和中断处理函数。</p>
<p>提一下，PCIE可以通过MSI(message signaled interrupts)方式实现中断：<br><img src="https://rancho333.gitee.io/uploads/msi.png"><br>CPu里面有一段特殊的寄存器空间，往这个寄存器里面写数据，就会触发CPU中断。pci设备经过配置以后，一旦需要上报中断就会往cpu这种寄存器里面写一个值，触发cpu中断。</p>
<p>中断的处理流程：</p>
<ol>
<li>保存现场</li>
<li>执行中断</li>
<li>恢复被中断进程的现场，继续执行</li>
</ol>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>中断可分为同步（synchronous）中断和异步（asynchronous）中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 同步中断是当指令执行时由CPU控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后CPU才会发出中断，而不是在代码指令执行期间，比如系统调用</span><br><span class="line">2. 异步中断是指由其他硬件设备依照CPU时钟信号随机产生，即意味着中断能够在指令之间产生，例如键盘中断</span><br></pre></td></tr></table></figure>
<p>同步中断称为异常（exception），异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。<br>异步中断被称为中断（interrupt）,中断可分为可屏蔽中断（Maskable interrupt，外部设备产生的）和非屏蔽中断（Nomaskable interrupt，计算机内部硬件产生的）<br>异常是CPU发出的中断信号，与中断控制器无关，不能被屏蔽。</p>
<p>广义上讲中断可分为四类：中断、故障、陷阱、终止。它们之间的异同点参照下表。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">原因</th>
<th align="left">异步/同步</th>
<th align="left">返回行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td align="left">来自I/O设备的信号</td>
<td align="left">异步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td align="left">有意的异常</td>
<td align="left">同步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">故障</td>
<td align="left">潜在可恢复的错误</td>
<td align="left">同步</td>
<td align="left">返回到当前指令</td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left">不可恢复的错误</td>
<td align="left">同步</td>
<td align="left">不会返回</td>
</tr>
</tbody></table>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>常见的中断控制器有两种，两片8259A外部芯片’级联’和多级I/O APIC系统，见下图：<br><img src="https://rancho333.gitee.io/uploads/interrupt_ctl.png"><br>至于硬件实现细节这里不做过多描述。辨别一个系统是否正在使用I/O APIC，可以使用如下命令查看：<br><img src="https://rancho333.gitee.io/uploads/interrupts.png"><br>可以看到第6列上显示的是IO-APIC,如果上面显示的是XY-APIC，说明系统正在使用8259A芯片。<br>对上面文件的输出，解释如下：</p>
<ol>
<li>第一列表示IRQ中断号</li>
<li>第二、三、四、五列表示相应的CPu核心被中断的次数</li>
<li>第六列表示使用控制器</li>
<li>第七列表示硬件中断号和中断触发方式（电平或边沿）</li>
<li>第八列表示中断名称</li>
<li>有一些IRQ号会表示为NMI，LOC之类的，这是系统保留的，用户无法访问和配置</li>
</ol>
<p>此外，<code>/proc/interrupts</code>文件中列出的是当前系统使用的中断情况，如果某个中断处理没有安装（包括安装后卸载的），是不会显示的。但是<code>/proc/stat</code>会记录机器从启动开始各个中断序号发生中断的次数。</p>
<h2 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h2><p>x86中支持256种中断，将这些中断源按照0到255的顺序对没中中断进行编号，这个标号叫做中断向量，通常用8位无符号整数来存储这个向量。中断号与中断向量一一映射。<br>中断号和中断向量概念不同。当I/O设备把中断信号发送个中断控制器时，与之关联的是一个中断号；而当中断控制器将该中断信号传递给CPU时，与之关联的是一个中断向量。中断号是以中断控制器的角度而言的；中断向量则是以CPU的角度而言的。<br>通常，Intel将编号为0～31的向量分配给异常和非屏蔽中断。</p>
<h2 id="中断服务例程"><a href="#中断服务例程" class="headerlink" title="中断服务例程"></a>中断服务例程</h2><p>在响应一个具体的中断时，内核会执行一个函数，这个函数被称为中断服务例程（interrupt service routine, ISR）。每一个设备的驱动程序中都会定义相关的中断服务例程。</p>
<p>现今的中断处理流程都会分为两部分:上半部分（top half）和下半部分（bottom half），原因如下：</p>
<ol>
<li>中断可以随时打断CPU对其它程序的执行，如果被打断的代码对系统很重要，那么此时中断处理程序的执行时间应该越短越好</li>
<li>中断处理程序在执行时，会屏蔽同条中断线上的中断请求；如果设置了IRQF_DISABLE，那么该中断服务程序执行时是会屏蔽其他所有其它的中断请求。那么此时应该让中断处理程序执行的越快越好。</li>
</ol>
<p>这样划分是有一定原因的，因为我们必须有一个快速、异步而且简单的处理程序专门来负责对硬件的中断请求作出快速响应，与此同时也要完成那些对时间要求很严格的操作。而那些对时间要求相对宽松，其它的剩余工作则会在稍后的任意时间执行，也就是所谓的下半部分执行。</p>
<p>上半部分只能通过中断处理程序实现，下半部分可以通过多种机制来完成：小任务（tasklet），工作队列，软中断，不管是哪种机制，他们均为下半部分提供了一种执行机制，比上半部分灵活多了，至于何时执行，则由内核负责。</p>
<h1 id="第一个中断测试程序"><a href="#第一个中断测试程序" class="headerlink" title="第一个中断测试程序"></a>第一个中断测试程序</h1><p>了解了下中断的基本概念，下面就写一个小demo来实际测试一下吧。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux&#x2F;init.h&gt;                 </span><br><span class="line">#include &lt;linux&#x2F;kernel.h&gt;          </span><br><span class="line">#include &lt;linux&#x2F;module.h&gt;               </span><br><span class="line">#include &lt;linux&#x2F;moduleparam.h&gt;          </span><br><span class="line">#include &lt;linux&#x2F;interrupt.h&gt;       </span><br><span class="line">#include &lt;linux&#x2F;stat.h&gt;                 </span><br><span class="line">#include &lt;linux&#x2F;slab.h&gt;                                                                                                                                                                                           </span><br><span class="line">                                   </span><br><span class="line">static int irq &#x3D; 1;                 &#x2F;&#x2F;保存中断号irq</span><br><span class="line">static char *devname &#x3D; NULL;        &#x2F;&#x2F;保存中断名称*devname</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用宏module_param来接受参数</span><br><span class="line">module_param(irq, int, 00644);      &#x2F;&#x2F;S_IRUGO&#x3D;00644</span><br><span class="line">module_param(devname, charp, 00644);</span><br><span class="line">                                   </span><br><span class="line">&#x2F;&#x2F;定义一个结构体，在request_irq函数中的void *dev_id经常设置为结构体或NULL</span><br><span class="line">struct dev_info&#123;                   </span><br><span class="line">    int irq_id;                    </span><br><span class="line">    char *dev_name;                </span><br><span class="line">&#125;;                                 </span><br><span class="line">                                   </span><br><span class="line">struct dev_info *mydev_info &#x3D; NULL;</span><br><span class="line">                                   </span><br><span class="line">&#x2F;&#x2F;声明中断处理函数（上半部分）  </span><br><span class="line">static irqreturn_t myirq_handler(int irq, void *dev);</span><br><span class="line">                                   </span><br><span class="line">static int __init myirq_init(void)</span><br><span class="line">&#123;                                  </span><br><span class="line">    printk(&quot;zhw test:Module is working ...\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;分配struct dev_info结构体内存</span><br><span class="line">    mydev_info &#x3D; kmalloc(sizeof(struct dev_info), GFP_KERNEL);</span><br><span class="line">    if(!mydev_info)                </span><br><span class="line">    &#123;                              </span><br><span class="line">        printk(&quot;kmalloc failed!\n&quot;);</span><br><span class="line">        return -1;                 </span><br><span class="line">    &#125;                              </span><br><span class="line">    memset(mydev_info, 0, sizeof(struct dev_info));</span><br><span class="line">    mydev_info-&gt;irq_id &#x3D; irq;   </span><br><span class="line">    &#x2F;&#x2F;分配结构体struct dev_info-&gt;char *dev_name内存</span><br><span class="line">    mydev_info-&gt;dev_name &#x3D; kmalloc(10, GFP_KERNEL);</span><br><span class="line">    if(!mydev_info-&gt;dev_name)   </span><br><span class="line">    &#123;                              </span><br><span class="line">        printk(&quot;kmalloc 1 failed!\n&quot;);</span><br><span class="line">        return -1;                 </span><br><span class="line">    &#125;                              </span><br><span class="line">    mydev_info-&gt;dev_name &#x3D; devname;</span><br><span class="line"></span><br><span class="line">    if(request_irq(irq, &amp;myirq_handler, IRQF_SHARED, devname, mydev_info))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;%s request IRQ:%d failed\n&quot;, devname, irq);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(&quot;%s request IRQ:%d success..\n&quot;, devname ,irq);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void __exit myirq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;unloading my module ..\n&quot;);</span><br><span class="line">    free_irq(irq, mydev_info);</span><br><span class="line">    printk(&quot;freeing IRQ %d\n&quot;, irq);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static irqreturn_t myirq_handler(int irq, void *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct dev_info mydev;</span><br><span class="line">    static int count &#x3D; 1;</span><br><span class="line">    mydev &#x3D; *(struct dev_info *)dev;</span><br><span class="line"> </span><br><span class="line">    printk(&quot;key:%d\n&quot;, count);</span><br><span class="line">    printk(&quot;devname:%s. devid:%d\n is working..\n&quot;, mydev.dev_name, mydev.irq_id);</span><br><span class="line">    printk(&quot;ISR is leaving\n&quot;);</span><br><span class="line">    count++;</span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(myirq_init);</span><br><span class="line">module_exit(myirq_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>
<p>因为中断程序一般包含在某个设备的驱动程序中，所以这个程序本质就是一个内核模块。这里面主要就是驱动的初始化，退出，以及中断服务例程（ISR）。这里共享键盘的中断号，x86下键盘的中断号是1.<br>Makefile如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m:&#x3D;first_interrupt.o                                                                                                                                                                                          </span><br><span class="line">KDIR:&#x3D;&#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;build</span><br><span class="line">PWD:&#x3D;$(shell pwd)</span><br><span class="line"> </span><br><span class="line">default:</span><br><span class="line">    $(MAKE) -C $(KDIR) M&#x3D;$(PWD) modules</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">    rm -rf .*.cmd *.o *.mod.c *.ko .tmp_versions</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<ol>
<li>cat /proc/interrupts查看中断号，注意如果是使用ssh或telent到linux上的是不会响应键盘中断的，需要使用虚拟机来实验</li>
<li>加载驱动<code>sudo insmod ./first_interrupt.ko irq=1 devname=zhwirq</code></li>
<li>查看驱动<code>lsmod | grep first</code>,查看中断<code>cat /proc/interrupts | grep zhw</code></li>
<li>dmesg查看内核日志文件，dmesg | tail -20<br><img src="https://rancho333.gitee.io/uploads/dmesg.png"></li>
<li>卸载驱动<code>sudo rmmod first_interrupt</code></li>
</ol>
<p>加载驱动后，先进行驱动初始化，之后每当有键盘中断触发后，都会进入ISR，卸载驱动后不会再触发。</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2014-03/98012.htm">Linux下的中断（interrupt） 简介</a><br><a target="_blank" rel="noopener" href="http://edsionte.com/techblog/archives/1495">中断入门</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wordwarwordwar/article/details/81182910">PCI&amp;PCIE MSI中断</a><br><a target="_blank" rel="noopener" href="http://control.blog.chinaunix.net/uid-22666248-id-3052413.html">第一个中断驱动程序</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yzytr/article/details/77659302">如何编译内核ko</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/09/Linux%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/Linux%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/" class="post-title-link" itemprop="url">Linux密码修改</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-09 17:20:27" itemprop="dateCreated datePublished" datetime="2020-03-09T17:20:27+00:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在做交换机Linux系统移植的过程中，发现进入shell的密码还是上一家的默认密码，还是改改吧。简单交代一下，ENOS上kernel加载完成之后应用的启动顺序如下如：<br><img src="https://rancho333.gitee.io/uploads/inittab.png"><br>这里是不进入shell的，而是直接进入klish作为交换机的命令行交互界面，类似于quagga的vtysh。之后在<code>configure</code>视图下面执行<code>start shell</code>进入linux shell的。<br><img src="https://rancho333.gitee.io/uploads/shell.png"><br>在fnconvert里面会获取用户<code>root</code>的密码，其实就是使用<code>getspnam</code>获取<code>passwd或者shadow</code>的口令。既然这玩意使用的是Linux的账户和密码，那就是修改<code>/etc/passwd</code>文件了。<br><img src="https://rancho333.gitee.io/uploads/spnam.png"></p>
<h1 id="passwd文件简介"><a href="#passwd文件简介" class="headerlink" title="passwd文件简介"></a>passwd文件简介</h1><p>Linux中每个用户在/etc/passwd文件中都有一个对应的记录行，每一行被冒号<code>:</code>分隔为7个字段，具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：口令：用户标识号：组标识号：注释性描述：主目录：登陆shell</span><br></pre></td></tr></table></figure>
<p>发行版中口令字段一般是<code>*或x</code>，<code>*</code>表示账号锁定, <code>x</code>表示密码存放在<code>/etc/shadown</code>文件中（访问需要sudo权限，而passwd文件不需要），当然我们的嵌入式系统密文是直接放在passwd中，如下：<br><img src="https://rancho333.gitee.io/uploads/passwd.png"></p>
<p>其它字段除了<code>登陆shell</code>就没啥好玩的了，有些账号出于安全限制，并不会允许登陆进shell，而采用<code>nologin</code>的方式可以让这些用户使用部分系统功能。<br><img src="https://rancho333.gitee.io/uploads/nologin.png"></p>
<h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><p>常规的在linux命令行下面修改密码没啥好说的，直接敲<code>passwd</code>然后输入新密码就行了，之后你会发现<code>passwd或者shadow</code>中的口令发生变化了。这里介绍一下口令了列的组成，不同的特殊字符表示不同的特殊意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 该列留空，即&quot;::&quot;，表示该用户没有密码。</span><br><span class="line">2. 该列为&quot;!&quot;，即&quot;:!:&quot;，表示该用户被锁，被锁将无法登陆，但是可能其他的登录方式是不受限制的，如ssh公钥认证的方式，su的方式。</span><br><span class="line">3. 该列为&quot;*&quot;，即&quot;:*:&quot;，也表示该用户被锁，和&quot;!&quot;效果是一样的。</span><br><span class="line">4. 该列以&quot;!&quot;或&quot;!!&quot;开头，则也表示该用户被锁。</span><br><span class="line">5. 该列为&quot;!!&quot;，即&quot;:!!:&quot;，表示该用户从来没设置过密码。</span><br><span class="line">6. 如果格式为&quot;$id$salt$hashed&quot;，则表示该用户密码正常。其中$id$的id表示密码的加密算法，$1$表示使用MD5算法，$2a$表示使用Blowfish算法，&quot;$2y$&quot;是另一算法长度的Blowfish,&quot;$5$&quot;表示SHA-256算法，而&quot;$6$&quot;表示SHA-512算法。加密算法会根据salt进行特定的加密，hashed是生成的密文</span><br></pre></td></tr></table></figure>
<p>我看自己的linux服务器上面都是使用SHA-512加密的，而嵌入式系统上面用的是MD5，使用命令<br><img src="https://rancho333.gitee.io/uploads/openssl.png"><br>就可以生成密码了，将原来的口令字段替换掉即可完成密码的修改。</p>
<p>有个小问题，实验过程中，发现在嵌入式系统上直接在命令行中修改密码不是按照<code>$id$salt$hashed</code>模式生成的口令，而是：<br><img src="https://rancho333.gitee.io/uploads/abnormal.png"><br>但是在发行版Linux上面是符合预期的，有可能是嵌入式系统的某些差异吧，这里留个记录！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">计算机存储体系</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-08 17:00:34" itemprop="dateCreated datePublished" datetime="2020-03-08T17:00:34+00:00">2020-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在没有接触过嵌入式之前，对于计算机存储的认知仅限于知道硬盘和内存，然后硬盘掉电可以保存数据，内存掉电丢失数据。后来逐渐听到更多的专业名词，什么ROM，RAM，SRAM，DRAM，FLASH,，NandFlash，NorFlash等等了。以前将自己的定位总是局限在协议工程师，对于和硬件和驱动相关的东西有些抵触，随着工作的深入，也时常会用到一些I2C,gpio之类的东东。本着沉下来，归零，再出发的心态，这篇文章用来梳理一下自己对于计算机存储体系的认知。</p>
<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>下面这张图大家应该都很熟悉了<br><img src="https://rancho333.gitee.io/uploads/storage.png"><br>生活中的大部分物品，基本都满足“好的不一定是最贵的，但是最贵的一定是好的”，在计算机存储体系中，基本满足了上面这句话。塔尖上的那一小撮是最贵的，最快的，存储空间最小的。在实际生产中需要做到价格与性能（或者说实际需求）的平衡。下面从上到下梳理一下吧。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>恩，之前软考《网络工程师》的时候接触过一点点.哦，文章有点跑题了，但是还是想记录一下。CPU执行指令分为：取指令，分析指令，执行指令三部曲，这里面会用到一系列的寄存器，有分别属于控制器和运算器，列举几个常见的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制器</span><br><span class="line">    程序计数器PC：存放下一条指令的地址</span><br><span class="line">    指令寄存器IR:存放正在运行的指令</span><br></pre></td></tr></table></figure>
<p>指令包括操作码和地址码（操作数所在的地址）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运算器：</span><br><span class="line">    累加寄存器AC</span><br><span class="line">    数据缓冲寄存器</span><br><span class="line">    状态条件寄存器</span><br></pre></td></tr></table></figure>
<p>具体见下图：<br><img src="https://rancho333.gitee.io/uploads/register.png"><br>寄存器是CPU的内部组成单元，是CPU运算是取指令和数据最快的地方。当然不仅仅是CPU了，比如交换芯片及很多其它的ASIC都是用寄存器来实现某些功能的，你会发现芯片SDK提供的API最底层就是读写某些寄存器来实现具体功能。</p>
<h2 id="cache与主存"><a href="#cache与主存" class="headerlink" title="cache与主存"></a>cache与主存</h2><p>cache与主存都是RAM（Random-Access Memory, 随机访问存储器），cache使用的是静态SRAM，主存使用的是DRAM。这两种器件掉电数据都会丢失。</p>
<p>SRAM只要存储器保持通电，里面存储的数据就可以保持不变。<br>DRAM需要周期性的充电刷新，主存也就是我们PC中的内存条了。</p>
<h2 id="ROM与flash"><a href="#ROM与flash" class="headerlink" title="ROM与flash"></a>ROM与flash</h2><p>以前一直纳闷为啥只读存储还能改里面的数据。<br>ROM一般用来存放bootloader(一般叫做固件，firmware)，这里面的内容在程序运行期间是无法更改的，掉电数据依然存在。<br>早期ROM在工厂里用特殊方法烧录进去，一旦烧录进去，用户只能验证写入的资料是否正确，不能再做任何修改。<br>后来人们发明了PROM（Programmable ROM， 可编程ROM），工厂制作的PROM内部没有数据，用户可以使用专用的编程期间烧写资料进去，但只能写一次，一旦写入也无法修改。<br>再后来发明了EPROM（Erasable Programmable ROM, 可擦写可编程ROM），芯片可以重复擦除和写入，但是需要使用紫外线照射芯片，比较麻烦。<br>再后来发明了EEPROM（Electrically Erasable Programmable ROM，电可擦除可编程ROM）,用专门的烧录器和烧录软件就可以直接烧录了，很方便。现在用的ROM大部分是这种。</p>
<p>至于flash，咱们常见的u盘，固态硬盘灯都是基于flash中的NandFlash。flash分为NorFlash和NandFlash两种类型。<br>Nor的读取速度比Nand快一些，Nand的写入速度比Nor快很多，Nand的成本低，哈，这是很重要的。<br>Nand的读写操作是以块为单位的，Nor是以字节为单位。<br>NorFlash一般用来替代ROM用来存放BootLoader，容量较小，支持芯片内执行（XIP, eXecute In Place），Nand就是用来做大容量数据存储的啦！</p>
<p>顺带提一下eMMC，这玩意没见过。eMMC相当于NandFlash+主控IC ，对外的接口协议与SD、TF卡一样，主要是针对手机或平板电脑等产品的内嵌式存储器标准规格。eMMC的一个明显优势是在封装中集成了一个控制器。eMMC由一个嵌入式存储解决方案组成，带有MMC（多媒体卡）接口、快闪存储器设备（Nand Flash）及主控制器，所有都在一个小型的BGA 封装。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>其实就是RAM的分类，ROM的分类，以及Flash的分类有点迷！搞清楚特性，对应上用途！</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/iva_brother/article/details/80463578">计算机存储器结构体系详解</a><br><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1610041455262486965&wfr=spider&for=pc">NorFlash、NandFlash、eMMC闪存的比较与区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38880380/article/details/78884522">NAND flash和NOR flash的区别详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rancho"
      src="/uploads/Rancho.png">
  <p class="site-author-name" itemprop="name">Rancho</p>
  <div class="site-description" itemprop="description">No pain, no gain!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rancho333" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rancho333" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rancho</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
