<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/R-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/R-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rancho333.gitee.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="No pain, no gain!">
<meta property="og:type" content="website">
<meta property="og:title" content="Rancho Blog">
<meta property="og:url" content="https://rancho333.gitee.io/page/3/index.html">
<meta property="og:site_name" content="Rancho Blog">
<meta property="og:description" content="No pain, no gain!">
<meta property="og:locale">
<meta property="article:author" content="Rancho">
<meta property="article:tag" content="Racncho, Rancho Blog, 嵌入式">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rancho333.gitee.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Rancho Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rancho Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知行合一，致良知！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/31/SONiC%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84device/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/SONiC%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84device/" class="post-title-link" itemprop="url">SONiC添加新的device</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-31 11:16:17" itemprop="dateCreated datePublished" datetime="2020-12-31T11:16:17+00:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>SONiC项目中，有时候厂商需要添加自己新的device上去。</p>
<ol>
<li>需要添加那些东西？</li>
<li>怎么编译进文件系统？</li>
<li>SONiC启动时是如何选择对应设备的文件？</li>
</ol>
<p>搞清楚这三个问题后，我们就可以对device进行裁剪（SONiC默认会将device目录下所有文件拷贝进文件系统）。</p>
<h1 id="目录结构及添加内容"><a href="#目录结构及添加内容" class="headerlink" title="目录结构及添加内容"></a>目录结构及添加内容</h1><p>与设备硬件耦合的文件夹有两个，分别是<code>platform</code>与<code>device</code>，<code>platform</code>描述ASIC，厂商设备驱动代码以及new platform API的适配；<code>device</code>描述厂商设备代码，其中包括端口配置，led配置，sai配置等信息，<code>plugins</code>文件夹是一些外设命令适配的python代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sonic-buildimage&#x2F;</span><br><span class="line">    platform&#x2F;            # asic相关，重点关注sai以及sonic-platform.bin</span><br><span class="line">        broadcom&#x2F;        </span><br><span class="line">    device              # 设备相关，对设备硬件特性的控制描述，如端口，led，console；以及和硬件相关的命令的底层适配接口，如填入eeprom的地址，之后使用SONiC的解析器进行解析。对于SONiC的命令体系，可以再写一篇文档</span><br><span class="line">        celestica&#x2F;</span><br></pre></td></tr></table></figure>

<p>在<code>platform</code>中有个<code>sonic-platform</code>的文件夹，这里面包含了eeprom、fan、psu等外设相关的文件，与<code>device</code>里面的文件实际上是有重复的，这可能是SONiC的历史遗留问题，在字节项目中有讨论过后续会将外设相关的处理全部放到<code>platform</code>中去。</p>
<p>对于端口适配这些内容不熟悉，在此只做简单介绍。</p>
<h1 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h1><h2 id="device的编译"><a href="#device的编译" class="headerlink" title="device的编译"></a>device的编译</h2><p><code>device</code>中的数据会打包到<code>sonic-device-data_1.0-1_all.deb</code>, 具体是在<code>src/sonic-device-data/Makefile</code>实现文件拷贝然后打包成deb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$(addprefix $(DEST)&#x2F;, $(MAIN_TARGET)): $(DEST)&#x2F;% :                                       </span><br><span class="line">    pushd .&#x2F;src                     </span><br><span class="line">                                    </span><br><span class="line">    # Remove any stale data         </span><br><span class="line">    rm -rf .&#x2F;device                 </span><br><span class="line">                                    </span><br><span class="line">    # Create a new dir and copy all ONIE-platform-string-named dirs into it              </span><br><span class="line">    mkdir .&#x2F;device                  </span><br><span class="line">    cp -r -L ..&#x2F;..&#x2F;..&#x2F;device&#x2F;*&#x2F;* .&#x2F;device&#x2F;                                               </span><br><span class="line">                                    </span><br><span class="line">    # Create hwsku for virtual switch</span><br><span class="line">    for d in &#96;find -L ..&#x2F;..&#x2F;..&#x2F;device -maxdepth 3 -mindepth 3 -type d | grep -vE &quot;(plugins|led-code)&quot;&#96;; do \</span><br><span class="line">        cp -Lr $$d device&#x2F;x86_64-kvm_x86_64-r0&#x2F; ; \                                      </span><br><span class="line">        cp .&#x2F;sai.vs_profile device&#x2F;x86_64-kvm_x86_64-r0&#x2F;$$(basename $$d)&#x2F;sai.profile; \  </span><br><span class="line">        grep -v ^# device&#x2F;x86_64-kvm_x86_64-r0&#x2F;$$(basename $$d)&#x2F;port_config.ini | awk &#39;&#123;i&#x3D;i+1;print &quot;eth&quot;i&quot;:&quot;$$2&#125;&#39; &gt; device&#x2F;x86_64-kvm_x86_64-r0&#x2F;$$(basename $$d)&#x2F;lanemap.ini</span><br><span class="line">    done;                           </span><br><span class="line">                                    </span><br><span class="line">    # Build the package                                                                                                                                       </span><br><span class="line">    dpkg-buildpackage -rfakeroot -b -us -uc</span><br></pre></td></tr></table></figure>
<p>在<code>src/sonic-device-data/src/Makefile</code>中有config和media的测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    # Execute Broadcom config file test</span><br><span class="line">    pushd ..&#x2F;tests&#x2F;</span><br><span class="line">    for f in $$(find ..&#x2F;..&#x2F;..&#x2F;device -name &quot;*.config.bcm&quot;); do</span><br><span class="line">        .&#x2F;config_checker $$f</span><br><span class="line">    done</span><br><span class="line">    for f in $$(find ..&#x2F;..&#x2F;..&#x2F;device -name media_settings.json); do                                                                                           </span><br><span class="line">        .&#x2F;media_checker $$f</span><br><span class="line">    done</span><br><span class="line">    popd</span><br></pre></td></tr></table></figure>
<p>使用<code>dpkg -X target/debs/stretch/sonic-device-data_1.0-1_all.deb</code>或者在<code>fsroot/usr/share/sonic/device/</code>目录下可以发现<code>device</code>相关的文件。这些文件与设备目录上<code>/usr/share/sonic/device/</code>的文件相对应。<br>在<code>sonic_debian_extension.sh</code>脚本中会将其释放到根文件系统中去。<br><img src="https://rancho333.gitee.io/uploads/device_data.png"><br>注意，在slave.mk中操作一下才能看到脚本，否则它做为中间文件，编译完成后会被自动删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-       $(if $($*_DOCKERS),</span><br><span class="line">-               rm sonic_debian_extension.sh,</span><br><span class="line">-       )</span><br><span class="line">+#      $(if $($*_DOCKERS),</span><br><span class="line">+#              rm sonic_debian_extension.sh,</span><br><span class="line">+#      )</span><br><span class="line"> </span><br><span class="line">        chmod a+x $@</span><br><span class="line">        $(FOOTER)</span><br></pre></td></tr></table></figure>

<p>对于porting而言，可以修改Makefile中cmd的规则，只拷贝需要的device和只进行与之对应的test。</p>
<h2 id="platform的编译"><a href="#platform的编译" class="headerlink" title="platform的编译"></a>platform的编译</h2><p><code>slave.mk</code>是SONiC项目真正的Makefile，所有的编译规则在里面可以找到，<code>platform</code>的入口在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifneq ($(CONFIGURED_PLATFORM), undefined)</span><br><span class="line">include $(PLATFORM_PATH)&#x2F;rules.mk</span><br><span class="line">endif </span><br></pre></td></tr></table></figure>
<p>我们在执行<code>make configure PLATFORM=platform</code>时会指定platform，从而找到对应的rules.mk。</p>
<p><img src="https://rancho333.gitee.io/uploads/rules_mk.png"></p>
<p>这里面关注三个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sai.mk                          # 指定SAI版本以及下载路径</span><br><span class="line">platform-modules-device.mk      # 指定设备platform源文件路径，编译打包成debian</span><br><span class="line">one-image.mk                    # 指定SONiC系统安装镜像名称</span><br></pre></td></tr></table></figure>
<p>sai由ASIC厂商维护，作为设备厂商，我们直接使用即可。Makefile中通过指定url在编译时下载指定版本sai，对于此类重要的模块文件，可以将之缓存到本地，指定本地url进行使用。</p>
<p>对于设备厂商的platform，通过在<code>rules.mk</code>中增删 <em><strong>platform-modules-device.mk</strong></em> 可以实现在文件系统中添加或删除设备厂商platform的<code>device</code>模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;platform&#x2F;broadcom&#x2F;rules.mk b&#x2F;platform&#x2F;broadcom&#x2F;rules.mk</span><br><span class="line">index 8dd7b2c8..91e3afd3 100644</span><br><span class="line">--- a&#x2F;platform&#x2F;broadcom&#x2F;rules.mk</span><br><span class="line">+++ b&#x2F;platform&#x2F;broadcom&#x2F;rules.mk</span><br><span class="line">@@ -1,7 +1,7 @@</span><br><span class="line"> include $(PLATFORM_PATH)&#x2F;sai-modules.mk</span><br><span class="line"> include $(PLATFORM_PATH)&#x2F;sai.mk</span><br><span class="line">-include $(PLATFORM_PATH)&#x2F;platform-modules-dell.mk</span><br><span class="line">-include $(PLATFORM_PATH)&#x2F;platform-modules-arista.mk</span><br><span class="line">+#include $(PLATFORM_PATH)&#x2F;platform-modules-dell.mk</span><br><span class="line">+#include $(PLATFORM_PATH)&#x2F;platform-modules-arista.mk</span><br><span class="line"> include $(PLATFORM_PATH)&#x2F;platform-modules-ingrasys.mk</span><br></pre></td></tr></table></figure>

<p>通过在<code>one-image.mk</code>中增删<code>**_PLATFORM_MODULE</code>可以选择将在<code>platform-modules-device.mk</code>中编译好的对应机型的deb包拷贝到文件系统中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk b&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk</span><br><span class="line">index 8cbf7269..edc51460 100644</span><br><span class="line">--- a&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk</span><br><span class="line">+++ b&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk</span><br><span class="line">@@ -54,8 +54,8 @@ $(SONIC_ONE_IMAGE)_LAZY_INSTALLS +&#x3D; $(DELL_S6000_PLATFORM_MODULE) \</span><br><span class="line">                                $(ALPHANETWORKS_SNH60B0_640F_PLATFORM_MODULE) \</span><br><span class="line">                                $(BRCM_XLR_GTS_PLATFORM_MODULE) \</span><br><span class="line">                                $(DELTA_AG9032V2A_PLATFORM_MODULE) \</span><br><span class="line">-                               $(JUNIPER_QFX5210_PLATFORM_MODULE) \</span><br><span class="line">-                               $(CEL_SILVERSTONE_PLATFORM_MODULE)</span><br><span class="line">+                               #$(JUNIPER_QFX5210_PLATFORM_MODULE) \</span><br><span class="line">+                               #$(CEL_SILVERSTONE_PLATFORM_MODULE)</span><br></pre></td></tr></table></figure>

<p>对于打包好的platform文件，会在<code>sonic_debian_extension.sh</code>中拷贝到文件系统中去<br><img src="https://rancho333.gitee.io/uploads/platform_module.png"></p>
<p>上面这张图片上就是裁剪过后只会拷贝<code>cel-b3010</code>这一款机型的platform。有兴趣的同学可以研究下是如何实现的。</p>
<p>在SONiC的安装镜像第一次启动时，会在<code>rc.local</code>中将其释放到文件系统中去.<br><img src="https://rancho333.gitee.io/uploads/platform_module_2.png"></p>
<p>对于<code>platform-modules-*_amd64.deb</code>，里面包含了device的驱动，会在systemd中添加服务完成驱动的加载。这个deb的生成规则参见<code>platform/broadcom/sonic-platform-modules-cel/debian/</code>，主要修改如下几个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rules</span><br><span class="line">control</span><br></pre></td></tr></table></figure>
<p>以及添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform-modules-ivystone.init</span><br><span class="line">platform-modules-ivystone.install</span><br><span class="line">platform-modules-ivystone.postinst</span><br></pre></td></tr></table></figure>

<p>注意编译<code>platform-modules-*_amd64.deb</code>的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CEL_DX010_PLATFORM_MODULE &#x3D; platform-modules-dx010_$(CEL_DX010_PLATFORM_MODULE_VERSION)_amd64.deb</span><br><span class="line">$(CEL_DX010_PLATFORM_MODULE)_SRC_PATH &#x3D; $(PLATFORM_PATH)&#x2F;sonic-platform-modules-cel</span><br><span class="line">$(CEL_DX010_PLATFORM_MODULE)_DEPENDS +&#x3D; $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)</span><br><span class="line">$(CEL_DX010_PLATFORM_MODULE)_PLATFORM &#x3D; x86_64-cel_seastone-r0</span><br><span class="line">SONIC_DPKG_DEBS +&#x3D; $(CEL_DX010_PLATFORM_MODULE)</span><br><span class="line">           </span><br><span class="line">CEL_HALIBURTON_PLATFORM_MODULE &#x3D; platform-modules-haliburton_$(CEL_HALIBURTON_PLATFORM_MODULE_VERSION)_amd64.deb</span><br><span class="line">$(CEL_HALIBURTON_PLATFORM_MODULE)_PLATFORM &#x3D; x86_64-cel_e1031-r0</span><br><span class="line">$(eval $(call add_extra_package,$(CEL_DX010_PLATFORM_MODULE),$(CEL_HALIBURTON_PLATFORM_MODULE)))</span><br></pre></td></tr></table></figure>
<p>在slave.mk中会有编译SONIC_DPKG_DEBS的命令，只有CEL_DX010_PLATFORM_MODULE是显示的添加到SONIC_DPKG_DEBS</p>
<h1 id="SONiC启动简述"><a href="#SONiC启动简述" class="headerlink" title="SONiC启动简述"></a>SONiC启动简述</h1><p>对于从onie下面安装SONiC，在onie下面会维护一个<code>machine.conf</code>文件，这里面有设备的详细信息，之后SONiC会根据这里的信息完成初始化的文件加载流程。</p>
<p>对于从SONiC下面直接安装SONiC，修改grub，暂不做深入研究。</p>
<p>对于systemd的初始化，SDK的初始化，platform/chassis的初始化，后续有需要在继续研究。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">ARP协议简述及应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-25 13:22:08" itemprop="dateCreated datePublished" datetime="2020-12-25T13:22:08+00:00">2020-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇文章分为两个部分ARP协议简介以及ARP协议的实际应用。</p>
<h1 id="ARP协议简介"><a href="#ARP协议简介" class="headerlink" title="ARP协议简介"></a>ARP协议简介</h1><h2 id="ARP的作用"><a href="#ARP的作用" class="headerlink" title="ARP的作用"></a>ARP的作用</h2><p>ARP(Address Resolution Protocol，地址解析协议)是将IP地址解析为以太网MAC地址的协议。与之相对的，将MAC地址解析为IP地址的协议称为RARP。</p>
<p>在局域网中，当终端设备需要将数据发送给另一个终端设备时，它必须知道对方网络的IP地址。但是仅仅有IP地址是不够的，因为IP数据必须封装成帧才能通过物理网络发送，因此发送端还必须有接收端的MAC地址，所以需要一个从IP地址到物理地址的映射。ARP就是实现这个功能的协议。</p>
<h2 id="ARP报文的结构"><a href="#ARP报文的结构" class="headerlink" title="ARP报文的结构"></a>ARP报文的结构</h2><p><img src="https://rancho333.gitee.io/uploads/arp_protocol.png"> </p>
<p>对于各个字段的解释如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">长度（bit）</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ethernet Address of destination</td>
<td align="left">48</td>
<td align="left">目的以太网地址。发送ARP请求时，为广播MAC地址，0xFF.FF.FF.FF.FF.FF</td>
</tr>
<tr>
<td align="left">Ethernet Address of sneder</td>
<td align="left">48</td>
<td align="left">源以太网地址</td>
</tr>
<tr>
<td align="left">Frame Type</td>
<td align="left">16</td>
<td align="left">表示报文类型。对于ARP请求或应答，该字段为0x0806</td>
</tr>
<tr>
<td align="left">Hardware Type</td>
<td align="left">16</td>
<td align="left">表示硬件地址的类型。对于以太网，该字段为1</td>
</tr>
<tr>
<td align="left">Protocol Type</td>
<td align="left">16</td>
<td align="left">表示发送方要映射的协议地址类型。对于IP地址，该值为0x0800</td>
</tr>
<tr>
<td align="left">Hardware Length</td>
<td align="left">8</td>
<td align="left">表示硬件地址的长度，单位是字节。对于ARP请求或应答来说，该值为6</td>
</tr>
<tr>
<td align="left">Protocol Length</td>
<td align="left">8</td>
<td align="left">表示协议地址的长度，单位是字节。对于ARP请求或应答来说，该值为4</td>
</tr>
<tr>
<td align="left">OP</td>
<td align="left">16</td>
<td align="left">表示操作类型。1 表示ARP请求，2 表示ARP应答，3表示RARP请求，4表示RARP应答</td>
</tr>
<tr>
<td align="left">Ethernet Address of sneder</td>
<td align="left">48</td>
<td align="left">发送方以太网地址。这个字段和ARP报文首部的源以太网地址字段是重复信息</td>
</tr>
<tr>
<td align="left">IP Address of sender</td>
<td align="left">32</td>
<td align="left">发送方IP地址</td>
</tr>
<tr>
<td align="left">Ethernet Address of destination</td>
<td align="left">48</td>
<td align="left">接收方以太网地址，发送ARP请求时，该处填充全0</td>
</tr>
<tr>
<td align="left">IP Address of destination</td>
<td align="left">32</td>
<td align="left">接收方IP地址</td>
</tr>
</tbody></table>
<p>在Linux上可以通过tcpdump工具抓取ARP包</p>
<p><img src="https://rancho333.gitee.io/uploads/arp_data_raw.png"><br>使用wireshark工具可以更为方便的查看报文中的各个字段：</p>
<p><img src="https://rancho333.gitee.io/uploads/arp_data.png"> </p>
<h2 id="ARP地址解析过程"><a href="#ARP地址解析过程" class="headerlink" title="ARP地址解析过程"></a>ARP地址解析过程</h2><p>假设主机A和B在同一个网段，主机A要向主机B发送信息，解析过程如下：</p>
<ul>
<li>主机A查看自己的ARP表，找到则直接使用</li>
<li>如果A在ARP表中没有找到B，则<ul>
<li>缓存IP数据报文</li>
<li>发送ARP请求报文，请求B的MAC地址</li>
</ul>
</li>
<li>主机B比较自己的IP地址与ARP请求报文中的IP地址，两者相同则：<ul>
<li>将A的IP与MAC地址缓存到自己的ARP表中</li>
<li>单播发送ARP应答报文给主机A，其中包含自己的MAC地址</li>
</ul>
</li>
<li>主机A收到ARP响应后，缓存B的MAC到ARP表中，之后发送IP数据报文</li>
</ul>
<p>当主机A和B不在同一网段时，主机A会向网关发送ARP请求。如果网关有主机B的ARP表项，则直接应答A；否则网关广播ARP请求，目标IP地址为主机B的IP地址，网关收到响应报文之后再应答B。</p>
<h2 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h2><p>ARP表分为动态ARP表和静态ARP表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">10.204.113.138           ether   00:00:00:00:00:01   C                     ens160</span><br><span class="line">10.204.113.151                   (incomplete)                              ens160</span><br><span class="line">172.17.0.7               ether   02:42:ac:11:00:07   C                     docker0</span><br><span class="line">10.204.112.11            ether   00:e0:ec:47:33:1a   C                     ens160</span><br><span class="line">openbmc-develop.asia.ad  ether   00:e0:4c:06:00:95   C                     ens160</span><br><span class="line">10.204.112.44            ether   6c:b3:11:32:7f:12   C                     ens160</span><br><span class="line">172.17.0.2               ether   02:42:ac:11:00:02   C                     docker0</span><br><span class="line">sonic.asia.ad.celestica  ether   aa:ad:40:03:ba:19   C                     ens160</span><br></pre></td></tr></table></figure>

<h3 id="动态ARP表"><a href="#动态ARP表" class="headerlink" title="动态ARP表"></a>动态ARP表</h3><p>动态ARP表由ARP协议通过ARP报文自动生成与维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。当到达老化时间、接口down时会删除相应的动态ARP表项。</p>
<h3 id="静态ARP表项"><a href="#静态ARP表项" class="headerlink" title="静态ARP表项"></a>静态ARP表项</h3><p>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖。</p>
<p>配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，<br>从而保护了本设备和指定设备间的正常通信。</p>
<p>静态ARP表项分为短静态ARP表项和长静态ARP表项。</p>
<ul>
<li>长静态ARP表项必须配置IP地址、MAC地址、所在VLAN和出接口。长静态ARP表项可直接用于报文转发。</li>
<li>短静态ARP表项只需要配置IP地址和MAC地址。<ul>
<li>如果出接口是三层口，直接用于报文转发</li>
<li>如果出接口是VLAN虚接口，短静态ARP表项不能直接用于报文转发，当要发送IP数据包时，先发送ARP请求报文，如果收到的response中的<br>源IP和源MAC与所配置的相同，则将收到response的接口加入该静态ARP中，之后用于IP数据包转发。</li>
</ul>
</li>
</ul>
<p>当希望设备和指定用户只能使用某个固定的IP地址和MAC地址通信时，可以配置短静态ARP表项，当进一步希望这个用户只在某个VLAN内的某个特定接口上连接时就可以配置长静态ARP表项</p>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>免费ARP是一种特殊的ARP报文，该报文中携带的发送端与目的端IP都是本机IP，发送端MAC时本机MAC，接收端MAC是全f。其本质是keep alive保活/心跳报文的应用。<br>免费ARP报文有以下功能:</p>
<ul>
<li>IP地址冲突检测。如果有冲突，冲突设备会给本机发送一个ARP应答，告知IP地址冲突</li>
<li>设备改变MAC地址，发送免费ARP更新其它设备中的ARP表项</li>
</ul>
<p>定时发送免费ARP的应用场景：</p>
<ul>
<li>防止仿冒网关的ARP攻击（ARP欺骗）<ul>
<li>如果攻击者仿冒网关发送免费ARP报文，可以将原本发送到网关的流量重定向到一个错误的MAC地址，导致用户无法正常访问网络。网关接口上使能免费ARP功能后，主机可以学习到正确的网关。</li>
</ul>
</li>
<li>防止ARP表项老化</li>
<li>防止VRRP虚拟IP地址冲突</li>
<li>及时更新模糊终结VLAN内设备的MAC地址表</li>
</ul>
<h1 id="ARP协议应用"><a href="#ARP协议应用" class="headerlink" title="ARP协议应用"></a>ARP协议应用</h1><p>ARP协议的状态机比较简单，但是应用起来是比较有意思的，一些基础网络问题也是值得思考的。</p>
<h2 id="二层通信与三层通信中ARP的应用"><a href="#二层通信与三层通信中ARP的应用" class="headerlink" title="二层通信与三层通信中ARP的应用"></a>二层通信与三层通信中ARP的应用</h2><p>二三层设备互通中arp是怎样工作的？</p>
<p><img src="https://rancho333.gitee.io/uploads/ping_arp.png"><br>如图所示，两个vlan通过interface vlan路由接口实现互通。下文说明中，交换机和终端设备均为初始状态，不含有arp表项。</p>
<h3 id="A和B之间的互通-二层"><a href="#A和B之间的互通-二层" class="headerlink" title="A和B之间的互通(二层)"></a>A和B之间的互通(二层)</h3><p>以A向B发起ping请求为例。</p>
<ol>
<li>A检查报文的目的IP地址发现和自己在同一个网段；</li>
<li>A—-&gt;B ARP请求报文，该报文在VLAN1内广播<ol>
<li>报文的dst mac是广播mac，src mac是A mac</li>
<li>报文的sender MAC是A mac, sender ip是A ip; target mac是全0，target ip是B ip</li>
</ol>
</li>
<li>B—-&gt;A  ARP回应报文<ol>
<li>报文的dst mac是A mac, src mac是B mac</li>
<li>报文的sender MAC是B mac(A请求的mac), sender ip是B ip; target mac是A mac，taaget ip是A ip</li>
</ol>
</li>
<li>A—-&gt;B  icmp request</li>
<li>B—-&gt;A  icmp reply</li>
</ol>
<h3 id="A和C之间的互通-三层"><a href="#A和C之间的互通-三层" class="headerlink" title="A和C之间的互通(三层)"></a>A和C之间的互通(三层)</h3><p>以A向C发起ping请求为例。</p>
<ol>
<li>A检查报文的目的IP地址，发现和自己不在同一个网段</li>
<li>A—-&gt;switch(int vlan 1) ARP请求报文，该报文在vlan1内广播<ol>
<li>报文的dst mac是广播mac，src mac是A mac</li>
<li>报文的sender MAC是A mac, sender ip是A ip; target mac是全0，target ip是int vlan 1 ip</li>
</ol>
</li>
<li>网关—-&gt; A ARP回应报文<ol>
<li>报文的dst mac是A mac, src mac是int vlan 1 mac</li>
<li>报文的sender MAC是int vlan 1 mac(A请求的mac), sender ip是int vlan 1 ip; target mac是A mac，taaget ip是A ip</li>
</ol>
</li>
<li>A—-&gt;switch icmp request<ol>
<li>报文dst mac是int vlan 1的mac，src mac是A的mac; dst ip是C ip，src ip是A ip</li>
</ol>
</li>
<li>switch收到报文后判断出是三层报文，检查报文的目的IP地址，发现是在自己的直连网段</li>
<li>switch(int vlan 2)—-&gt;C ARP请求报文，该报文在vlan2内广播</li>
<li>C—-&gt;switch(int vlan 2) ARP回应报文</li>
<li>switch(int vlan 2)—-&gt;C icmp request<ol>
<li>报文的dst mac是C的mac, src mac是int vlan 2的mac; dst ip是C ip, src ip是A ip</li>
</ol>
</li>
<li>C—-&gt;A icmp reply, 这以后的处理同前面icmp request的过程基本相同。</li>
</ol>
<p>对报文路由，会对报文的MAC头进行重新封装，而IP层以上的字段基本不变。通过说明报文dst/src MAC的变化，注意ARP在二三层通信中起的作用。后续设备中ARP表有了相应的条目之后，则不会给对方发送ARP请求报文。</p>
<h2 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h2><p>如果ARP请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理ARP功能的设备就可以回答该请求，这个过程称作代理ARP（Proxy ARP）<br>代理ARP功能屏蔽分离的物理网络这一事实，使用户使用起来，好像在同一物理网络上。<br>代理ARP分为普通代理ARP和本地代理ARP，二者的应用场景有所区别。</p>
<ul>
<li>普通代理ARP的应用场景：想要互通的主机分别连接到设备的不同的三层接口上，且这些主机不在同一个广播域中</li>
<li>本地代理ARP的应用环境为：想要互通的主机连接到设备的同一个三层接口在，且这些主机不在同一个广播域中</li>
</ul>
<h3 id="普通代理ARP"><a href="#普通代理ARP" class="headerlink" title="普通代理ARP"></a>普通代理ARP</h3><p>处于同一网段内的主机，当连接到设备的不同三层接口时，可以利用设备的代理ARP功能，通过三层转发实现互通。<br>拓扑如下图所示。设备Router通过两个三层接口Eth1/1和Eth1/2连接两个网络，两个三层接口的IP地址不在同一个网段，但是两个网络内的主机Host A和Host B的地址通过掩码的控制，既与相连设备的接口地址在同一网段，同时二者也处于同一个网段。<br><img src="https://rancho333.gitee.io/uploads/general_arp_agent.png"><br>这种组网场景下，当Host A需要与Host B通信时，由于dst ip与src ip在同一网段，因此Host A会直接对Host B进行ARP请求。但是，两台主机不在同一个广播域中，Host B无法收到Host A的ARP请求报文，当然也就无法应答。<br>通过在Router上启用代理ARP功能，可以解决此问题。启用代理ARP后,Router可以应答Host A的ARP请求。同时，Router相当于Host B的代理，把从其它主机发送过来的报文转发给它。<br>代理ARP的优点是，它可以只被应用在一个设备上（此时设备的作用相当于网关），不会影响到网络中其它设备的路由表。代理ARP功能可以在IP主机没有配置缺省网关或者IP主机没有任何路由能力的情况下使用。</p>
<h3 id="本地代理ARP"><a href="#本地代理ARP" class="headerlink" title="本地代理ARP"></a>本地代理ARP</h3><p>拓扑如图所示。Host A与Host B属于同一个VLAN 2,但他们分别连接到被二层隔离的端口Eth1/3和Eth1/1上，通过在Router上启用本地代理ARP功能，可以实现Host A和Host B的三层互通。<br><img src="https://rancho333.gitee.io/uploads/local_arp_agent.png"></p>
<p>本地代理ARP可以在下列三种情况下实现主机之间的三层互通：</p>
<ul>
<li>想要互通的主机分别连接到同一个VLAN中的不同的二层隔离端口下</li>
<li>使能Super VLAN功能后，想要互通的主机属于不同的Sub VLAN</li>
<li>使能Lsolate-user-vlan功能后，想要互通的主机属于不同的Secondary VLAN</li>
</ul>
<h2 id="ARP-Snooping"><a href="#ARP-Snooping" class="headerlink" title="ARP Snooping"></a>ARP Snooping</h2><p>ARP snooping功能是一个用于二层交换网络环境的特性，通过侦听ARP报文建立ARP Snooping表项，从而提供给ARP快速应答和MFF手动方式等使用。<br>设备上的一个VLAN使能ARP Snooping后，该VLAN内所有端口接收的ARP报文会被重定向到CPu。CPU对重定向上送的ARP报文进行分析，获取ARP报文的src ip, src mac, src vlan和入端口信息，建立记录用户信息的ARP Snooping表项。</p>
<h2 id="ARP快速应答"><a href="#ARP快速应答" class="headerlink" title="ARP快速应答"></a>ARP快速应答</h2><p>在无线产品组网中，AC与AP会建立隧道连接，Client通过AP连接到AC，通过AC，client可以与网关建立连接。当Client发起ARP广播请求时，需要通过AC向所有的AP复制ARP请求，这样会导致ARP广播占用隧道的大量资源，导致性能下降。为了减少ARP广播占用的隧道资源，可以在AC上启用ARP快速应答功能，减少ARP广播报文的影响。</p>
<p>ARP快速应答功能就是根据AC设备收集的用户信息（DHCP Snooping表项或者ARP Snooping表项），在指定的VLAN内，尽可能的对ARP请求进行应答，从而减少ARP广播报文。</p>
<h3 id="ARP快速应答工作机制"><a href="#ARP快速应答工作机制" class="headerlink" title="ARP快速应答工作机制"></a>ARP快速应答工作机制</h3><p>ARP快速应答的工作机制如下：</p>
<ol>
<li>设备接收到ARP请求报文时，如果请求报文的目的IP地址是设备的VLAN虚接口的IP地址，则由ARP特性进行处理</li>
<li>如果不是，则根据报文中的目的IP地址查找DHCP Snooping表项<ol>
<li>如果查找成功，但是查找到的表项的接口和收到请求报文的接口一致，并且接口是以太网接口，则不进行应答，否则立即进行应答</li>
<li>如果查找失败，则继续查找ARP Snooping表项。如果查找成功，但是查找到的表项的接口和收到请求报文的接口一致，并且接口是以太网接口，则不进行应答，否则立即进行应答。</li>
<li>如果两个表项均查找失败，则直接转发请求报文或将报文交于其它特性处理。</li>
</ol>
</li>
</ol>
<h2 id="ARP防御攻击"><a href="#ARP防御攻击" class="headerlink" title="ARP防御攻击"></a>ARP防御攻击</h2><p>ARP协议有简单、易用的优点，但是也因为没有任何安全机制而容易被攻击发起者利用。</p>
<ul>
<li>攻击者可以仿冒用户、仿冒网关发送伪造的ARP报文，使网关或主机的ARP表项不正确，从而对网络进行攻击</li>
<li>攻击者通过向设备发送大量目标IP地址不能解析的IP报文，使得设备试图反复地对目标IP地址进行解析，导致CPU负荷过重及网络流量过大</li>
<li>攻击者向设备发送大量的ARP报文，对设备的CPU形成冲击。<br>目前ARP攻击和ARP病毒已经成为局域网安全的一大威胁。下面简单说明一下ARP攻防原理。</li>
</ul>
<h3 id="ARP防止IP报文攻击功能简介"><a href="#ARP防止IP报文攻击功能简介" class="headerlink" title="ARP防止IP报文攻击功能简介"></a>ARP防止IP报文攻击功能简介</h3><p>如果网络中有主机通过向设备发送大量目标IP地址不能解析的IP报文来攻击设备，则会造成下面的危害：</p>
<ul>
<li>设备向目的网段发送大量的ARP请求报文，加重目的网段的负载</li>
<li>设备会试图反复地对目标IP地址进行解析，增加了CPU的负担</li>
</ul>
<p>为了避免这种IP报文攻击所带来的危害，设备提供了下列两个功能：</p>
<ul>
<li>如果发送攻击报文的源是固定的，可以采用ARP源抑制功能。开启该功能后，如果网络中某主机向设备某端口连续发送目标IP地址不能解析的IP报文，当每5秒内此主机发出IP报文出发ARP请求报文的流量超过设置的阈值，那么对于由此主机发出的IP报文，设备不允许其触发ARP请求，直至5秒后再处理，从而避免了恶意攻击所造成的危害。</li>
<li>如果发送攻击报文的源不固定，设备立即产生一个黑洞路由，使得设备在一段时间内将去往该地址的报文直接丢弃。等待黑洞路由老化时间过后，如有报文触发则再次发起解析，如果解析成功则进行转发，否则仍然产生一个黑洞路由将去往改地址的报文丢弃。这种方式能够有效的防止IP报文的攻击，减轻CPU的负担。</li>
</ul>
<h3 id="ARP报文限速功能"><a href="#ARP报文限速功能" class="headerlink" title="ARP报文限速功能"></a>ARP报文限速功能</h3><p>ARP报文限速功能是指对上送CPU的ARP报文进行限速，可以防止大量ARP报文对CPU进行冲击。例如，在配置了ARP Detection功能后，设备会将收到的ARP报文重定向到CPU进行检查，这样会引入新的问题：如果攻击者恶意构造大量ARP报文发往设备，会导致设备的CPU负担过重，从而造成其它功能无法正常运行甚至设备瘫痪，这个时候可以启用ARP报文限速功能来控制上送CPU的ARP报文的速率。</p>
<p>推荐用户在配置了ARP Detection、ARP Snooping、ARP快速应答、MFF，或者发现有ARP泛洪攻击的情况下，使用ARP报文限速功能。</p>
<h3 id="源MAC地址固定的ARP攻击检测功能"><a href="#源MAC地址固定的ARP攻击检测功能" class="headerlink" title="源MAC地址固定的ARP攻击检测功能"></a>源MAC地址固定的ARP攻击检测功能</h3><p>本特性根据ARP报文的源MAC地址进行统计，在5秒内，如果收到同一源MAC地址的ARP报文超过一定的阈值，则认为存在攻击，系统会将此MAC地址添加到攻击检测表项中。在该攻击检测表项老化之前，如果设置的检查模式为过滤模式，则会打印告警信息并将该源MAC地址发送的ARP报文过滤掉。如果设置为监控模式，则只打印告警信息，不会将源MAC地址发送的ARP报文过滤掉。<br>对于网关或一些重要的服务器，可能会发送大量的ARP报文，为了使这些ARP报文不被过滤掉，可以将这类设备的MAC地址配置成保护MAC，这样，即使该MAC存在攻击也不会被检测过滤。只对上送CPU的ARP报文进行统计。</p>
<h3 id="ARP报文源MAC一致性检查功能简介"><a href="#ARP报文源MAC一致性检查功能简介" class="headerlink" title="ARP报文源MAC一致性检查功能简介"></a>ARP报文源MAC一致性检查功能简介</h3><p>ARP报文源MAC一致性检查功能主要应用于网关设备上，防御以太网数据帧首部中的源MAC地址和ARP报文中sender mac地址不同的ARP攻击。</p>
<p>在配置被特性后，网关设备在进行ARP学习前将对ARP报文进行检查。如果以太网数据帧首部中的源MAC地址和ARP报文中sender mac地址不同，则认为是攻击报文，将其丢弃，否则，继续进行ARP学习。</p>
<h3 id="ARP主动确认功能"><a href="#ARP主动确认功能" class="headerlink" title="ARP主动确认功能"></a>ARP主动确认功能</h3><p>ARP的主动确认功能主要应用于网关设备上，防止攻击者仿冒用户欺骗网关设备。</p>
<p>启用ARP主动确认功能后，设备在新建或更新ARP表项前需进行主动确认，防止产生错误的ARP表项。</p>
<h2 id="MLAG结合VARP实现VRRP"><a href="#MLAG结合VARP实现VRRP" class="headerlink" title="MLAG结合VARP实现VRRP"></a>MLAG结合VARP实现VRRP</h2><p>VRRP(virtual router redundancy protocol，虚拟路由器冗余协议)将可以承担网关功能的一组路由器加入到备份组中，形成一台虚拟路由器，局域网内的终端设备只需将虚拟路由器配置为缺省网关即可。VRRP有两个版本，VRRPv2基于IPv4, VRRPv3基于IPv6。正统的VRRP实现起来可能有些复杂，通过MLAG结合VARP可以较为简单的实现VRRP的功能。拓扑如下。<br><img src="https://rancho333.gitee.io/uploads/varp_mlag_vrrp.png"></p>
<p>原理说明：device作为leaf switch, 下行接host，上行通过mlag连接到两台网关。策略配置之后，host发往网关的流量只会通过mlag中的一个端口发往switch A或switch B, 当mlag中一条线路down掉时，通过另一条线路通信，在switch A和switch B上运行VARP协议，通过配置相同的VIP和VMAC实现网关虚拟化。这里面有两个关键点。</p>
<ul>
<li>主机流量同一时间只会发往一台物理网关</li>
<li>物理网关上配置相同的VIP和VMAC实现网关虚拟化</li>
</ul>
<p>对于VARP说明，可以通过ip地址/mac地址确定唯一三层接口，但是三层接口可以被多个ip地址/mac地址定位到。对于虚拟网关，物理网关除了正常配置的ip与mac地址，还会配置一组相同的vip/vmac，主机将vip作为网关ip。对于物理网关：</p>
<ul>
<li>只有当主机请求vip时才回复vmac</li>
<li>主动发送arp或者转发三层报文时，src mac使用的都是自己真实的router mac</li>
</ul>
<p>对于主机而言，网关是虚拟的，所以使用虚拟网关ip进行通信<br>对于交换机而言，自己与外界通信需要使用自己真实的ip和mac, 这样对方才能根据真实的ip和mac定位到自己。</p>
<p>当MLAG交换机配置了VARP之后，host通过arp去请求VARP虚拟网关ip的mac地址，则MLAG-VARP交换机回应的自然是虚拟网关的mac;host发送icmp request给虚拟网关，虚拟网关使用真实的router-mac去回复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/21/%E5%8A%A0%E5%BC%98%E8%B7%91%E5%9B%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/21/%E5%8A%A0%E5%BC%98%E8%B7%91%E5%9B%A2/" class="post-title-link" itemprop="url">加弘跑团</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-21 13:12:08" itemprop="dateCreated datePublished" datetime="2020-12-21T13:12:08+00:00">2020-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要跑步？<br>我最开始跑步是为了减肥，现在我更多的认为规律性的跑步是一种健康的生活方式，是一种极易获取的运动。对跑步，我谈不上热爱，但我已经习惯了生活有它的一席之地。我知道跑步之前的生活状态，也知道现在的生活状态，所以我离不开跑步。</p>
<p>提及跑步，可以轻易找到各种各样的好处，这里不赘述。但是随便跑个几公里，一周只跑一两次其实很难看到你想要的效果。如果加大跑量，跑步有时候可能会损伤你的膝盖，还会让你得上一些奇奇怪怪的病，什么足底筋膜炎，跟腱炎，髂胫束摩擦综合症，跑完一个半马，你可能下楼梯都困难。</p>
<p>跑步是痛苦的，长跑更是意志力的对抗赛。只有在熬过最初的苦痛，可以边跑边聊天，可以只用鼻子呼吸的时候，你才不会感觉那么煎熬，这之前是可以称作跑步痛苦期。如果想着提高配速，增加距离，再突破瓶颈，那便得再痛苦一番。跑步也不能拯救我们，跑步是花钱的运动，专业跑鞋很贵，所以好好工作才能好好跑步。</p>
<p>跑步是痛苦的，只有认识到跑步的痛苦之后，然后依然热爱并且坚定的选择，才能持久的进行。跑步的快乐，只有在获得正向反馈之后，熬过跑步痛苦期之后，才能真正体会到。</p>
<p>所以，为什么要跑步？请寻找你内心的信念，让它支撑你熬过开始跑步时的痛苦。</p>
<p>什么叫跑步？<br>跑步，跑马拉松并不会让我们高人一等，也不是只有跑十公里以上才叫跑步。每个人跑步的需求也是不一样的。有严肃跑者，将跑步当作兴趣来培养，动辄全马百公里超马越野跑，追求成绩追求PB；也有休闲跑者，三五好友或携妻带子，三两公里，微风微汗，也是开心畅快。<br>不用神话跑步，学音乐，学舞蹈，学英语都可以让我们变得更好。无论是严肃的跑者还是休闲的跑者，跑起来，都是跑步。跑步是一项包容性很大的活动。不用管配速，不用管距离，跑起来就好。</p>
<p>了解了一下，加弘跑团中有跑过上马的老马, 有早起晨跑的大佬，有希望进阶的跑者，有刚接触跑步的菜鸟。大家相聚一起，一起跑，想来是件很欢快的事情。加弘跑团刚成立，需要大家一起去将跑团运行起来。下面对跑团的运行以及接下来的安排做一些简要说明，欢迎大家补充优化。</p>
<ol>
<li><p>本周4（12月24号）进行加弘跑团第一次分享会，具体时间地点会通知，有以下几点：</p>
<ol>
<li>大家相互认识一下，确定跑团人员，购买跑团队服，还有大家赶紧拉人头</li>
<li>分享跑步基础知识，包括但不限于跑步姿势，预防伤害，跑步场地，跑步时间与饮食</li>
<li>跑步装备介绍，包括但不限于跑鞋（袜子），跑衣，手表<br>备注：分享人待定</li>
</ol>
</li>
<li><p>活动组织形式</p>
<ol>
<li>每月组织一次线下活动，时间可以是周末或者有意义的节假日或其它，地点待确定。不能参加的可以通过线上方式参与</li>
<li>线下活动会视经费情况安排补给，供大家补充体力</li>
<li>不定期安排比赛活动，视经费情况安排奖品</li>
</ol>
</li>
<li><p>暂定元旦进行加弘跑团第一次线下活动</p>
</li>
</ol>
<p>为了跑团的良好运行，请大家以任何形式联系我提供建议。关于知识分享，请大佬主动认领！<br>期待大家越跑越健康；期待大家跑一个冬天，帅一个夏天；期待有一天在马拉松的赛道上看到加弘跑团的旗帜！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/18/sonic-testbed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/18/sonic-testbed/" class="post-title-link" itemprop="url">sonic-testbed</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-18 15:29:56" itemprop="dateCreated datePublished" datetime="2020-12-18T15:29:56+00:00">2020-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最初，SONiC的所有测试用例都是用ansible playbook写的。2019年开始使用pytest， 2020年9月份之后，只有用pytest写的测试用例才被采纳。<br>但是ansible依然很重要，pytest-ansible插件连接pytest与ansible。pytest通过ansible进行多设备协同工作。</p>
<h2 id="物理拓扑"><a href="#物理拓扑" class="headerlink" title="物理拓扑"></a>物理拓扑</h2><p><img src="https://rancho333.gitee.io/uploads/physical-topology.png"></p>
<ol>
<li>DUT和leaf fanout的端口一一互联</li>
<li>leaf fanout与DUT相连的端口进行VLAN隔离</li>
<li>root fanout连接leaf fanout与testbed server</li>
<li>root fanout的端口工作在vlan trunk模式下</li>
<li>任一testbed server可以发送带有vlan tag的包到达DUT端口（root fanout的trunk口需要使能该vlan tag）</li>
</ol>
<h3 id="Fanout-switch"><a href="#Fanout-switch" class="headerlink" title="Fanout switch"></a>Fanout switch</h3><p><em>Fanout switch是使能了vlan trunking的物理交换机</em></p>
<ul>
<li>Et33是一个vlan trunking端口，并且和linux host的eth0连接</li>
<li>Et1-Et32是vlan access端口，并且与DUT连接</li>
<li>使能LACP/LLDP</li>
<li>关闭STP功能</li>
</ul>
<h3 id="Testbed-server"><a href="#Testbed-server" class="headerlink" title="Testbed server"></a>Testbed server</h3><p><img src="https://rancho333.gitee.io/uploads/testbed_server.png"></p>
<h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><ul>
<li>testbed server有两个网络接口<ul>
<li>trunk端口连接root fanout</li>
<li>management port管理服务器以及服务器上的VMs和PTF容器</li>
</ul>
</li>
</ul>
<h3 id="VMs"><a href="#VMs" class="headerlink" title="VMs"></a>VMs</h3><p>VMs使用的是Arista的vEOS。它们用来设置测试协议，例如BGP、LACP、LLDP等。它们通过<code>testbed-cli.sh start-vms</code>进行创建。每一个VM使用2G内存并且拥有10个网络接口。<br>    * 8个前面板端口。这些端口用来连接到openvswitch网桥，连接到vlan interfaces.vlan interface通过物理接口连接到fanout。<br>    * 一个后背板端口。所有VMs通过这个背板口互联。<br>    * 一个管理网口。用来管理VMs.</p>
<h3 id="PTF"><a href="#PTF" class="headerlink" title="PTF"></a>PTF</h3><p>PTF容器通过发送和接收数据包来验证DUT的数据面。<br>PTF with direct port<br><img src="https://rancho333.gitee.io/uploads/testbed-direct.png"></p>
<p>DUT的前面板口直连到一个PTF容器的端口。一般的PTF容器的eth0连接到DUT的Ethernet0，eth1连接到Ethernet4。这一般在PTF拓扑中用来连接DUT端口和PTF容器端口。</p>
<p><img src="https://rancho333.gitee.io/uploads/testbed-injected.png"></p>
<p>DUT的前面板口和一个VM的接口直连。但是我们在这个连接上有个tap。从vlan interface中收到的包被发送给VMs和PTF容器。从VM和PTF容器中发出的包被送到vlan interface。这允许我们可以同时从PTF host往DUT注入包和维持VM与DUT之间的BGP会话。</p>
<h3 id="SONiC-Tested-with-keysight-IxNetwork-as-Traffic-Generator"><a href="#SONiC-Tested-with-keysight-IxNetwork-as-Traffic-Generator" class="headerlink" title="SONiC Tested with keysight IxNetwork as Traffic Generator"></a>SONiC Tested with keysight IxNetwork as Traffic Generator</h3><p>TO BE DONE！！</p>
<h2 id="Testbed设置"><a href="#Testbed设置" class="headerlink" title="Testbed设置"></a>Testbed设置</h2><p>下面讲述testbed的设置步骤以及拓扑的部署。</p>
<h3 id="准备testbed服务器"><a href="#准备testbed服务器" class="headerlink" title="准备testbed服务器"></a>准备testbed服务器</h3><ul>
<li>系统要求：ubuntu 18.04 amd64</li>
<li>设置管理口，使用如下示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@server-1:~# cat &#x2F;etc&#x2F;network&#x2F;interfaces</span><br><span class="line"># The management network interface</span><br><span class="line">auto ma0</span><br><span class="line">iface ma0 inet manual</span><br><span class="line"></span><br><span class="line"># Server, VM and PTF management interface</span><br><span class="line">auto br1</span><br><span class="line">iface br1 inet static</span><br><span class="line">    bridge_ports ma0</span><br><span class="line">    bridge_stp off</span><br><span class="line">    bridge_maxwait 0</span><br><span class="line">    bridge_fd 0</span><br><span class="line">    address 10.250.0.245</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    network 10.250.0.0</span><br><span class="line">    broadcast 10.250.0.255</span><br><span class="line">    gateway 10.250.0.1</span><br><span class="line">    dns-nameservers 10.250.0.1 10.250.0.2</span><br><span class="line">    # dns-* options are implemented by the resolvconf package, if installed</span><br></pre></td></tr></table></figure></li>
<li>安装python2.7（Ansible需要）</li>
<li>添加Docker的官方GPG key：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为docker-pth设置docker仓库"><a href="#为docker-pth设置docker仓库" class="headerlink" title="为docker-pth设置docker仓库"></a>为<code>docker-pth</code>设置docker仓库</h3><ol>
<li>build <code>docker-pth</code>镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;sonic-buildimage.git</span><br><span class="line">cd sonic-buildimage</span><br><span class="line">make configure PLATFORM&#x3D;generic</span><br><span class="line">make target&#x2F;docker-ptf.gz</span><br></pre></td></tr></table></figure></li>
<li>设置自己的docker仓库并将<code>docker-ptf</code>上传</li>
</ol>
<h3 id="创建并且运行docker-sonic-mgmt"><a href="#创建并且运行docker-sonic-mgmt" class="headerlink" title="创建并且运行docker-sonic-mgmt"></a>创建并且运行<code>docker-sonic-mgmt</code></h3><p>管理testbed和运行测试用例需要很多依赖。将所有的依赖部署到<code>docker-sonic-mgmt</code>中，这样就可以很方便的使用<code>ansible-playbook</code>，<code>pytest</code>，<code>spytest</code>。</p>
<ol>
<li><p>构建<code>docker-sonic-mgmt</code>镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;sonic-buildimage.git</span><br><span class="line">cd sonic-buildimage</span><br><span class="line">make configure PLATFORM&#x3D;generic</span><br><span class="line">make target&#x2F;docker-sonic-mgmt.gz</span><br></pre></td></tr></table></figure>
<p>或者从<a target="_blank" rel="noopener" href="https://sonic-jenkins.westus2.cloudapp.azure.com/job/bldenv/job/docker-sonic-mgmt/lastSuccessfulBuild/artifact/sonic-buildimage/target/docker-sonic-mgmt.gz">这里</a>下载事先编译好的镜像。</p>
</li>
<li><p>克隆<code>sonic-mgmt</code>库到testbed server的工作目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Azure&#x2F;sonic-mgmt</span><br></pre></td></tr></table></figure></li>
<li><p>创建<code>docker-sonic-mgmt</code>容器，注意需要将上面克隆的<code>sonic-mgmt</code>挂载到容器中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; docker-sonic-mgmt.gz</span><br><span class="line">docker run -v $PWD:&#x2F;data -it docker-sonic-mgmt bash</span><br><span class="line">cd ~&#x2F;sonic-mgmt</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>注意：之后的所有操作都是在<code>docker-sonic-mgmt</code>容器中操作</em></p>
<h3 id="准备Testbed配置"><a href="#准备Testbed配置" class="headerlink" title="准备Testbed配置"></a>准备Testbed配置</h3><p>进入到容器之后，我们需要修改testbed的配置文件使之与实验拓扑映射起来。</p>
<ul>
<li><p>Testbed Server</p>
<ul>
<li>在<code>ansible/veos</code>中更新server的管理IP</li>
<li>在<code>ansible/group_vars/vm_host/creds.yml</code>中更新server的凭证</li>
<li>在<code>ansible/host_vars/STA-ACS-SERV-01.yml</code>中更新server的网络配置（for VMs和PTF management）<ul>
<li><code>external_port</code>：server的trunk口名称（连接到fanout switch）</li>
<li><code>mgmt_gw</code>：VM管理端口的网关IP</li>
<li><code>mgmt_prefixlen</code>: 管理网口子网掩码</li>
</ul>
</li>
<li>检查ansible可以与这个host连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible -m ping -i veos vm_host_1 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>VMs</p>
<ul>
<li>从Arista下载<a target="_blank" rel="noopener" href="https://www.arista.com/en/support/software-download">vEOS</a></li>
<li>将镜像文件拷贝到<code>ansible/veos</code><ul>
<li><code>Aboot-veos-serial-8.0.0.iso</code></li>
<li><code>vEOS-lab-4.20.15M.vmdk</code></li>
</ul>
</li>
<li>将VM的IP地址更新到<code>ansible/veos</code>. 这个IP地址应该和定义的管理IP在同一个子网中</li>
<li>在<code>ansible/group_vars/eos/creds.yml</code>中更新VM的凭证</li>
</ul>
</li>
<li><p>PTF容器</p>
<ul>
<li>在<code>vars/docker_registry.yml</code>中更新docker仓库信息</li>
</ul>
</li>
</ul>
<h3 id="设置VMs"><a href="#设置VMs" class="headerlink" title="设置VMs"></a>设置VMs</h3><ol>
<li>开启VMs：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh start-vms server_1 password.txt</span><br></pre></td></tr></table></figure>
<code>password.txt</code>是ansible的密码文件，如果不使用直接创建一个空文件即可。</li>
</ol>
<ol start="2">
<li>检查所有的VMs是否启动并且在运行中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible -m ping -i veos server_1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="部署Fanout交换机的Vlan"><a href="#部署Fanout交换机的Vlan" class="headerlink" title="部署Fanout交换机的Vlan"></a>部署Fanout交换机的Vlan</h3><p>在部署Fanout和运行测试用例之前需要明确环境中的所有物理连接。<br>在<code>roles/fanout</code>下的playbook只是用来部署Arista的Vlan配置。如果使用其它类型的交换机，请手动配置Vlan，或者部署一个2层交换机。</p>
<h3 id="部署拓扑"><a href="#部署拓扑" class="headerlink" title="部署拓扑"></a>部署拓扑</h3><ul>
<li>使用自己的数据更新<code>testbed.csv</code>。至少需要更新PTF管理接口的配置。</li>
<li>部署拓扑请运行：<code>/testbed-cli.sh add-topo vms-t1 ~/.password</code></li>
<li>移除拓扑请运行: <code>./testbed-cli.sh remove-topo vms-t1 ~/.password</code></li>
</ul>
<p>注意：<code>testbed-cli.sh</code>的最后一步试图在root fanout中重新部署vlan范围（与拓扑中规定的相匹配）。Arista的正常工作，其它型号的需要手动修改？</p>
<h2 id="Docker容器设置"><a href="#Docker容器设置" class="headerlink" title="Docker容器设置"></a>Docker容器设置</h2><p>使用<code>setup-container.sh</code>脚本去自动创建和配置sonic-mgmt的docker容器。使用普通用户user创建即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;setuo-container.sh -n container_name -i image_id -d directory</span><br><span class="line">image_id是在sonic-buildimage中创建的docker-sonic-mgmt.tar</span><br><span class="line">directory是主机与docker进行mount的文件夹</span><br></pre></td></tr></table></figure>
<p>创建完dokcer容器之后，可以进入容器中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -u &lt;user&gt; -it &lt;container name&gt; bash</span><br></pre></td></tr></table></figure>

<h2 id="KVM-testbed设置"><a href="#KVM-testbed设置" class="headerlink" title="KVM testbed设置"></a>KVM testbed设置</h2><p>可以给testbed创建虚拟的交换机，在上面部署T0拓扑，运行一个快速测试去验证是否符合预期。<br>即物理设备都虚拟化在服务器上，对内存资源要求比较高，我们现在使用物理设备连接，暂不研究这块内容。<br>这里面有vEOS与cEOS的介绍，分别是基于KVM和docker的技术。</p>
<h2 id="cEOS"><a href="#cEOS" class="headerlink" title="cEOS"></a>cEOS</h2><p>如何使用cEOS作为DUT的邻居设备。<br>cEOS是容器化的EOS。所有的软件在容器中运行。与vEOS相比，cEOS内存暂用更少。</p>
<h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><p>首先创建一个基容器<code>net_$&#123;testbed_name&#125;_$&#123;vm_name&#125;</code>，在基容器中创建6个以太口。然后在基容器基础上启动cEOS<code>ceos_$&#123;testbed_name&#125;_$&#123;vm_name&#125;</code>容器。这6个网口分别用来：</p>
<ul>
<li>一个管理网口</li>
<li>4个前面板端口用来连接DUT</li>
<li>一个背板口连接PTF容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+------------+                      +----+</span><br><span class="line">|  cEOS  Ma0 +--------- VM0100-m ---+ br |</span><br><span class="line">|            |                      +----+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et1 +----------VM0100-t0---+  br-VM0100-0 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et2 +----------VM0100-t1---+  br-VM0100-1 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et3 +----------VM0100-t2---+  br-VM0100-2 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|        Et4 +----------VM0100-t3---+  br-VM0100-3 |</span><br><span class="line">|            |                      +--------------+</span><br><span class="line">|            |</span><br><span class="line">|            |                       +--------------+</span><br><span class="line">|        Et5 +----------VM0100-back--+  br-b-vms6-1 |</span><br><span class="line">|            |                       +--------------+</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>cEOS容器中的<code>/mnt/flash</code>挂载到主机的<code>/data/ceos/ceos_$&#123;testbed_name&#125;_$&#123;vm_name&#125;</code>。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>两种方式登录到cEOS容器。</p>
<ol>
<li><p>docker exec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ceos_vms6-1_VM0100 Cli</span><br></pre></td></tr></table></figure></li>
<li><p>ssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lgh@jenkins-worker-15:~$ ssh admin@10.250.0.51</span><br><span class="line">Password: </span><br><span class="line">ARISTA01T1&gt;show int status</span><br><span class="line">Port       Name      Status       Vlan     Duplex Speed  Type            Flags Encapsulation</span><br><span class="line">Et1                  connected    in Po1   full   unconf EbraTestPhyPort                    </span><br><span class="line">Et2                  connected    1        full   unconf EbraTestPhyPort                    </span><br><span class="line">Et3                  connected    1        full   unconf EbraTestPhyPort                    </span><br><span class="line">Et4                  connected    1        full   unconf EbraTestPhyPort                    </span><br><span class="line">Et5        backplane connected    routed   full   unconf EbraTestPhyPort                    </span><br><span class="line">Ma0                  connected    routed   full   10G    10&#x2F;100&#x2F;1000                        </span><br><span class="line">Po1                  connected    routed   full   unconf N&#x2F;A                                </span><br><span class="line"></span><br><span class="line">ARISTA01T1&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="testbed路由设计"><a href="#testbed路由设计" class="headerlink" title="testbed路由设计"></a>testbed路由设计</h2><p>下面说明testbed中的BGP路由设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              +------+</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+         |</span><br><span class="line">                               |</span><br><span class="line">              +------+         |</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+         |</span><br><span class="line">+-------+                  +---+---+     </span><br><span class="line">|  PTF  +------------------+  DUT  |</span><br><span class="line">+-------+                  +---+---+</span><br><span class="line">              +------+         |</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+         |</span><br><span class="line">                               |</span><br><span class="line">              +------+         |</span><br><span class="line">              +  VM  +---------+</span><br><span class="line">              +------+</span><br></pre></td></tr></table></figure>
<p>在这个拓扑中，VMs（vEOS）充当DUT的BGP邻居。VMs生成并且宣告BGP路由给DUT.这种方式有几个问题：</p>
<ul>
<li>在vEOS很难生成任意路由，例如，写一个复杂的路由表，过滤生成需要的路由</li>
<li>消耗很多内存在vENOS中</li>
<li>特定的NOS规则。如果我们打算从VN切换到SONiC，我们需要重写所有的路由表。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              +------+</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">    |         +------+         |</span><br><span class="line">    |                          |</span><br><span class="line">    |         +------+         |</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">    |         +------+         |</span><br><span class="line">+---+---+                  +---+---+     </span><br><span class="line">|  PTF  |                  |  DUT  |</span><br><span class="line">+---+---+                  +---+---+</span><br><span class="line">    |         +------+         |</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">    |         +------+         |</span><br><span class="line">    |                          |</span><br><span class="line">    |         +------+         |</span><br><span class="line">    +---------+  VM  +---------+</span><br><span class="line">              +------+</span><br></pre></td></tr></table></figure>
新的方法是将VM作为一个透传设备，我们在PTF容器上运行exabgp,exabgp通告如有信息给VM，VM再将路由信息通告给DUT。这种方式有几个好处：</li>
<li>VM模板变得简单很多。只有基础的端口，lag，BGP配置</li>
<li>VM的内存开销变小</li>
<li>exbgp可以生成复杂路由条目</li>
<li>容易支持不同的NOS作为邻居设备，例如SONiC vm</li>
</ul>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><ol>
<li>配置testbed的拓扑定义在一个文件中：<code>testbed.csv</code></li>
<li>一个脚本去操作所有的testbed:<code>testbed-cli.sh</code></li>
<li>灵活的拓扑允许将VM_SET和PTF容器作为一个实体看待</li>
<li>所有的VM管理网口ip定义在：<code>veos</code></li>
<li>PTF容器在所有拓扑中被使用</li>
<li>自动构建fanout switch的配置（需要被重构）</li>
<li>请看示例模块如果你想设置任意的testbed的拓扑</li>
</ol>
<h3 id="testbed拓扑配置"><a href="#testbed拓扑配置" class="headerlink" title="testbed拓扑配置"></a>testbed拓扑配置</h3><ul>
<li><code>testbed.csv</code>文件由以下组成：<ul>
<li>物理拓扑；VMs和PTF容器的端口如何与DUT连接</li>
<li>VMs的配置模板</li>
</ul>
</li>
<li>拓扑在<code>vars/topo_*.yml</code>文件中</li>
<li>当前的拓扑有：<ul>
<li>t1:32个VMs + 用来端口注入的PTF容器</li>
<li>t1-lag：24个VMs + 用来端口注入的PTF容器。其中8个VMs在每一LAG中有两个端口</li>
<li>ptf32: 拥有32个个端口的PTF容器与DUT端口直连</li>
<li>ptf64: 和ptf32相同，但是拥有64个端口</li>
<li>t0：4个VMs + PTF容器（4个用来端口注入，28个用来直连DUT）</li>
</ul>
</li>
</ul>
<h3 id="当前的拓扑"><a href="#当前的拓扑" class="headerlink" title="当前的拓扑"></a>当前的拓扑</h3><h4 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-t1.png"></p>
<ul>
<li>需要32个VMs</li>
<li>所有的DUT端口直连VMs</li>
<li>PTF容器只有注入端口</li>
</ul>
<h4 id="t1-lag"><a href="#t1-lag" class="headerlink" title="t1-lag"></a>t1-lag</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-ti-lag.png"></p>
<ul>
<li>需要24个VMs</li>
<li>所有的DUT端口直连VMs</li>
<li>PTF容器只有注入端口</li>
</ul>
<h4 id="ptf32"><a href="#ptf32" class="headerlink" title="ptf32"></a>ptf32</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-ptf32.png"></p>
<ul>
<li>不需要VMs</li>
<li>所有的DUT端口直连PTF容器</li>
<li>PTF容器没有注入端口</li>
</ul>
<h4 id="ptf64"><a href="#ptf64" class="headerlink" title="ptf64"></a>ptf64</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-ptf64.png"><br>和ptf32一样</p>
<h4 id="t0"><a href="#t0" class="headerlink" title="t0"></a>t0</h4><p><img src="https://rancho333.gitee.io/uploads/testbed-t0.png"></p>
<ul>
<li>需要4个VMs</li>
<li>4个DUT端口连接到VMs</li>
<li>PTF容器有4个注入端口与28个直连端口</li>
</ul>
<h2 id="testbed配置"><a href="#testbed配置" class="headerlink" title="testbed配置"></a>testbed配置</h2><h3 id="testbed清单"><a href="#testbed清单" class="headerlink" title="testbed清单"></a>testbed清单</h3><ul>
<li><code>ansible/lab</code>：包含实验的所有DUTs， fanout switch, testbed server拓扑</li>
<li><code>ansible/veos</code>：所有的server和VMs</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="Sonic-Mgmt-testbed设置"><a href="#Sonic-Mgmt-testbed设置" class="headerlink" title="Sonic-Mgmt testbed设置"></a>Sonic-Mgmt testbed设置</h2><p>从github上将sonic testbed设置到自己的环境中将会是一个冗长的过程。在将测试用例跑起来之前有十多个文件需要更新。<br>然而，这个过程可以通过testbed.yaml和TestbedProcessing.py自动完成。testbed.yaml是一个配置文件（编译所有需要运行testcase的数据到一个文件中）。TestbedProcess.py的工作原理是：从配置文件拉取信息，然后将信息推送到它们属于的文件中去。这篇指南将会勾勒并简易化testbed的设置。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>通过使用testbed.yaml和TestbedProcessing.py来完成testbed的设置。这篇指南结束后，应该完成sonic-mgmt testbed的设置并且将testcases跑起来。</p>
<h3 id="预迁移设置"><a href="#预迁移设置" class="headerlink" title="预迁移设置"></a>预迁移设置</h3><p> sonic-mgmt启动并运行测试用例需要下述的设备：</p>
<ul>
<li>Linux服务器</li>
<li>root fanout</li>
<li>leaf fanout</li>
<li>DUT (device under test)<br>testbed的信息和拓扑可以从overview中获取到。</li>
</ul>
<h3 id="修改-Testbed-yaml配置文件"><a href="#修改-Testbed-yaml配置文件" class="headerlink" title="修改 Testbed.yaml配置文件"></a>修改 Testbed.yaml配置文件</h3><p>在testbed.yaml中有7个主要的部分需要编辑：</p>
<ol>
<li>device_groups</li>
<li>devices</li>
<li>host_vars</li>
<li>veos_groups</li>
<li>veos</li>
<li>testbed</li>
<li>topology<br>每一部分文件的作用都需要按顺序的写好。具体信息在Sonic-Mgmt testbed Configuration中有描述</li>
</ol>
<p>对于testbed.yaml文件（在ansible下面有个testbed-new.yaml文件）：</p>
<h4 id="（可选）testbed-config部分："><a href="#（可选）testbed-config部分：" class="headerlink" title="（可选）testbed_config部分："></a>（可选）testbed_config部分：</h4><ul>
<li>name - 给testbed配置文件选择一个名字</li>
<li>alias - 给testbed配置文件选择一个别名</li>
</ul>
<h5 id="device-groups部分"><a href="#device-groups部分" class="headerlink" title="device_groups部分"></a>device_groups部分</h5><p>用法：lab</p>
<p>device_group部分生成lab文件，是用来设置testbed的的必须清单文件。配置文件的格式是yaml格式，脚本会将之转换成INI格式。device_group部分包含实验室中所有DUTs, fanout switchs，testbed server拓扑。组子节点从下面的device部分介绍。在大多数情况下可以不用管这一部分。</p>
<h4 id="devices部分"><a href="#devices部分" class="headerlink" title="devices部分"></a>devices部分</h4><p>用法：files/sonic_lab_devices, group_vars/fanout/secrets, group_vars/lab/secrets, lab</p>
<p>device部分是包含所有设备和主机的字典。这部分不包含PTF容器的信息。关于PTF容器的信息，查看testbed.csv文件。<br>对每一个你添加的设备，添加下面的信息：</p>
<table>
<thead>
<tr>
<th>Hostname</th>
<th>ansible_host</th>
<th>ansible_ssh_user</th>
<th>ansible_ssh_pass</th>
<th>HwSKU</th>
<th>device_type</th>
</tr>
</thead>
<tbody><tr>
<td>str-msn2700-01</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>DevSonic</td>
<td>DevSonic</td>
</tr>
<tr>
<td>str-7260-10</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>Arista-7260QX-64</td>
<td>FanoutRoot</td>
</tr>
<tr>
<td>str-7260-10</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>Arista-7260QX-64</td>
<td>FanoutLeaf</td>
</tr>
<tr>
<td>str-acs-serv-01</td>
<td>[IP Address]</td>
<td>[username]</td>
<td>[password]</td>
<td>TestServ</td>
<td>Server</td>
</tr>
</tbody></table>
<ul>
<li>hostname - 设备名称</li>
<li>ansible_host - 设备的管理IP</li>
<li>ansible_ssh_user - 设备登录名称</li>
<li>ansible_ssh_pass - 设备登录密码</li>
<li>hesku - 这是用来查阅验证的值（在/group_vars/all/labinfo.json）。没有这部分，就爱那个会失败。确保这部分在labinfo.json中有准确的数据。</li>
<li>device_type - 设备类型。如果只有4种设备，可以将提供标签留白不填写。</li>
</ul>
<p>lab server部分需要不同的字段输入：ansible_become_pass, sonicadmin_user(用户名), sonicadmin_password, sonic_inital_password. 这些字段是可选的，因为它们是直接从group_var/lab/secrets.yml中获取的变量。所以为了便利，这部分的配置文件作为一个拷贝。</p>
<h4 id="host-vars部分"><a href="#host-vars部分" class="headerlink" title="host_vars部分"></a>host_vars部分</h4><p>用法：所有的host_val数据</p>
<p>host的参数在此处设置。在这篇指南中，我们在此处定义server（str-acs-serv-01）：<br>对于每一个你添加的host，定义或确认如下数据：</p>
<ul>
<li>mgmt_bridge</li>
<li>mgmt_prefixlen (这个应该和mgmt_subnet_mask_length匹配)</li>
<li>mgmt_gw</li>
<li>external_about</li>
</ul>
<h4 id="veos-groups部分"><a href="#veos-groups部分" class="headerlink" title="veos_groups部分"></a>veos_groups部分</h4><p>用法：veos</p>
<h4 id="veos部分"><a href="#veos部分" class="headerlink" title="veos部分"></a>veos部分</h4><p>用法：group_vars/eos/cred, main.yml, group_vars/vm_host/creds</p>
<h4 id="testbed部分"><a href="#testbed部分" class="headerlink" title="testbed部分"></a>testbed部分</h4><p>用法： testbed.csv</p>
<h4 id="拓扑部分"><a href="#拓扑部分" class="headerlink" title="拓扑部分"></a>拓扑部分</h4><p>用法： files/sonic_lab_links.csv</p>
<h4 id="docker-registry部分"><a href="#docker-registry部分" class="headerlink" title="docker_registry部分"></a>docker_registry部分</h4><p>用法： /vars/docker_registry.yml</p>
<h3 id="testbed运行脚本"><a href="#testbed运行脚本" class="headerlink" title="testbed运行脚本"></a>testbed运行脚本</h3><p>当testbed.yaml文件配置好后，将TestbedProcess.py和testbed.yaml文件放在sonic-mgmt/ansible下面。</p>
<p>运行TestbedProcessing.py脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python TestbedProcessing.py -i testbed.yaml</span><br><span class="line">options:</span><br><span class="line">-i &#x3D; 解析testbed.yaml文件</span><br><span class="line">-basedir &#x3D; 项目的根目录</span><br><span class="line">-backup &#x3D; 文件的备份文件夹</span><br></pre></td></tr></table></figure>

<h4 id="VMS命令"><a href="#VMS命令" class="headerlink" title="VMS命令"></a>VMS命令</h4><p>开启VMS（使用vms_1）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh start-vms vms_1 password.txt</span><br></pre></td></tr></table></figure>
<p>停止VMS（使用vms_1）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh stop-vms vms_1 password.txt</span><br></pre></td></tr></table></figure>

<h3 id="部署（PTF32）拓扑容器"><a href="#部署（PTF32）拓扑容器" class="headerlink" title="部署（PTF32）拓扑容器"></a>部署（PTF32）拓扑容器</h3><p>在这篇指南中，将会使用testbed-cli.sh添加ptf32-1作为示例</p>
<p>移除拓扑 ptf32-1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh remove-topo ptf32-1 password.txt</span><br></pre></td></tr></table></figure>

<p>添加拓扑 ptf32-1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;testbed-cli.sh add-topo ptf32-1 password.txt</span><br></pre></td></tr></table></figure>
<p>可以使用”docker ps”或者”dokcer container ls”命令去检查是否添加或移除。</p>
<h3 id="运行第一个测试用例（Neighbour）"><a href="#运行第一个测试用例（Neighbour）" class="headerlink" title="运行第一个测试用例（Neighbour）"></a>运行第一个测试用例（Neighbour）</h3><p>当VMs和ptf32-1拓扑成功添加后，第一个测试用例“neighbour”就可以运行起来了。testbed的名字和测试用例的名字需要通过变量声明出来。请检查一下，之后，playbook就可以运行了。<br>运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export TESTBED_NAME&#x3D;ptf32-1</span><br><span class="line">export TESTCASE_NAME&#x3D;neighbour</span><br><span class="line">echo $TESTBED_NAME</span><br><span class="line">echo $TESTCASE_NAME</span><br><span class="line">ansible-playbook -i lab -l sonic-ag9032 test_sonic.ynl -e testbed_name&#x3D;$TESTBED_NAME -e testcase_name&#x3D;$TESTCASE_NAME</span><br></pre></td></tr></table></figure>

<h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><p>问题：Testbed命令行提示没有password文件<br>解决方式：创建一个空的password文件去绕过这个问题</p>
<p>问题：即使在我运行完stop-vms命令后IPs不可达<br>解决方式：如果运行了stop-vms命令后这个问题依然存在，运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virsh</span><br><span class="line">list</span><br><span class="line">destory VM_Name (删除占用这个IP的VM)</span><br><span class="line">exit(退出virsh)，在永久删除这个IPs前请确保没有其它VM使用这个IPs</span><br></pre></td></tr></table></figure>

<p>问题：任务设置失败。SSH Error：data could not be sent to the remote host<br>解决方式：导致这个现象的问题可能有很多。<br>    1. 确保这台主机可以通过SSH到达<br>    2. group_vars/all/lab_info.json文件中包含了正确的凭证吗？<br>    3. 设备在files/sonic_lab_devices.cav中有正确的hwsku吗？<br>    4. 确保lab文件中在IPs后面没有”/“，INI文件无法识别<br>    5. 重新检查testbed.yaml配置文件，是否获取了IPs和正确的凭证</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/15/SONiC%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/15/SONiC%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0%E5%8F%8A%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">SONiC编译简述及优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-15 09:58:41" itemprop="dateCreated datePublished" datetime="2020-12-15T09:58:41+00:00">2020-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SONiC/" itemprop="url" rel="index"><span itemprop="name">SONiC</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>SONiC在docker中完成编译，docker image基于debian(jessie, stretch, buster)完成构建。201807及其之前的版本使用的是jessie, 202006及其之后的版本使用的是buster, 我们现阶段主要使用stretch。SONiC的编译大致分成三个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. git submodules初始化。对应make init</span><br><span class="line">2. 编译环境构建。对应的是Makefile.work中的DOCKER_BASE_BUILD与DOCKER_BUILD，编译环境只需要在第一次使用时进行构建。</span><br><span class="line">3. 主目标编译（sonic-platform.bin）。这里面可以分为kernel编译，外部功能编译（platform, src等），根文件系统的构建。对应的是make target&#x2F;sonic-platform.bin.</span><br></pre></td></tr></table></figure>

<h1 id="submodules初始化优化建议"><a href="#submodules初始化优化建议" class="headerlink" title="submodules初始化优化建议"></a>submodules初始化优化建议</h1><p>执行<code>make init</code>之前，项目文件大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[rancho git]$ du -h --max-depth&#x3D;1</span><br><span class="line">76M     .&#x2F;bytedance-sonic</span><br></pre></td></tr></table></figure>
<p>执行之后的项目文件大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[rancho git]$ du -h --max-depth&#x3D;1</span><br><span class="line">1.9G     .&#x2F;bytedance-sonic</span><br></pre></td></tr></table></figure>
<p>整个过程耗时约22分钟（网络环境不同会有差异），总共27个外部modules。只会在第一次编译项目时进行构建。基于项目管控以及子模块自开发的角度，后续可以将modules迁移到内部gitlab上。字节项目中的sonic-platform-common模块现在就是这样管理的。</p>
<h1 id="编译环境构建的优化"><a href="#编译环境构建的优化" class="headerlink" title="编译环境构建的优化"></a>编译环境构建的优化</h1><p>SONiC通过Dockerfile对每个用户都构建一个编译环境，对于单用户环境这种方式合适，对于使用Linux服务器的<strong>多用户环境</strong>而言，这种方式很不合适，docker image应该给所有用户复用，而不是针对每个用户构建一个内容相同只是名字不同的image。</p>
<h2 id="缺点说明"><a href="#缺点说明" class="headerlink" title="缺点说明"></a>缺点说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 消耗大量存储资源。可使用docker images | grep sonic 查看。</span><br><span class="line">2. 消耗大量网络资源，构建时下载重复数据</span><br><span class="line">3. 消耗大量时间，通过源码完成编译环境的构建大概需要一小时，使用优化后的方法只需要一分钟乃至更少</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>复用相同版本的docker镜像进行编译</p>
<h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><h3 id="对于复用docker镜像搭建编译环境的用户"><a href="#对于复用docker镜像搭建编译环境的用户" class="headerlink" title="对于复用docker镜像搭建编译环境的用户"></a>对于复用docker镜像搭建编译环境的用户</h3><ol>
<li><p><code>docker images</code>查看服务器上是否有所需版本的image, image命名规则为:sonic-version-debian_version, tag为public，例如:sonic-201911-stretch:public，如果有了,跳过步骤2；</p>
</li>
<li><p>获取对应版本image的tar.gz文件</p>
<ol>
<li>我在10.204.112.46上搭建了一个文件服务器，201911-stretch的编译镜像存放在上面，可以通过该链接<code>http://10.204.112.46:8081/sonic-201911/sonic-201911-stretch.tar.gz</code>获取</li>
<li><code>gzip -d sonic-version-debian_version.tar.gz</code></li>
<li><code>docker load --input sonic-version-debian_version.tar</code></li>
</ol>
</li>
<li><p>修改Makefile, 文件位于项目根目录下</p>
<ol>
<li><p>修改Makefile文件如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;Makefile b&#x2F;Makefile</span><br><span class="line">index 13a3f247..542f4077 100644--- a&#x2F;Makefile+++ b&#x2F;Makefile</span><br><span class="line">@@ -1,6 +1,6 @@ </span><br><span class="line"># SONiC make file </span><br><span class="line">-NOJESSIE ?&#x3D; 0</span><br><span class="line">+NOJESSIE ?&#x3D; 1</span><br></pre></td></tr></table></figure>
<p>如果是202006及其之后的版本，将stretch也注释掉。我们只需要用于编译的环境。</p>
</li>
<li><p>修改Makefile.work文件如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;Makefile.work b&#x2F;Makefile.work</span><br><span class="line">index 14c433e4..e7232264 100644</span><br><span class="line">--- a&#x2F;Makefile.work</span><br><span class="line">+++ b&#x2F;Makefile.work</span><br><span class="line">@@ -78,10 +78,12 @@ SLAVE_DIR &#x3D; sonic-slave-stretch</span><br><span class="line">endif</span><br><span class="line">-   SLAVE_BASE_TAG &#x3D; $(shell CONFIGURED_ARCH&#x3D;$(CONFIGURED_ARCH) j2 $(SLAVE_DIR)&#x2F;Dockerfile.j2 &gt; $(SLAVE_DIR)&#x2F;Dockerfile &amp;&amp; sha1sum $(SLAVE_DIR)&#x2F;Dockerfile | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">-   SLAVE_TAG &#x3D; $(shell cat $(SLAVE_DIR)&#x2F;Dockerfile.user $(SLAVE_DIR)&#x2F;Dockerfile | sha1sum | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">-   SLAVE_BASE_IMAGE &#x3D; $(SLAVE_DIR)</span><br><span class="line">-   SLAVE_IMAGE &#x3D; $(SLAVE_BASE_IMAGE)-$(USER)</span><br><span class="line">+   #SLAVE_BASE_TAG &#x3D; $(shell CONFIGURED_ARCH&#x3D;$(CONFIGURED_ARCH) j2 $(SLAVE_DIR)&#x2F;Dockerfile.j2 &gt; $     (SLAVE_DIR)&#x2F;Dockerfile &amp;&amp; sha1sum $(SLAVE_DIR)&#x2F;Dockerfile | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">+   #SLAVE_TAG &#x3D; $(shell cat $(SLAVE_DIR)&#x2F;Dockerfile.user $(SLAVE_DIR)&#x2F;Dockerfile | sha1sum | awk &#39;&#123;print substr($$1,0,11);&#125;&#39;)</span><br><span class="line">+   SLAVE_TAG &#x3D; public</span><br><span class="line">+   #SLAVE_BASE_IMAGE &#x3D; $(SLAVE_DIR)</span><br><span class="line">+   #SLAVE_IMAGE &#x3D; $(SLAVE_BASE_IMAGE)-$(USER)</span><br><span class="line">+   SLAVE_IMAGE &#x3D; sonic-201911-stretch</span><br><span class="line"> </span><br><span class="line">OVERLAY_MODULE_CHECK :&#x3D; \</span><br><span class="line"> lsmod | grep -q &quot;^overlay &quot; &amp;&gt;&#x2F;dev&#x2F;null || \</span><br><span class="line">@@ -113,6 +115,7 @@ DOCKER_RUN :&#x3D; docker run --rm&#x3D;true --privileged \</span><br><span class="line"> -w $(DOCKER_BUILDER_WORKDIR) \</span><br><span class="line"> -e &quot;http_proxy&#x3D;$(http_proxy)&quot; \</span><br><span class="line"> -e &quot;https_proxy&#x3D;$(https_proxy)&quot; \</span><br><span class="line">+   -u root \</span><br><span class="line"> -i$(if $(TERM),t,)</span><br><span class="line"></span><br><span class="line">@@ -200,9 +202,9 @@ endif</span><br><span class="line">    @$(OVERLAY_MODULE_CHECK)</span><br><span class="line">    </span><br><span class="line">-       @docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">-           &#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">-           $(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">+       #@docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">+           #&#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">+           #$(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">        @docker inspect --type image $(SLAVE_IMAGE):$(SLAVE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">            &#123; echo Image $(SLAVE_IMAGE):$(SLAVE_TAG) not found. Building... ; \</span><br><span class="line">            $(DOCKER_BUILD) ; &#125;</span><br><span class="line">@@ -222,9 +224,9 @@ sonic-slave-build :</span><br><span class="line"> </span><br><span class="line">sonic-slave-bash :</span><br><span class="line">        @$(OVERLAY_MODULE_CHECK)</span><br><span class="line">-       @docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">-           &#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">-           $(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">+       #@docker inspect --type image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">+           #&#123; echo Image $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG) not found. Building... ; \</span><br><span class="line">+           #$(DOCKER_BASE_BUILD) ; &#125;</span><br><span class="line">        @docker inspect --type image $(SLAVE_IMAGE):$(SLAVE_TAG) &amp;&gt; &#x2F;dev&#x2F;null || \</span><br><span class="line">            &#123; echo Image $(SLAVE_IMAGE):$(SLAVE_TAG) not found. Building... ; \</span><br><span class="line">            $(DOCKER_BUILD) ; &#125;</span><br><span class="line">@@ -232,7 +234,7 @@ sonic-slave-bash :</span><br><span class="line"> </span><br><span class="line">showtag:</span><br><span class="line">        @echo $(SLAVE_IMAGE):$(SLAVE_TAG)</span><br><span class="line">-       @echo $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG)</span><br><span class="line">+       #@echo $(SLAVE_BASE_IMAGE):$(SLAVE_BASE_TAG)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将SLAVE_IMAGE和SLAVE_TAG修改为复用image及其tag，抛弃SLAVE_BASE_IMAGE的使用。</p>
</li>
<li><p>通过<code>make showtag</code>检查编译环境是否加载正确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+++ Making showtag +++</span><br><span class="line">BLDENV&#x3D;stretch make -f Makefile.work showtag</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;home&#x2F;rancho&#x2F;workdir&#x2F;SONIC-DEV&#x2F;sonic-buildimage&#39;</span><br><span class="line">sonic-201911-stretch:public</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;rancho&#x2F;workdir&#x2F;SONIC-DEV&#x2F;sonic-buildimage&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="对于发布docker编译环境供大家使用的用户"><a href="#对于发布docker编译环境供大家使用的用户" class="headerlink" title="对于发布docker编译环境供大家使用的用户"></a>对于发布docker编译环境供大家使用的用户</h3><ol>
<li><p>按照原有的方式完成编译环境的构建</p>
</li>
<li><p>发布编译环境</p>
<ol>
<li>使用<code>docker tag image-id sonic-version-debian_version:tag</code>进行规法镜像命名</li>
<li>使用<code>docker rmi old_name:old_tag</code>删除生成的镜像tag</li>
<li>使用<code>docker save -o ~/sonic-version-debian_version.tar sonic-version-debian_version:public</code>提取镜像</li>
<li>使用<code>gzip sonic-version-debian_version.tar</code>压缩</li>
<li>将sonic-version-debian_version.tar.gz文件放到文件服务器上供大家使用</li>
</ol>
</li>
</ol>
<h1 id="对于主目标编译"><a href="#对于主目标编译" class="headerlink" title="对于主目标编译"></a>对于主目标编译</h1><p>这里面有个<code>target groups</code>的概念, 在slave.mk里面定义了很多目标组，如SONIC_MAKE_DEBS, SONIC_MAKE_FILES，这些目标组在具体的功能模块中被填充，之后被该组的cmd所执行。参见README.buildsystem.md将会有更好的理解。<br>对于根文件系统的构建，时间很久，主要是每次都会删除之前构建的rootfs然后使用<code>debootstrap</code>重新构建，后续如果需要进行上层功能调试这明显效率很低。这里可以通过替换调试功能所在docker完成快速版本迭代。以路由协议frr举例。</p>
<pre><code>1. make list | grep frr 找到 target/docker-fpm-frr.gz
2. 修改src/sonic-frr中的代码
3. make target/docker-fpm-frr.gz生成新的frr镜像
4. 在SONiC设备上`service bgp stop`停止docker-fpm-frr，并删除该container，删除docker-fpm-frr:latest镜像
5. 将新的镜像拷贝到设备中`docker load -i docker-fpm-frr.gz`，并为之打上latest的tag
6. `service bgp start`重启frr服务，进行代码验证
7. service bgp如果找不到对应的container，则会根据docker-fpm-frr:latest重新创建一个，所以如果需要版本回退，重4,5,6的动作即可
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/08/05/Linux%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/05/Linux%E4%B8%8B%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">Linux下程序调试方法简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-05 14:58:02" itemprop="dateCreated datePublished" datetime="2020-08-05T14:58:02+00:00">2020-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文旨在综合性的描述Linux下程序调试的方法和思路，不会过于细节的描述某种工具的使用，如gdb，这些方法通过man以及google都能找到答案。包含知识点：strip, addr2line, strace, gdb, readelf。</p>
<h2 id="strip相关"><a href="#strip相关" class="headerlink" title="strip相关"></a>strip相关</h2><p>嵌入式系统要求小巧精简，最大限度去除冗余数据。Linux下编译出来elf文件是带有符号表的，通过<code>nm</code>命令可以查看，如：<br><img src="https://rancho333.gitee.io/uploads/nm.png"><br>这些符号表是进行程序调试的关键，例如通过<code>addr2line</code>进行地址和文件名或行数的转换，例如在<code>gdb</code>中通过<code>bt</code>显示函数调用栈信息，没有符号表这些工具都无法提供有价值信息。<br><code>strip</code>命令可以去掉这些符号信息，进而减小文件大小，同时不会影响elf的正常执行。<br><img src="https://rancho333.gitee.io/uploads/compare.png"><br>可以看到，<code>strip app</code>之后，app中没有符号表相关信息了。<br>在进行rootfs制作时，对于发行版本，我们进行<code>strip</code>操作，对于开发人员调试版本，我们保留符号表信息。<br><img src="https://rancho333.gitee.io/uploads/strip.png"></p>
<h2 id="gdb简述"><a href="#gdb简述" class="headerlink" title="gdb简述"></a>gdb简述</h2><p>遇到<code>core dump</code>最常使用的就是<code>gdb</code>了，<code>gdb</code>的一般使用方法<code>gdb app core</code>。常见子命令如下：</p>
<table>
<thead>
<tr>
<th align="left">cmd</th>
<th align="left">function</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bt</td>
<td align="left">回溯显示app堆栈</td>
</tr>
<tr>
<td align="left">bt full</td>
<td align="left">不仅仅显示栈帧，还显示局部变量</td>
</tr>
<tr>
<td align="left">info reg</td>
<td align="left">显示寄存器内容</td>
</tr>
<tr>
<td align="left">run</td>
<td align="left">执行app</td>
</tr>
<tr>
<td align="left">print val</td>
<td align="left">打印变量val的值</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">设置断点</td>
</tr>
</tbody></table>
<p>gdb一般使用<em>断点</em>和<em>堆栈</em>进行程序调试，注意调试的程序一定要是<code>not stripped</code>的。<br>简单示例如下：<br><img src="https://rancho333.gitee.io/uploads/gdb.png"></p>
<h2 id="strace介绍"><a href="#strace介绍" class="headerlink" title="strace介绍"></a>strace介绍</h2><p>strace可以跟踪app的<code>system call</code>和<code>signals</code>，一般使用方法<code>strace app</code>，常见参数如下：</p>
<table>
<thead>
<tr>
<th align="left">cmd</th>
<th align="left">function</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-tt</td>
<td align="left">在每行输出的前面，显示毫秒级别的时间</td>
</tr>
<tr>
<td align="left">-T</td>
<td align="left">显示每次系统调用所花费的时间</td>
</tr>
<tr>
<td align="left">-v</td>
<td align="left">对于某些相关调用，把完整的环境变量，文件stat结构等打出来</td>
</tr>
<tr>
<td align="left">-f</td>
<td align="left">跟踪目标进程，以及目标进程创建的所有子进程</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left">控制要跟踪的事件和跟踪行为,比如指定要跟踪的系统调用名称</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">把strace的输出单独写到指定的文件</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是32个字节</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">指定要跟踪的进程pid, 要同时跟踪多个pid, 重复多次-p选项即可</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">在打印系统调用同时打印指令指针</td>
</tr>
</tbody></table>
<p>举个之前在ENOS飞腾移植过程中的一个例子，先使用gdb做一个基本的错误定位</p>

<p>看起来像是没有进入main函数就已经挂了。<br>使用strace查看命令执行过程中的系统调用和信号：<br><img src="https://rancho333.gitee.io/uploads/strace2.png"><br>找到源码中的对应位置：<br><img src="https://rancho333.gitee.io/uploads/strace3.png"><br>iv_signal_init在main函数之前会执行并挂掉，将之注释掉测试通过。</p>
<h2 id="so库相关"><a href="#so库相关" class="headerlink" title="so库相关"></a>so库相关</h2><p>使用<code>ldd</code>命令可以查看app的依赖库，<code>readelf</code>命令可以获取到更多的内容<br><img src="https://rancho333.gitee.io/uploads/so.png"></p>
<p>如果app的依赖库找不到，报错格式一般如下：<br><img src="https://rancho333.gitee.io/uploads/find.png"></p>
<p>这里面缺少一些动态库，二进制可执行文件，分3种情况：</p>
<ol>
<li>文件不存在</li>
<li>文件存在但路径不对, /etc/ld.so.conf 此文件记录了编译时使用的动态库的路径</li>
<li>有些文件不必须，可以注释掉，参考<br>根据不同的情况处理之。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/16/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">Linux系统移植简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 14:12:38" itemprop="dateCreated datePublished" datetime="2020-03-16T14:12:38+00:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>之前也做过一些移植性的东西，不过都是别人搭好框架，自己填充一些模块，这次有机会完成系统级的移植，非常感谢张总以及胡老师的指点帮助，收获良多！</p>
<h1 id="移植总述"><a href="#移植总述" class="headerlink" title="移植总述"></a>移植总述</h1><p>嵌入式系统移植分为四个大块，分别是构建交叉编译工具，rootfs的制作，kernel的配置、编译、移植，BootLoader的移植。需要移植的系统可以在MIPS上跑起来，我只需要顺着原有的编译框架完成ARM64的编译，之后再上板子做具体的调试。</p>
<h2 id="构建交叉编译工具"><a href="#构建交叉编译工具" class="headerlink" title="构建交叉编译工具"></a>构建交叉编译工具</h2><p>toolchain一般芯片厂家会提供，当然自己通过buildroot构建也是可以的。<br>使用buildroot构建交叉编译工具，下载buildroot2015</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;buildroot.uclibc.org&#x2F;downloads&#x2F;buildroot-2015.08.tar.gz</span><br></pre></td></tr></table></figure>
<p><code>make menuconfig ARCH=arm64</code>配置buildroot，将target和toolchain两项配置成如下所示<br><img src="https://rancho333.gitee.io/uploads/buildroot.png"><br>之后<code>make</code>等待完成即可，buildroot有些源码下载速度很慢，下载网站也不尽相同，比较麻烦，不像Linux发行版可以改成国内镜像软件源，有的可能会等待比较长的时间。<br>将生成的toolchain打包，释放到服务器docker编译环境中，如下所示：<br><img src="https://rancho333.gitee.io/uploads/toolchain.png"><br>之后可以根据container构建image将编译环境发布出去，大家就可以直接使用了。</p>
<h2 id="kernel的配置、编译、移植"><a href="#kernel的配置、编译、移植" class="headerlink" title="kernel的配置、编译、移植"></a>kernel的配置、编译、移植</h2><p>kernel的配置结果保存在<code>.config</code>文件中，根据实际的需求会选配一些内核选项，如开启nat以及veth相关的配置<br><img src="https://rancho333.gitee.io/uploads/nat.png"><br><img src="https://rancho333.gitee.io/uploads/veth.png"><br>这些配置实际上是系统构建完成后跑起来报错才知道需要的，只需要在<code>make menuconfig</code>中搜索对应关键字即可找到编译选项。<br>关于内核编译的一些说明，可以参考这篇文章<br><a href="https://rancho333.gitee.io/2020/03/11/kernel%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/">kernel编译简述</a></p>
<h2 id="rootfs的制作"><a href="#rootfs的制作" class="headerlink" title="rootfs的制作"></a>rootfs的制作</h2><p>在这一步其实花的时间是最多的，因为这里涉及到大量的上层应用模块的编译，然后这些模块的依赖库在交叉工具链中是不存在的，还有部分是需要编译一些独立的Linux命令。解决办法很简单，下载源码，编译出库，之后放到交叉工具链和文件系统中即可。<br>这里说下开源代码交叉编译的经典三部曲<code>configure, make, make install</code>，在configure中会指定交叉编译工具，编译生成文件的install路径,关于动态库的一些理解可以查看这篇文章<br><a href="https://rancho333.gitee.io/2020/02/26/%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E5%BA%93%E4%BB%A5%E5%8F%8Aconstructor%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/">关于动态库以及constructor属性的使用</a><br>嗯，rootfs以前一直用buildroot来制作，这里发现一个不一样的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 使用mktemp命令创建一个临时文件</span><br><span class="line">2. 使用shell命令构建文件系统，就是echo命令然后重定向到临时文件</span><br><span class="line">3. 使用gen_init_cpio和压缩软件构建cpio格式的压缩包</span><br><span class="line">4. 删除临时文件</span><br></pre></td></tr></table></figure>
<p><img src="https://rancho333.gitee.io/uploads/rootfs.png"></p>
<h2 id="BootLoader的移植"><a href="#BootLoader的移植" class="headerlink" title="BootLoader的移植"></a>BootLoader的移植</h2><p>给的开发板上直接烧有uboot，所以这里不涉及自己构建bootloader了。在bring up的过程中遇到一个问题卡了很久：<br><img src="https://rancho333.gitee.io/uploads/panic.png"><br>返回错误8的含义<code>文件没有可执行权限</code>,确认过busybox的执行权限，并且是静态编译，并且可以在同平台的其它机器上执行。<br>真实的错误是kernel在rootfs中没有找到文件系统，比较详细的描述见上文提到的<code>kernel编译简述</code>。</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kernel-style/p/3397705.html">linux init启动分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/11/kernel%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/kernel%E7%BC%96%E8%AF%91%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">kernel编译简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-11 15:48:46" itemprop="dateCreated datePublished" datetime="2020-03-11T15:48:46+00:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在ENOS系统移植的过程中，对于Linux kernel，涉及到kernel的配置，编译，以及二进制镜像uImage的生成。这篇文章分为两块：</p>
<ol>
<li>内核配置系统浅析</li>
<li>vmlinux,uImage,Image的关系或区别</li>
</ol>
<h1 id="内核配置系统浅析"><a href="#内核配置系统浅析" class="headerlink" title="内核配置系统浅析"></a>内核配置系统浅析</h1><p>Linux采用模块化的内核配置系统，保证了内核的可扩展性。Linux内核的配置系统由三个部分组成，分别是：</p>
<ol>
<li>Makefile：分部在Linux内核源码中的Makefile，定义Linux内核的编译规则</li>
<li>配置文件（.config, Kconfig等）</li>
<li>配置工具<ol>
<li>配置命令解释器，对配置脚本中使用的配置命令进行解释</li>
<li>配置用户界面，分为基于字符（make config）,基于Ncurses图形界面（make menuconfig），基于Xwindows图形界面（make xconfig）</li>
</ol>
</li>
</ol>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>Makefile的作用是根据配置的情况，构造出需要编译的源文件列表，然后分别编译，并把目标代码链接到一起，最终形成Linux内核二进制文件。kernel中Makefile相关的文件有：</p>
<ol>
<li>顶层Makefile，是整个内核配置、编译的总体控制文件，产生vmlinux文件和内核模块（module）</li>
<li>.config：内核配置文件，是执行完内核配置的结果，如果没有指定kernel根目录下没有.config，可以在make时指定特定的配置文件进行编译，之后也会在根目录下产生.config</li>
<li>arch/*/Makefile：不同CPU体系的Makefile，系统移植需要多关注一些这部分</li>
<li>各子目录下的Makefile，如drivers下的，负责所在子目录下源代码的管理</li>
<li>Rules.make：规则文件，被所有的Makefile使用</li>
</ol>
<p>用户通过make config后，这里实际就是收集各目录下的Kconfig/deconfig文件生成配置界面，供用户进行功能选择，最后产生<code>.config</code>，如果.config文件存在，则是直接通过.config生成配置界面。顶层Makefile读入.config中的配置选择进行具体模块的编译。顶层Makefiel中会包含具体arch的Makefile<br><img src="https://rancho333.gitee.io/uploads/arch.png"><br>Rules.make其实就是不同模块之间会共用到的Makefile规则。</p>
<p>在ENOS中，系统架构人员将生成好的ARCH的config文件存放ARCH的目录下，上层开发人员编译时直接使用指定的config文件编译即可。<br><img src="https://rancho333.gitee.io/uploads/config.png"><br>之后在指定的<code>O</code>目录下会生成编译过程中生成的文件，这样可以避免污染源码（make clean不能清除么），或者是更便于管理和模块化考虑。<br>如果需要进行kernel的二次配置，需要到<code>O</code>目录下去执行make menuconfig，之后将重新生成的<code>.config</code>拷回<code>ARCH</code>目录覆盖之前的配置文件。这是基于ARCH缺省配置的一种应用，在向内核代码增加了新的功能后，如果新功能对于这个ARCH是必需的，就需要修改此ARCH的缺省配置，修改方法如下：</p>
<ol>
<li>备份.config文件</li>
<li>cp arch/arm/deconfig .config</li>
<li>修改.config</li>
<li>cp .config arch/arm/deconfig</li>
<li>恢复.config</li>
</ol>
<h3 id="配置变量CONFIG"><a href="#配置变量CONFIG" class="headerlink" title="配置变量CONFIG_*"></a>配置变量CONFIG_*</h3><p>.config文件中用配置变量等式来说明用户的配置结果，等式左边是模块/功能,右侧是控制选项，有三种：</p>
<ol>
<li><code>y</code>表示后本编译选项对用的内核代码被静态编译进Linux内核</li>
<li><code>m</code> 表示本编译选项对应的内核代码被编译成模块</li>
<li><code>n</code>表示不选择此编译选项<br>如果根本没有选择某模块，该模块是被注释掉的</li>
</ol>
<h1 id="vmlinux-uImage-Image的关系或区别"><a href="#vmlinux-uImage-Image的关系或区别" class="headerlink" title="vmlinux,uImage,Image的关系或区别"></a>vmlinux,uImage,Image的关系或区别</h1><p>Linux内核有多种格式的镜像，包括vmlinux、Image、zImage、bzImage、uImage、xipImage、bootpImage等。<br>vmlinux是编译出来的最原始的内核文件，未经压缩，vm代表virtual memory Linux支持虚拟内存；<br>Image是经过objcopy处理的只包含二进制数据的内核代码，未经压缩，不是elf格式；objcopy的实质是将所有的符号和 重定位信息都抛弃，只剩下二进制数据。<br>zImage是vmlinux加上解压代码经gzip压缩而成，是ARM linux常用的一种压缩镜像文件。这种格式的Linux镜像多存放在NAND上。bzImage与之类似，只不过是采用了压缩率更高的算法。<br>uImage是uboot专用的镜像文件，它是在zImage之前加上一个长度为0x40的tag，里面包含了镜像文件的类型、加载位置、生成时间、大小等信息。通过mkimage命令可以制作uImage。<br>xipImage多放在NorFlash上直接运行。<br>这里只是一些简单的描述，有待在今后的项目中去加深理解各种格式的使用，存在肯定是有其对应的使用场景的！<br><img src="https://rancho333.gitee.io/uploads/vmlinux.png"></p>
<h1 id="对于文件系统的一点理解"><a href="#对于文件系统的一点理解" class="headerlink" title="对于文件系统的一点理解"></a>对于文件系统的一点理解</h1><p>加在这里可能不是很符合这篇文章的主题！<br>Linux下一切皆文件。Linux系统中任何文件系统的挂载必须满足两个条件：挂载点和文件系统。rootfs之所以存在，是因为需要在VFS机制下给系统提供最原始的挂载点。<br>rootfs其实就是文件系统顶层的<code>/</code>，使用pwd命令后看到的第一个字符，它有三个特点：</p>
<ol>
<li>它是系统自己创建并加载的第一个文件系统，是Linux内核自己创建的，并不是我们常说的外部根文件系统，将外部根文件系统解压或者说挂载到<code>/</code>后就是用户能看到的Linux文件系统，里面有很多的文件夹，如’etc’、’bin’等。<em>不能被unmount或者删除</em>，通过<code>cat /proc/mounts</code>也可以看出。下述的rootfs特指<code>/</code></li>
<li>该文件系统的挂载点就是它自己的根目录项对象</li>
<li>该文件系统仅仅存在于内存中<br>VFS是Linux文件系统实现遵循的一种机制，rootfs是一种是一种具体实现的文件系统，Linux下所有文件系统的实现都必须符合VFS机制（符合VFS的接口），这是二者的真正关系。</li>
</ol>
<p>Linux系统移植过程有一项是制作根文件系统，这里所谓的根文件系统实际上是外部根文件系统，用来释放到rootfs里面。有几个概念<code>ramfs initramfs</code>，ramfs是linux中的一个内存文件系统,initramfs是一种压缩（可以是lzma，zip等，看kernel的支持情况）的cpio格式的归档文件，initrd（initramdisk）也是一中ramfs镜像文件，它是用来在启动过程中初始化系统的，它可以被卸载。区别如下：</p>
<ol>
<li>它必须是和kernel分离的一种形式存在</li>
<li>他只是一个zip压缩的文件系统，而不是cpio文件</li>
<li>initrd中的/initrd程序只是做一些setup操作并最后返回到kernel中执行，而initramfs中的/init执行完后不返回到kernel</li>
</ol>
<p>对于initramfs，也就是系统移植时需要制作的文件系统。它存在于两处，一种是内核编译后自动生成的内部initramfs(在/usr目录下)，另一种是用户自己制作的，通过cmdline将地址传递给kernel的外部initramfs<br>对于内部initramfs，这个文件系统里面实际上啥也没有：<br><img src="https://rancho333.gitee.io/uploads/initramfs_kernel.png"><br>rootfs挂载之后，首先会先释放这个内部的initramfs到rootfs（很显然啥也干不了！<em>没搞清楚为什么会存在，但肯定有原因！</em>）,然后kernel会尝试在rootfs中寻找/init，一旦找到就执行init，kernel也就完成了启动工作，之后init就会接管接下来的工作。如果kernel找不到，就会去找外部initramfs然后释放（uboot下通过initrd参数指定位置）或者按照标准做法解析参数<code>root=</code>（这里面是解压好到某个介质分区的文件系统），试图找到一个文件系统并挂载到rootfs，之后就init。</p>
<p>所以我们实际使用的肯定是外部文件系统了，对于外部的文件系统，我们可以通过不同的方法将它挂载到rootfs。</p>
<ol>
<li>制作一个独立的cpio.lzma包，然后告诉bootloader它的地址，通过cmdline将参数传递给kernel</li>
<li>制作一个独立的包，通过mkimge(只针对于uboot)将kernel+initramfs+dtb打包成一个文件，在uboot下启动（实验过可行）</li>
<li>用外部的initramfs替换kernel自动生成的initramfs，有两种方法：<ol>
<li>先编译kernel，让它生成内部intramfs，然后制作外部initramfs，拷贝替换掉，最后重新编译内核。外部initramfs就会和kernel编成一个文件。ENOS里面使用的是这种方法。</li>
<li>使用内核编译选项CONFIG_INITRAMFS_SOURCE指定根文件系统路径，即kernel会根据给定的文件生成内部initramfs，这里面又有集中不同的给定方式，这里不表。<br><img src="https://rancho333.gitee.io/uploads/kernel_initramfs.png"><br>外部initramfs替换内部initramfs之后，kernel会在第一时间找到/init,所以<code>root=，initrd=</code>这些参数都不会起作用了。</li>
</ol>
</li>
</ol>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/kernel/l-kerconf/">Linux内核配置系统浅析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ultraman_hs/article/details/52838989">zImage和uImage的区别联系</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rikeyone/article/details/52048972">ramfs,rootfs,initramfs,initrd</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunjing_/article/details/53081306">initramfs的使用方法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/10/%E4%B8%AD%E6%96%AD%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/%E4%B8%AD%E6%96%AD%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">中断学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-10 16:07:13" itemprop="dateCreated datePublished" datetime="2020-03-10T16:07:13+00:00">2020-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在ENOS系统移植的过程中需要调试CPU和交换芯片的中断，这里记录一下对中断的学习！</p>
<h1 id="中断简介"><a href="#中断简介" class="headerlink" title="中断简介"></a>中断简介</h1><p>Linux内核需要对连接到计算机上的所有硬件设备进行管理，他们之间需要互相通信，一般有两种方案可以实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 轮询（polling）内核定期对设备的状态进行查询，然后做出相应的处理</span><br><span class="line">2. 中断（interrupt）让硬件在需要的时候向内核发出信号（变内核主动为硬件主动）</span><br></pre></td></tr></table></figure>
<p>轮询是周期性的重复执行，大量耗用CPU的时间，效率比较低，对于实时性比较高的操作，肯定是不适用的。</p>
<p>从物理学的角度看，中断是一种电信号，由硬件设备产生，并直接送入中断控制器（如8259A）的输入引脚上，然后再由中断控制器向CPU发送相应的信号。处理器检测到该信号，便中断当前正在处理的工作，转而去处理中断。对于软件开发人员，一般需要用到的就是中断号和中断处理函数。</p>
<p>提一下，PCIE可以通过MSI(message signaled interrupts)方式实现中断：<br><img src="https://rancho333.gitee.io/uploads/msi.png"><br>CPu里面有一段特殊的寄存器空间，往这个寄存器里面写数据，就会触发CPU中断。pci设备经过配置以后，一旦需要上报中断就会往cpu这种寄存器里面写一个值，触发cpu中断。</p>
<p>中断的处理流程：</p>
<ol>
<li>保存现场</li>
<li>执行中断</li>
<li>恢复被中断进程的现场，继续执行</li>
</ol>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>中断可分为同步（synchronous）中断和异步（asynchronous）中断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 同步中断是当指令执行时由CPU控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后CPU才会发出中断，而不是在代码指令执行期间，比如系统调用</span><br><span class="line">2. 异步中断是指由其他硬件设备依照CPU时钟信号随机产生，即意味着中断能够在指令之间产生，例如键盘中断</span><br></pre></td></tr></table></figure>
<p>同步中断称为异常（exception），异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。<br>异步中断被称为中断（interrupt）,中断可分为可屏蔽中断（Maskable interrupt，外部设备产生的）和非屏蔽中断（Nomaskable interrupt，计算机内部硬件产生的）<br>异常是CPU发出的中断信号，与中断控制器无关，不能被屏蔽。</p>
<p>广义上讲中断可分为四类：中断、故障、陷阱、终止。它们之间的异同点参照下表。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">原因</th>
<th align="left">异步/同步</th>
<th align="left">返回行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中断</td>
<td align="left">来自I/O设备的信号</td>
<td align="left">异步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">陷阱</td>
<td align="left">有意的异常</td>
<td align="left">同步</td>
<td align="left">总是返回到下一条指令</td>
</tr>
<tr>
<td align="left">故障</td>
<td align="left">潜在可恢复的错误</td>
<td align="left">同步</td>
<td align="left">返回到当前指令</td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left">不可恢复的错误</td>
<td align="left">同步</td>
<td align="left">不会返回</td>
</tr>
</tbody></table>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>常见的中断控制器有两种，两片8259A外部芯片’级联’和多级I/O APIC系统，见下图：<br><img src="https://rancho333.gitee.io/uploads/interrupt_ctl.png"><br>至于硬件实现细节这里不做过多描述。辨别一个系统是否正在使用I/O APIC，可以使用如下命令查看：<br><img src="https://rancho333.gitee.io/uploads/interrupts.png"><br>可以看到第6列上显示的是IO-APIC,如果上面显示的是XY-APIC，说明系统正在使用8259A芯片。<br>对上面文件的输出，解释如下：</p>
<ol>
<li>第一列表示IRQ中断号</li>
<li>第二、三、四、五列表示相应的CPu核心被中断的次数</li>
<li>第六列表示使用控制器</li>
<li>第七列表示硬件中断号和中断触发方式（电平或边沿）</li>
<li>第八列表示中断名称</li>
<li>有一些IRQ号会表示为NMI，LOC之类的，这是系统保留的，用户无法访问和配置</li>
</ol>
<p>此外，<code>/proc/interrupts</code>文件中列出的是当前系统使用的中断情况，如果某个中断处理没有安装（包括安装后卸载的），是不会显示的。但是<code>/proc/stat</code>会记录机器从启动开始各个中断序号发生中断的次数。</p>
<h2 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h2><p>x86中支持256种中断，将这些中断源按照0到255的顺序对没中中断进行编号，这个标号叫做中断向量，通常用8位无符号整数来存储这个向量。中断号与中断向量一一映射。<br>中断号和中断向量概念不同。当I/O设备把中断信号发送个中断控制器时，与之关联的是一个中断号；而当中断控制器将该中断信号传递给CPU时，与之关联的是一个中断向量。中断号是以中断控制器的角度而言的；中断向量则是以CPU的角度而言的。<br>通常，Intel将编号为0～31的向量分配给异常和非屏蔽中断。</p>
<h2 id="中断服务例程"><a href="#中断服务例程" class="headerlink" title="中断服务例程"></a>中断服务例程</h2><p>在响应一个具体的中断时，内核会执行一个函数，这个函数被称为中断服务例程（interrupt service routine, ISR）。每一个设备的驱动程序中都会定义相关的中断服务例程。</p>
<p>现今的中断处理流程都会分为两部分:上半部分（top half）和下半部分（bottom half），原因如下：</p>
<ol>
<li>中断可以随时打断CPU对其它程序的执行，如果被打断的代码对系统很重要，那么此时中断处理程序的执行时间应该越短越好</li>
<li>中断处理程序在执行时，会屏蔽同条中断线上的中断请求；如果设置了IRQF_DISABLE，那么该中断服务程序执行时是会屏蔽其他所有其它的中断请求。那么此时应该让中断处理程序执行的越快越好。</li>
</ol>
<p>这样划分是有一定原因的，因为我们必须有一个快速、异步而且简单的处理程序专门来负责对硬件的中断请求作出快速响应，与此同时也要完成那些对时间要求很严格的操作。而那些对时间要求相对宽松，其它的剩余工作则会在稍后的任意时间执行，也就是所谓的下半部分执行。</p>
<p>上半部分只能通过中断处理程序实现，下半部分可以通过多种机制来完成：小任务（tasklet），工作队列，软中断，不管是哪种机制，他们均为下半部分提供了一种执行机制，比上半部分灵活多了，至于何时执行，则由内核负责。</p>
<h1 id="第一个中断测试程序"><a href="#第一个中断测试程序" class="headerlink" title="第一个中断测试程序"></a>第一个中断测试程序</h1><p>了解了下中断的基本概念，下面就写一个小demo来实际测试一下吧。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux&#x2F;init.h&gt;                 </span><br><span class="line">#include &lt;linux&#x2F;kernel.h&gt;          </span><br><span class="line">#include &lt;linux&#x2F;module.h&gt;               </span><br><span class="line">#include &lt;linux&#x2F;moduleparam.h&gt;          </span><br><span class="line">#include &lt;linux&#x2F;interrupt.h&gt;       </span><br><span class="line">#include &lt;linux&#x2F;stat.h&gt;                 </span><br><span class="line">#include &lt;linux&#x2F;slab.h&gt;                                                                                                                                                                                           </span><br><span class="line">                                   </span><br><span class="line">static int irq &#x3D; 1;                 &#x2F;&#x2F;保存中断号irq</span><br><span class="line">static char *devname &#x3D; NULL;        &#x2F;&#x2F;保存中断名称*devname</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用宏module_param来接受参数</span><br><span class="line">module_param(irq, int, 00644);      &#x2F;&#x2F;S_IRUGO&#x3D;00644</span><br><span class="line">module_param(devname, charp, 00644);</span><br><span class="line">                                   </span><br><span class="line">&#x2F;&#x2F;定义一个结构体，在request_irq函数中的void *dev_id经常设置为结构体或NULL</span><br><span class="line">struct dev_info&#123;                   </span><br><span class="line">    int irq_id;                    </span><br><span class="line">    char *dev_name;                </span><br><span class="line">&#125;;                                 </span><br><span class="line">                                   </span><br><span class="line">struct dev_info *mydev_info &#x3D; NULL;</span><br><span class="line">                                   </span><br><span class="line">&#x2F;&#x2F;声明中断处理函数（上半部分）  </span><br><span class="line">static irqreturn_t myirq_handler(int irq, void *dev);</span><br><span class="line">                                   </span><br><span class="line">static int __init myirq_init(void)</span><br><span class="line">&#123;                                  </span><br><span class="line">    printk(&quot;zhw test:Module is working ...\n&quot;);</span><br><span class="line">    &#x2F;&#x2F;分配struct dev_info结构体内存</span><br><span class="line">    mydev_info &#x3D; kmalloc(sizeof(struct dev_info), GFP_KERNEL);</span><br><span class="line">    if(!mydev_info)                </span><br><span class="line">    &#123;                              </span><br><span class="line">        printk(&quot;kmalloc failed!\n&quot;);</span><br><span class="line">        return -1;                 </span><br><span class="line">    &#125;                              </span><br><span class="line">    memset(mydev_info, 0, sizeof(struct dev_info));</span><br><span class="line">    mydev_info-&gt;irq_id &#x3D; irq;   </span><br><span class="line">    &#x2F;&#x2F;分配结构体struct dev_info-&gt;char *dev_name内存</span><br><span class="line">    mydev_info-&gt;dev_name &#x3D; kmalloc(10, GFP_KERNEL);</span><br><span class="line">    if(!mydev_info-&gt;dev_name)   </span><br><span class="line">    &#123;                              </span><br><span class="line">        printk(&quot;kmalloc 1 failed!\n&quot;);</span><br><span class="line">        return -1;                 </span><br><span class="line">    &#125;                              </span><br><span class="line">    mydev_info-&gt;dev_name &#x3D; devname;</span><br><span class="line"></span><br><span class="line">    if(request_irq(irq, &amp;myirq_handler, IRQF_SHARED, devname, mydev_info))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(&quot;%s request IRQ:%d failed\n&quot;, devname, irq);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(&quot;%s request IRQ:%d success..\n&quot;, devname ,irq);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void __exit myirq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;unloading my module ..\n&quot;);</span><br><span class="line">    free_irq(irq, mydev_info);</span><br><span class="line">    printk(&quot;freeing IRQ %d\n&quot;, irq);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static irqreturn_t myirq_handler(int irq, void *dev)</span><br><span class="line">&#123;</span><br><span class="line">    struct dev_info mydev;</span><br><span class="line">    static int count &#x3D; 1;</span><br><span class="line">    mydev &#x3D; *(struct dev_info *)dev;</span><br><span class="line"> </span><br><span class="line">    printk(&quot;key:%d\n&quot;, count);</span><br><span class="line">    printk(&quot;devname:%s. devid:%d\n is working..\n&quot;, mydev.dev_name, mydev.irq_id);</span><br><span class="line">    printk(&quot;ISR is leaving\n&quot;);</span><br><span class="line">    count++;</span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(myirq_init);</span><br><span class="line">module_exit(myirq_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>
<p>因为中断程序一般包含在某个设备的驱动程序中，所以这个程序本质就是一个内核模块。这里面主要就是驱动的初始化，退出，以及中断服务例程（ISR）。这里共享键盘的中断号，x86下键盘的中断号是1.<br>Makefile如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m:&#x3D;first_interrupt.o                                                                                                                                                                                          </span><br><span class="line">KDIR:&#x3D;&#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;build</span><br><span class="line">PWD:&#x3D;$(shell pwd)</span><br><span class="line"> </span><br><span class="line">default:</span><br><span class="line">    $(MAKE) -C $(KDIR) M&#x3D;$(PWD) modules</span><br><span class="line"> </span><br><span class="line">clean:</span><br><span class="line">    rm -rf .*.cmd *.o *.mod.c *.ko .tmp_versions</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<ol>
<li>cat /proc/interrupts查看中断号，注意如果是使用ssh或telent到linux上的是不会响应键盘中断的，需要使用虚拟机来实验</li>
<li>加载驱动<code>sudo insmod ./first_interrupt.ko irq=1 devname=zhwirq</code></li>
<li>查看驱动<code>lsmod | grep first</code>,查看中断<code>cat /proc/interrupts | grep zhw</code></li>
<li>dmesg查看内核日志文件，dmesg | tail -20<br><img src="https://rancho333.gitee.io/uploads/dmesg.png"></li>
<li>卸载驱动<code>sudo rmmod first_interrupt</code></li>
</ol>
<p>加载驱动后，先进行驱动初始化，之后每当有键盘中断触发后，都会进入ISR，卸载驱动后不会再触发。</p>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2014-03/98012.htm">Linux下的中断（interrupt） 简介</a><br><a target="_blank" rel="noopener" href="http://edsionte.com/techblog/archives/1495">中断入门</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wordwarwordwar/article/details/81182910">PCI&amp;PCIE MSI中断</a><br><a target="_blank" rel="noopener" href="http://control.blog.chinaunix.net/uid-22666248-id-3052413.html">第一个中断驱动程序</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yzytr/article/details/77659302">如何编译内核ko</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/03/09/Linux%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/Linux%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/" class="post-title-link" itemprop="url">Linux密码修改</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-09 17:20:27" itemprop="dateCreated datePublished" datetime="2020-03-09T17:20:27+00:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 12:15:18" itemprop="dateModified" datetime="2021-04-02T12:15:18+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在做交换机Linux系统移植的过程中，发现进入shell的密码还是上一家的默认密码，还是改改吧。简单交代一下，ENOS上kernel加载完成之后应用的启动顺序如下如：<br><img src="https://rancho333.gitee.io/uploads/inittab.png"><br>这里是不进入shell的，而是直接进入klish作为交换机的命令行交互界面，类似于quagga的vtysh。之后在<code>configure</code>视图下面执行<code>start shell</code>进入linux shell的。<br><img src="https://rancho333.gitee.io/uploads/shell.png"><br>在fnconvert里面会获取用户<code>root</code>的密码，其实就是使用<code>getspnam</code>获取<code>passwd或者shadow</code>的口令。既然这玩意使用的是Linux的账户和密码，那就是修改<code>/etc/passwd</code>文件了。<br><img src="https://rancho333.gitee.io/uploads/spnam.png"></p>
<h1 id="passwd文件简介"><a href="#passwd文件简介" class="headerlink" title="passwd文件简介"></a>passwd文件简介</h1><p>Linux中每个用户在/etc/passwd文件中都有一个对应的记录行，每一行被冒号<code>:</code>分隔为7个字段，具体含义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：口令：用户标识号：组标识号：注释性描述：主目录：登陆shell</span><br></pre></td></tr></table></figure>
<p>发行版中口令字段一般是<code>*或x</code>，<code>*</code>表示账号锁定, <code>x</code>表示密码存放在<code>/etc/shadown</code>文件中（访问需要sudo权限，而passwd文件不需要），当然我们的嵌入式系统密文是直接放在passwd中，如下：<br><img src="https://rancho333.gitee.io/uploads/passwd.png"></p>
<p>其它字段除了<code>登陆shell</code>就没啥好玩的了，有些账号出于安全限制，并不会允许登陆进shell，而采用<code>nologin</code>的方式可以让这些用户使用部分系统功能。<br><img src="https://rancho333.gitee.io/uploads/nologin.png"></p>
<h2 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h2><p>常规的在linux命令行下面修改密码没啥好说的，直接敲<code>passwd</code>然后输入新密码就行了，之后你会发现<code>passwd或者shadow</code>中的口令发生变化了。这里介绍一下口令了列的组成，不同的特殊字符表示不同的特殊意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 该列留空，即&quot;::&quot;，表示该用户没有密码。</span><br><span class="line">2. 该列为&quot;!&quot;，即&quot;:!:&quot;，表示该用户被锁，被锁将无法登陆，但是可能其他的登录方式是不受限制的，如ssh公钥认证的方式，su的方式。</span><br><span class="line">3. 该列为&quot;*&quot;，即&quot;:*:&quot;，也表示该用户被锁，和&quot;!&quot;效果是一样的。</span><br><span class="line">4. 该列以&quot;!&quot;或&quot;!!&quot;开头，则也表示该用户被锁。</span><br><span class="line">5. 该列为&quot;!!&quot;，即&quot;:!!:&quot;，表示该用户从来没设置过密码。</span><br><span class="line">6. 如果格式为&quot;$id$salt$hashed&quot;，则表示该用户密码正常。其中$id$的id表示密码的加密算法，$1$表示使用MD5算法，$2a$表示使用Blowfish算法，&quot;$2y$&quot;是另一算法长度的Blowfish,&quot;$5$&quot;表示SHA-256算法，而&quot;$6$&quot;表示SHA-512算法。加密算法会根据salt进行特定的加密，hashed是生成的密文</span><br></pre></td></tr></table></figure>
<p>我看自己的linux服务器上面都是使用SHA-512加密的，而嵌入式系统上面用的是MD5，使用命令<br><img src="https://rancho333.gitee.io/uploads/openssl.png"><br>就可以生成密码了，将原来的口令字段替换掉即可完成密码的修改。</p>
<p>有个小问题，实验过程中，发现在嵌入式系统上直接在命令行中修改密码不是按照<code>$id$salt$hashed</code>模式生成的口令，而是：<br><img src="https://rancho333.gitee.io/uploads/abnormal.png"><br>但是在发行版Linux上面是符合预期的，有可能是嵌入式系统的某些差异吧，这里留个记录！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rancho</p>
  <div class="site-description" itemprop="description">No pain, no gain!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rancho</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
