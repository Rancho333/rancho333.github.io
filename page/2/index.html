<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/R-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/R-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rancho333.gitee.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="No pain, no gain!">
<meta property="og:type" content="website">
<meta property="og:title" content="Rancho Blog">
<meta property="og:url" content="https://rancho333.gitee.io/page/2/index.html">
<meta property="og:site_name" content="Rancho Blog">
<meta property="og:description" content="No pain, no gain!">
<meta property="og:locale">
<meta property="article:author" content="Rancho">
<meta property="article:tag" content="Racncho, Rancho Blog, 嵌入式">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rancho333.gitee.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Rancho Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rancho Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知行合一，致良知！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Rancho333" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/02/03/vxlan%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/03/vxlan%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">vxlan学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-03 10:24:44" itemprop="dateCreated datePublished" datetime="2021-02-03T10:24:44+08:00">2021-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>vxlan是overlay层的应用，vlan是underlay层的应用。这篇文档是vxlan的学习文档，在学习vxlan之前，会简单介绍下vlan，之后进入vxlan学习。学习完成后，应该搞明白以下的几个问题：</p>
<ul>
<li>什么是vxlan</li>
<li>vxlan解决了什么问题，应用场景是什么</li>
<li>vxlan报文的封装格式是什么样的</li>
<li>什么是VTEP和VNI</li>
<li>哪些VTEP之间需要建立vxlan隧道<ul>
<li>什么是<code>同一大二层域</code></li>
</ul>
</li>
<li>vxlan隧道是如何建立的<ul>
<li>如何确定报文属于那个BD，哪些报文进入vxlan隧道</li>
<li>如何确定报文走那条隧道</li>
</ul>
</li>
<li>什么是vxlan二层网关和三层网关</li>
<li>什么是vxlan集中式网关与分布式网关<ul>
<li>集中式网关中同子网互通流程是怎样的</li>
<li>集中式网关中不同子网互通流程是怎样的</li>
</ul>
</li>
<li>什么是BGP EVPN<ul>
<li>分布式网关中报文的转发流程是怎样的</li>
</ul>
</li>
</ul>
<h1 id="vlan介绍"><a href="#vlan介绍" class="headerlink" title="vlan介绍"></a>vlan介绍</h1><p>VLAN(virtual local area network)即虚拟局域网，是将一个物理的LAN在逻辑上划分多个广播域的通信技术。根据IEEE 802.1Q协议规定，在以太网数据帧的目的MAC地址和源MAC地址字段之后、协议字段之前加入4个字节的VLAN tag，用以标识VLAN信息，VLAN数据帧格式如下图所示。</p>
<p><img src="https://rancho333.gitee.io/pictures/vlan_frame.png"></p>
<p>对于交换机而言，其内部处理的数据帧都带有VLAN tag，现网中交换机连接的设备只会接收Untagged帧。交换机需要有识别Untagged帧并在收发时给帧添加、剥离VLAN标签的能力，交换机间的接口需要有同时识别和发送多个vlan数据帧的能力。</p>
<p>根据接口对象和收发数据帧处理的不同，下面介绍4中链路类型，用以适应不同的连接和组网：</p>
<ul>
<li>Access接口：一般用于交换机与用户终端相连。Access接口大部分情况只能收发Untagged帧，且只能为Untagged帧添加唯一的VLAN tag。</li>
<li>Trunk接口：一般用于交换机之间相连。允许多个VLAN的帧带tag通过，但只允许一个VLAN的帧(默认vlan)从该类型接口上发出时不带tag。</li>
<li>Hybridd接口：Access和Trunk的混合。</li>
<li>使用QinQ(802.1Q-in-802.1Q)协议，一般用于私网与公网之间的连接，也被称为Dot1q-tunnel接口，它可以给vlan加上双层Tag，最多支持4094*4094个VLAN。</li>
</ul>
<p>下面介绍一下vlan划分的方式及使用场景：</p>
<table>
<thead>
<tr>
<th align="left">划分方式</th>
<th align="left">简介</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基于接口</td>
<td align="left">根据交换机的接口来划分vlan</td>
<td align="left">使用与任何大小但是位置比较固定的网络</td>
</tr>
<tr>
<td align="left">基于MAC地址</td>
<td align="left">根据数据帧的源MAC地址来划分VLAN</td>
<td align="left">适用于位置经常移动但网卡不经常更换的小型网络</td>
</tr>
<tr>
<td align="left">基于子网</td>
<td align="left">根据数据帧中的源IP地址和子网掩码来划分VLAN</td>
<td align="left">适用于安全需求不高、对移动性和简易管理需求比较高的场景</td>
</tr>
<tr>
<td align="left">基于网络层协议</td>
<td align="left">根据数据帧所属的协议(族)类型及封装格式</td>
<td align="left">适用于需要同时运行多协议的网络</td>
</tr>
<tr>
<td align="left">基于匹配策略</td>
<td align="left">根据配置的策略划分VLAN,能实现上述的多种组合</td>
<td align="left">使用与需求比较复杂的环境</td>
</tr>
</tbody></table>
<p>两个概念，vlan的透传和终结，vlan的透传就是某个vlan不仅在一台交换机上有效，它还要通过某种方式延伸到别的以太网交换机上，在别的设备上照样有效，vlan的透传可以使用802.1Q协议，trunk链路上使用。vlan的终结意思相对，某个vlan的有效域不能再延伸到别的设备，或者不能通过某条链路延伸到别的设备，可以使用pvlan技术实现，主要在vlan数据出端口到终端设备，或者上三层转发时剥离。这两者的本质就是保留vlan tag和去除vlan tag。</p>
<h1 id="vxlan学习"><a href="#vxlan学习" class="headerlink" title="vxlan学习"></a>vxlan学习</h1><h2 id="什么是vxlan"><a href="#什么是vxlan" class="headerlink" title="什么是vxlan"></a>什么是vxlan</h2><p>vxlan(virtual extensible local area network)虚拟扩展局域网，是有IETF定义的NVO3(network virtualization over layer 3)标准技术之一。vxlan的本质是一种隧道技术，将L2的以太帧封装到UDP报文中在L3网络中传输。虽然从名字上看，vxlan是vlan的一种扩展协议，但是vxlan构建虚拟隧道的本领已经和vlan迥然不同了。vxlan报文格式如下图所示。</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_tag.png"></p>
<p>如上图所示，VTEP对VM发送的原始以太帧（original L2 frame）进行了如下的封装：</p>
<table>
<thead>
<tr>
<th align="left">封装</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vxaln header</td>
<td align="left">增加vxlan头(8字节),其中24bits的VNI用来标识vxlan</td>
</tr>
<tr>
<td align="left">udp header</td>
<td align="left">vxlan头和原始以太帧一起作为UDP的数据。UDP中，目的端口号(vxlan port)固定为4789</td>
</tr>
<tr>
<td align="left">outer ip header</td>
<td align="left">src ip为源VM所属VTEP的IP地址，目的IP地址为目的VM所属VTEP的IP地址</td>
</tr>
<tr>
<td align="left">outer mac header</td>
<td align="left">src mac为源VM所属VTEP的mac地址，目的mac地址为到达VTEP的路径的下一跳设备的mac地址</td>
</tr>
</tbody></table>
<h2 id="vxlan的应用场景"><a href="#vxlan的应用场景" class="headerlink" title="vxlan的应用场景"></a>vxlan的应用场景</h2><p>vxlan的主要应用场景是数据中心。vxlan可以满足数据中心的三个关键需求：</p>
<ol>
<li>数据中心服务器侧虚拟化后出现了虚拟机动态迁移，要求提供一个无障碍接入的网络</li>
<li>数据中心规模庞大，租户数量激增，要求网络提供隔离海量租户的能力</li>
<li>针对虚拟机规模受网络规格限制的解决方案。对接入交换机，MAC地址规格需求极大降低，但是对核心网关要求极高。两个vxlan可以具有相同的MAC地址，但在一个vxlan内不能有重复的mac地址</li>
</ol>
<p>对于虚拟机动态迁移，不仅虚拟机的IP地址不变，而且虚拟机的运行状态也必须保持原状（如TCP会话状态），所以虚拟机动态迁移只能在一个二层域中进行。vxlan可以将整个数据中心基础网络虚拟化成一台巨大的“二层交换机”，所有的服务器都连结在这台二层交换机上。underlay网路具体如何转发，服务器完全无需关心。将虚拟机从“二层交换机”的一个端口换到另一个端口，完全无需变更IP地址。<br>使用这种理念的技术协议，除了vxlan外，还有NVGRE、STT等。</p>
<p>传统网络中，vlan数量只有4000个左右，vxlan理论上可以支持16M的vxlan段，从而满足大规模不同网络之间的标识、隔离需求。</p>
<h2 id="vxlan的隧道是如何建立的"><a href="#vxlan的隧道是如何建立的" class="headerlink" title="vxlan的隧道是如何建立的"></a>vxlan的隧道是如何建立的</h2><h3 id="vxlan中的VTEP和VNI"><a href="#vxlan中的VTEP和VNI" class="headerlink" title="vxlan中的VTEP和VNI"></a>vxlan中的VTEP和VNI</h3><p>下面了解一下vxlan网络模型以及一些常见的概念，如下图所示，两台服务器之间通过vxlan的网络进行通信。</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_network_module.png"></p>
<p>如上图所示，vxlan报文在vtep两端又一个封装和解封装的操作。</p>
<p>VTEP(vxlan tunnel endpoints, vxlan隧道断点)是vxlan网路的边缘设备，是vxlan隧道的起点个终点，vxlan对用户原始数据帧的封装和解封装均在VTEP上进行。VTEP既可以是一台独立的网络设备，也可以是服务器中的虚拟交换机。</p>
<p>VNI(vxlan network identifier, vxlan网络标识符)是一种类似VLAN ID的用户标识，一个VNI代表了一个租户，属于不同的VNI虚拟机之间不能直接进行二层通信。在分布式网关的部署场景下，VNI可以分为二层VNI和三层VNI：</p>
<ul>
<li>二层VNI是普通VNI，以1:1方式映射到广播域BD，实现vxlan报文同子网的转发</li>
<li>三层VNI和VPN实例进行关联，用于vxlan报文跨子网的转发，参见EVPN相关</li>
</ul>
<h3 id="那些VTEP之间需要建立vxlan隧道"><a href="#那些VTEP之间需要建立vxlan隧道" class="headerlink" title="那些VTEP之间需要建立vxlan隧道"></a>那些VTEP之间需要建立vxlan隧道</h3><p>连接在不同的VTEP上的VM之间如果有“大二层”互通的需求，这两个VTEP之间就需要建立vxlan隧道。换言之，同一个大二层域内的VTEP之间都需要建立VTEP隧道。</p>
<p><code>同一个大二层域</code>类似于传统网络中VLAN(虚拟局域网)的概念，在vxlan中它有另一个名字，叫做Bridge-Domain，简称BD。vlan是通过vlan id来标识的，BD则是通过VNI来标识的，BD与VNI是1:1的映射关系。以华为CloudEngine系列交换机而言，可以如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bridge-domain 10        #表示创建一个大二层广播域，编号是10</span><br><span class="line">  vxlan vni 5000        #表示在BD下，指定与之关联的VNI是5000</span><br></pre></td></tr></table></figure>
<p>有了映射之后，进入VTEP的报文就可以根据自己所属的BD来确定报文封装时添加的VNI。那么怎么确定报文属于那个BD呢？</p>
<p>VTEP只是交换机承担的一个角色，只是交换机功能的一部分。并非所有进入交换机的报文都会走Vxlan隧道（也可能报文就是走普通二三层转发流程）。</p>
<p>在vlan的接口对报文处理的流程是：</p>
<ol>
<li>根据配置来检查哪些报文时允许通过的</li>
<li>判断对检查通过的报文做怎样的处理</li>
</ol>
<p>在vxlan网络中，VTEP上的接口承担类似的任务，这个接口是个叫做<code>二层子接口</code>的逻辑接口。二层子接口对报文的处理流程是：</p>
<ol>
<li>根据配置来检查哪些报文需要进入vxlan隧道</li>
<li>判断对检查通过的报文做怎样的处理</li>
</ol>
<p>在二层子接口上，可以根据需要定义不同的流封装类型（类似传统网络中不同的接口类型），一般有dot1q、untag、qinq和default四种类型：</p>
<ul>
<li>dot1q:对于带一层vlan tag的报文，该类型的接口只接受与指定vlan tag匹配的报文；对于带有两层vlan tag的报文，该类型接口只接收外层vlan tag与指定VLAN tag匹配的报文</li>
<li>untag：只接收不带vlan tag的报文</li>
<li>qinq：只接收带有指定两层vlan tag的报文</li>
<li>default: 允许接口接收所有的报文，不区分报文中是否带有vlan tag。不论是对原始报文进行vxlan封装还是解封装，该类型接口都不会对原始报文进行任何vlan tag处理，包括添加、替换和剥离。</li>
</ul>
<p>vxlan隧道两端二层子接口的配置并不一定是完全相等的。正因为这样，才可能实现属于同一网段但是不同vlan的两个vm通过vxlan隧道进行通信。</p>
<p>除二层子接口外，还可以将vlan作为业务接入点。将vlan绑定到BD后，加入该vlan的接口即为vxlan业务接入点，进入接口的报文由vxlan隧道处理。</p>
<p>只要将二层子接口加入指定的BD，然后根据二层子接口上的配置，设备就可以确定报文属于那个BD啦！</p>
<h3 id="vxlan隧道是怎么建立的"><a href="#vxlan隧道是怎么建立的" class="headerlink" title="vxlan隧道是怎么建立的"></a>vxlan隧道是怎么建立的</h3><p>两种方式，手动或自动。</p>
<h4 id="手动建立"><a href="#手动建立" class="headerlink" title="手动建立"></a>手动建立</h4><p>这种方式需要用户手动指定vxlan隧道源IP为本端VTEP的IP、目的IP为对端VTEP的IP，也就是人为在本端VTEP和对端VTEP之间建立静态VXLAN隧道。</p>
<p>以华为CloudEngine系列交换机为例，在NVE(network virtualization edge)接口下完成配置，配置举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Nve1          #创建逻辑接口NVE 1</span><br><span class="line">    source 1.1.1.1          #配置源VTEP的IP地址（推荐使用Loopback接口的IP地址）</span><br><span class="line">    vni 5000 head-end peer-list 2.2.2.2</span><br><span class="line">    vni 5000 head-end peer-list 2.2.2.3</span><br></pre></td></tr></table></figure>
<p>两条vni命令表示VNI 5000的对端VTEP有两个。根据这两条配置，VTEP上会生成如下所示的一张表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;HUAWEI&gt; display vxlan vni 5000 verbose</span><br><span class="line">BD ID : 10</span><br><span class="line">State : up</span><br><span class="line">NVE : 288</span><br><span class="line">Source Address : 1.1.1.1</span><br><span class="line">Source IPv6 Address : -</span><br><span class="line">UDP Port : 4789</span><br><span class="line">BUM Mode : head-end</span><br><span class="line">Group Address : -</span><br><span class="line">Peer List : 2.2.2.2 2.2.2.3</span><br><span class="line">IPv6 Peer List : -</span><br></pre></td></tr></table></figure>
<p>根据这张表的Peer List，本端VTEP就可以知道属于同一BD的对端VTEP有哪些，这也决定了同一大二层广播域的范围。当VTEP收到BUM(broadcast&amp;unknown-unicast&amp;multicast)报文时，会将报文复制并发送给peer list中所列的所有对端VTEP（类似广播报文在VLAn内广播）。因此，这张表也被称为”头端复制列表”。当VTEP收到一致单播报文时，会根据VTEP上的MAC表来确定报文要从那条vxlan隧道走。而此时Peer List中所列出的对端，则充当了MAC表中”出接口”的角色。</p>
<h4 id="自动建立"><a href="#自动建立" class="headerlink" title="自动建立"></a>自动建立</h4><p>自动建立则需要借助EVPN(Ethernet VPN)协议。</p>
<h4 id="如何确定报文走那条隧道"><a href="#如何确定报文走那条隧道" class="headerlink" title="如何确定报文走那条隧道"></a>如何确定报文走那条隧道</h4><p>参见<code>vxlan网络中报文时如何转发的</code>章节。</p>
<h2 id="vxlan网关有哪些种类"><a href="#vxlan网关有哪些种类" class="headerlink" title="vxlan网关有哪些种类"></a>vxlan网关有哪些种类</h2><h3 id="vxlan二层网关与三层网关"><a href="#vxlan二层网关与三层网关" class="headerlink" title="vxlan二层网关与三层网关"></a>vxlan二层网关与三层网关</h3><p>和vlan类似，不同VNI之间的主机，以及vxlan网络和非vxlan网络中的主机不能直接相互通信，为了满足这些通信需求，vxlan引入了vxlan网关的概念。vxlan网关分为二层网关和三层网关：</p>
<ul>
<li>二层网关：用于终端接入vxlan网络，也可用于同一vxlan网络的子网通信</li>
<li>三层网关：用于vxlan网络中跨子网通信以及访问外部网络</li>
</ul>
<p>具体说明下。<br>vxlan三层网关。用于终结vxlan网络，将vxlan报文转换成传统三层报文发送至IP网络，适用于vxlan网络内服务器与远端之间的三层互访；同时也作不同vxlan网络互通，如下图所示.当服务器访问外部网络时，vxlan三层网关剥离对应vxlan报文封装，送入IP网络；当外部终端访问vxlan内的服务器时，vxlan根据目的IP地址所属vxlan及所属的VTEP，加上对应的vxlan报文头封装进入vxlan网络。vxlan之间的互访流量与此类似，vxlan网关剥离vxlan报文头，并基于目的IP地址所属vxlan及所属的VTEP，重新封装后送入另外的vxlan网络。<br><img src="https://rancho333.gitee.io/pictures/vxlan_l3_gateway.png"></p>
<p>vxlan二层网关。用于终结vxlan网络。将vxlan报文转换成对应的传统二层网络送到传统以太网路，适用于vxlan网络内服务器与远端终端或远端服务器的二层互联。如在不同网络中做虚拟机迁移时，当业务需要传统网络中服务器与vxlan网络中服务器在同一个二层中，此时需要使用vxlan二层网关打通vxlan网络和二层网络。如下图所示。vxlan10网络中的服务器要和IP网络中vlan100的业务二层互通，此时就需要通过vxlan的二层网关进行互联。vxlan10的报文进入IP网络的流量，剥离vxlan报文头，根据vxlan的标签查询对应的vlan网络，并据此在二层报文中加入vlan的802.1Q报文送入IP网络；相反vlan100的业务流量进入vxlan也需要根据vlan获知对应的vxlan的vni，根据目的mac地址获知远端vtep的IP地址，基于以上信息进行vxlan封装后送入对应的vxlan网络。</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_l2_gateway.png"></p>
<h3 id="vxlan集中式网关与分布式网关"><a href="#vxlan集中式网关与分布式网关" class="headerlink" title="vxlan集中式网关与分布式网关"></a>vxlan集中式网关与分布式网关</h3><p>集中式网关指将三层网关集中部署在一台设备上,如下图所示，所有跨子网的流量都经过这个三层网关转发，实现流量的集中管理。</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_gateway.png"></p>
<p>集中式网关的优点和缺点如下：</p>
<ul>
<li>优点：对跨子网流量进行集中管理，网关部署和管理比较简单</li>
<li>缺点：<ul>
<li>转发路径不是最优</li>
<li>ARP表项规格瓶颈。通过三层网关转发的终端的ARP表项都需要在三层网关上生成。</li>
</ul>
</li>
</ul>
<p>vxlan分布式网关是指在典型的”spine-leaf”组网结构下，将leaf节点作为vxlan隧道断点VTEP，每个leaf节点都可作为vxlan三层网关(同时也是vxlan二层网关)，spine节点不感知vxlan隧道，只作为vxlan报文的转发节点。如下图所示</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_gateway_2.png"></p>
<p>部署分布式网关时：</p>
<ul>
<li>spine节点：关注于高速IP转发，强调的是设备的高速转发能力</li>
<li>leaf节点：<ul>
<li>作为vxlan网络的二层网关，与物理服务器或vm对接，用于解决终端租户接入vxlan虚拟网络的问题</li>
<li>作为vxlan网络的三层网关，进行vxlan报文封装与解封装，实现跨子网的终端租户通信，以及外部网络的访问</li>
</ul>
</li>
</ul>
<p>vxlan分布式网关具有如下特点：</p>
<ul>
<li>同一个leaf节点既可以做vxlan二层网关，也可以做vxlan三层网关</li>
<li>leaf节点只需要学习自身连接服务器的ARP表项，而不必像集中三层网关一样，需要学习所有服务器的ARP表项，解决了集中式三层网关带来的ARP表项瓶颈问题，网络规模扩展能力强</li>
</ul>
<h2 id="vxlan网络中报文时如何转发的"><a href="#vxlan网络中报文时如何转发的" class="headerlink" title="vxlan网络中报文时如何转发的"></a>vxlan网络中报文时如何转发的</h2><p>这里介绍集中式vxlan中相同子网内、不同子网间是如何进行通信的。对于分布式vxlan网络，在EVPN中介绍。<br>对于二三层转发通信细节不是很清楚的同学，建议学习下二层与三层ping中arp与icmp报文的交互细节。</p>
<h3 id="集中式vxlan中同子网互通流程"><a href="#集中式vxlan中同子网互通流程" class="headerlink" title="集中式vxlan中同子网互通流程"></a>集中式vxlan中同子网互通流程</h3><p><img src="https://rancho333.gitee.io/pictures/vxlan_l2_ct.png"></p>
<p>如上图所示，VM_A、VM_B、VM_C属于相同网段，且同属VNI 5000。C要与A进行通信，对于首次通信，需要通过ARP获取对方MAC。在vlan子网通信中，arp报文在vlan内广播。在vxlan相同子网中，ARP请求报文转发流程见下图</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_l2_arp_request.png"></p>
<p>A向C进行MAC请求的过程如下：</p>
<ol>
<li>A发送ARP请求报文请求C的MAC</li>
<li>VTEP_1收到ARP请求后<ol>
<li>根据二层子接口上的配置判断报文需要进入vxlan隧道，确定报文所属BD，VNI</li>
<li>VTEP_1学习A的MAC、VNI和报文入接口的对应关系，记录到MAC地址表中</li>
<li>VTEP_1根据头端复制列表对报文进行复制，并分别进行封装，其中：<ol>
<li>外层源IP为本地VTEP_1的IP地址，外层目的IP地址为对端VTEP(VTEP_2、VTEP_3)的IP地址</li>
<li>外层源MAC地址为本地VTEP的mac地址，外层目的mac地址为去往目的IP网络的下一跳设备mac地址</li>
<li>封装完成之后就是在underlay网络中将vxlan报文传送到对端VTEP</li>
</ol>
</li>
</ol>
</li>
<li>VTEP_2和VTEP_3收到报文后，对报文进行解封装，得到A发送的原始报文<ol>
<li>VTEP_2和VTEP_3学习A的MAC地址、VNI和远端VTEP_1IP地址的对应关系，并记录在本地MAC表中</li>
<li>VTEP_2和VTEP_3根据二层子接口上的配置进行相应的处理并在对应的二层域内广播</li>
</ol>
</li>
<li>B和C收到arp报文后，按照arp报文处理方式进行丢弃或应答。这里C向A发送ARP应答。</li>
</ol>
<p>ARP应答报文转发流程见下图</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_l2_arp_reply.png"></p>
<p>C向A发送ARP 应答报文的过程如下：</p>
<ol>
<li>A向C发送ARP应答报文</li>
<li>VTEP_3收到ARP应答报文后<ol>
<li>确定报文所属的BD、VNI</li>
<li>VTEP_3学习C的MAC、VNI和报文入接口的对应关系，记录到MAC地址表中</li>
<li>VTEP_3对报文进行封装，其中：<ol>
<li>外层源IP为本地VTEP_3的IP地址，外层目的IP地址为对端VTEP_1的IP地址</li>
<li>外层源MAC地址为本地VTEP的mac地址，外层目的mac地址为去往目的IP网络的下一跳设备mac地址</li>
<li>封装完成之后就是在underlay网络中将vxlan报文传送到对端VTEP</li>
</ol>
</li>
</ol>
</li>
<li>VTEP_1收到报文后，对报文进行解封装，得到C发送的原始报文<ol>
<li>VTEP_1学习C的MAC地址、VNI和远端VTEP_3IP地址的对应关系，并记录在本地MAC表中</li>
<li>VTE_1将解封后的报文发送给A</li>
</ol>
</li>
</ol>
<p>至此，A和C均已学习到了对方的MAC地址。</p>
<h3 id="集中式vxlan不同子网互通流程"><a href="#集中式vxlan不同子网互通流程" class="headerlink" title="集中式vxlan不同子网互通流程"></a>集中式vxlan不同子网互通流程</h3><p><img src="https://rancho333.gitee.io/pictures/vxlan_l3_ct.png"></p>
<p>A、B分属不同网段，且分别属于VNI 5000和VNI 6000。A、B对应的三层网关分别是VTEP_3上的BDIF 10和BDIF 20的IP地址。VTEP_3上存在到两个网段的路由。</p>
<p>BDIF接口的功能与VLAN IF接口类似，是基于BD创建的三层逻辑接口，用以实现不同子网之间的通信，或vxlan网络与非vxlan网络之间的通信。</p>
<p>对于首次通信，类比与underlay网络中跨网段通信。A请求网关BDIF 10 MAC，然后将数据包发送给网关BDIF 10，BDIF 10将数据包路由至BDIF 20，BDIF 20请求B的MAC，然后将数据包发送给B。具体流程如下：</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_l3_arp.png"></p>
<p>数据报文转发流程如下：</p>
<ol>
<li>A将数据报文发送给网关。报文的源MAC是A MAC，目的MAC是网管BDIF 10的MAC；报文的源IP是A的IP，目的IP是B的IP</li>
<li>VTEP_1收到数据报文之后，识别报文所属的VNI，并根据MAC表项对报文进行封装<ol>
<li>外层源IP地址为本地VTEP的IP，外层目的IP地址为对端VTEP的IP</li>
<li>外层源MAC地址为本地VTEP的MAC地址，外层目的MAC地址为下一跳设备的IP地址</li>
<li>封装之后再underlay网络中传送至目的VTEP</li>
</ol>
</li>
<li>VTEP_3收到报文之后，对报文进行解封装。得到A发送的原始报文，VTEP_3会报文会做如下处理：<ol>
<li>VTEP_3发现该报文的目的MAC为本机BDIF 10接口的MAC，而目的IP为B的IP，所以会根据路由表查找B的下一跳</li>
<li>发现下一跳的出接口为BDIF 20。VETP_3查询ARP表项，将原始报文的源MAC修改为BDIF 20接口的MAC，将目的MAC修改为B的MAC</li>
<li>报文到BDIF 20后，识别需要进入vxlan隧道，所以根据MAC表对报文进行封装。<ol>
<li>外层源IP为本地VTEP的IP，外层目的IP地址为对端VTEP的IP</li>
<li>外层源MAC地址为本地VTEP的MAC，外层目的MAC为去往目的IP网络的下一跳设备的MAC地址</li>
<li>封装之后再underlay网络中传送至目的VTEP</li>
</ol>
</li>
</ol>
</li>
<li>VETP_2收到报文之后，对报文进行解封装，将overlay报文发送给B</li>
</ol>
<p>vxlan网络与非vxlan网络之间的互通，也需要借助三层网关，但是不同在于：报文在vxlan网络侧会进行封装，而在非vxlan网络侧不需要进行封装。报文从vxlan侧进入网关并解封后，就按照普通单播报文的发送方式进行转发。</p>
<h2 id="overlay网络的三种构建模式"><a href="#overlay网络的三种构建模式" class="headerlink" title="overlay网络的三种构建模式"></a>overlay网络的三种构建模式</h2><p>在数据中心，部分业务不适合进行虚拟化(如小机服务器，高性能数据库服务器),这些服务器会直接与物理交换机互联；对于服务器(虚拟机)，接入的可以是虚拟交换机(OpenvSwitch),也可以是物理交换机，因此存在如下图所示的三种接入模型。</p>
<p><img src="https://rancho333.gitee.io/pictures/vxlan_network_module_2.png"></p>
<p>以上，在network overlay方案中，所有终端均采用物理交换机作为VTEP节点；host overlay方案中，所有终端均采用虚拟交换机作为VTEP节点；hybird overlay方案中，既有物理交换机接入，又有虚拟交换机接入，且软件VTEP和硬件VTEP之间可以基于标准协议互通。</p>
<h2 id="vxlan与SDN"><a href="#vxlan与SDN" class="headerlink" title="vxlan与SDN"></a>vxlan与SDN</h2><p>vxlan只定义了转发平面的流程，对于控制平面还没有规范，一般采取三种方式：</p>
<ol>
<li>组播。由物理网络的组播协议形成组播表项，通过手工方式将不同的vxlan与组播组一一绑定。vxlan的报文通过绑定的组播组在组播对应的范围内进行泛洪</li>
<li>自定义协议。通过自定义的邻居发现协议学习overlay网络的拓扑结构并建立隧道管理机制，比如现在广泛应用的BGP-EVPN</li>
<li>SDN控制器。通过SDN控制器集中控制vxlan的转发，经由openflow协议下发表项是目前业界的主流方式</li>
</ol>
<h1 id="EVPN学习"><a href="#EVPN学习" class="headerlink" title="EVPN学习"></a>EVPN学习</h1><h2 id="EVPN的作用"><a href="#EVPN的作用" class="headerlink" title="EVPN的作用"></a>EVPN的作用</h2><p>最初的vxlan方案(RFC7348)中没有定义控制平面，是手工配置隧道，然后通过流量泛洪的方式进行主机地址的学习。这会导致网络中存在很多泛洪流量、网络扩展起来很难。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/02/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E4%B8%B2%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E4%B8%B2%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">树莓派做串口服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-02 10:32:51" itemprop="dateCreated datePublished" datetime="2021-02-02T10:32:51+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>交换机设备放在实验室中，部分位置只有网口而没有串口服务器，用PC做串口服务器太浪费，下面介绍用树莓派做串口服务器。</p>
<h1 id="拓扑说明"><a href="#拓扑说明" class="headerlink" title="拓扑说明"></a>拓扑说明</h1><p>通过SSh远程到树莓派上，树莓派通过USB转串口与交换机串口相连。Linux上通过minicom连接串口。</p>
<h1 id="Linux环境准备"><a href="#Linux环境准备" class="headerlink" title="Linux环境准备"></a>Linux环境准备</h1><h2 id="minicom安装"><a href="#minicom安装" class="headerlink" title="minicom安装"></a>minicom安装</h2><p>通过以下命令安装minicom。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install  lrzsz</span><br><span class="line">apt install minicom</span><br></pre></td></tr></table></figure>

<h2 id="串口参数设置"><a href="#串口参数设置" class="headerlink" title="串口参数设置"></a>串口参数设置</h2><p><code>minicom -s</code>进行参数设置。<br><img src="https://rancho333.gitee.io/pictures/minicom_s.png"></p>
<p>按如下参数进行设置.<br><img src="https://rancho333.gitee.io/pictures/serial_port.png"><br>可以在插拔usb转串口线在<code>/dev</code>查看串口设备。波特率以设备波特率为准。</p>
<p>设置完成后记得保存设置。</p>
<h2 id="设备登录"><a href="#设备登录" class="headerlink" title="设备登录"></a>设备登录</h2><p>在shell下输入<code>minicom</code>即可登录设备。<br>minicom的控制命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-A x        退出minicom</span><br><span class="line">Ctrl-A z        显示快捷键帮助信息</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/01/29/SONiC%E5%90%AF%E5%8A%A8%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/SONiC%E5%90%AF%E5%8A%A8%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">SONiC启动简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-29 10:28:18" itemprop="dateCreated datePublished" datetime="2021-01-29T10:28:18+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>sonic在初始化的时候是怎样识别platform的，<br>/host/machine.conf<br>/etc/sonic/config_db.json<br>/etc/rc.local</p>
<h2 id="platform相关"><a href="#platform相关" class="headerlink" title="platform相关"></a>platform相关</h2><p>在<code>device_info.py</code>中会通过读取<code>/host/machine.conf</code>配置文件来获取platform的名称</p>
<h2 id="hwsku相关"><a href="#hwsku相关" class="headerlink" title="hwsku相关"></a>hwsku相关</h2><p>在<code>device_info.py</code>中会通过读取ConfigDB来获取hwsku, 如果在<code>show version</code>中没有看到hwsku，那么需要配置config_db.json配置文件来加载配置信息，重启后生效。</p>
<h2 id="chassis相关"><a href="#chassis相关" class="headerlink" title="chassis相关"></a>chassis相关</h2><p>以pmon的docker的psud为例，先获取<code>platform_chassis</code>，对于chassis的初始化，关注platform_base.py、platform.py以及chassis.py这三个文件，其中chassis.py中完成chassis的实例化，一般包括syseeprom、watchdog、fan、thermal、psu、sfp、component。</p>
<p>chassis.py是厂商的sonic_platform包里面提供的文件，pmon的docker创建的时候会根据platform挂载对应的sonic_platform包，所以能保证加载正确的板子的外设。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/01/26/Systemd%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/26/Systemd%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Systemd学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-26 13:32:42" itemprop="dateCreated datePublished" datetime="2021-01-26T13:32:42+08:00">2021-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Systemd是现代Linux的服务启动管理。Linux的第一个进程已经由<code>init</code>变成<code>systemd</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[rancho sonic-buildimage]$ ps -ef | grep root | grep init</span><br><span class="line">root         1     0  0  2020 ?        00:19:51 &#x2F;sbin&#x2F;init splash</span><br><span class="line">[rancho sonic-buildimage]$ file &#x2F;sbin&#x2F;init</span><br><span class="line">&#x2F;sbin&#x2F;init: symbolic link to &#x2F;lib&#x2F;systemd&#x2F;systemd</span><br></pre></td></tr></table></figure>
<p>init的两个缺点:</p>
<ol>
<li>启动时间长。init是串行启动。</li>
<li>启动脚本复杂。init进程只是执行启动脚本，不管其它事情。所以脚本里面要处理各种情况，如依赖关系等，这使得脚本变得复杂且长。</li>
</ol>
<h1 id="Systemd概述"><a href="#Systemd概述" class="headerlink" title="Systemd概述"></a>Systemd概述</h1><p>Linux一直没有一个统一的管理平台，所以各种资料与学习都很零散，而且是一个分散的管理系统。Systemd是一个趋势，不然这么多发行版(Arch Linux、Debian系、Red Hat系)也不会去集成它了。</p>
<p>Systemd的设计目标是：为系统的启动和管理提供一套完整的解决方案。</p>
<p>Systemd的优点是功能强大，使用方便。缺点是体系庞大，非常复杂，与操作系统其它部分强耦合。<br><img src="https://rancho333.gitee.io/pictures/arch_of_systemd.png"></p>
<h1 id="Systemd命令族"><a href="#Systemd命令族" class="headerlink" title="Systemd命令族"></a>Systemd命令族</h1><p>Systemd是一组命令的集合，涉及到系统管理的各个方面。</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><code>systemctl</code>是Systemd的主命令，用于系统管理。systemctl接受服务（.service），挂载点（.mount）,套接口（.socket）和设备（.device）作为单元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">systemctl --version                 #查看systemd的版本</span><br><span class="line">systemctl reboot                    #重启系统</span><br><span class="line">systemctl poweroff                  #掉电</span><br><span class="line">systemctl halt                      #CPU停止工作</span><br><span class="line">systemctl suspend                   #暂停系统</span><br><span class="line"></span><br><span class="line">systemctl list-unit-files           #列出所有可用单元</span><br><span class="line">            [--type&#x3D;service]        #所有服务</span><br><span class="line">            [--type&#x3D;mount]          #所有系统挂载点</span><br><span class="line">            [--type&#x3D;socket]         #所有可用系统套接口</span><br><span class="line">systemctl list-units                #列出所有运行中的单元</span><br><span class="line">systemctl --failed                  #列出所有失败的单元</span><br><span class="line"></span><br><span class="line">systemctl status                    #显示系统状态</span><br><span class="line">            [XX.service]            #检查某个服务状态</span><br><span class="line">systemctl start XX.service          </span><br><span class="line">systemctl restart XX.service</span><br><span class="line">systemctl stop XX.service</span><br><span class="line">systemctl reload XX.service         #启动、重启、停止、重载服务</span><br><span class="line"></span><br><span class="line">systemctl is-active XX.service      #检查某个单元是否正在运行</span><br><span class="line">systemctl is-enabled XX.service     #检查某个单元是否启用</span><br><span class="line">systemctl is-failed XX.service      #检查某个单元是否启动失败</span><br><span class="line"></span><br><span class="line">systemctl enable XX.service         #在启动时启用服务</span><br><span class="line">systemctl disable XX.service        #在启动时禁止服务</span><br><span class="line">systemctl kill XX.service           #杀死服务</span><br><span class="line">systemctl show XX                   #检查某个服务的所有配置细节</span><br><span class="line"></span><br><span class="line">systemctl mask XX.service           #屏蔽服务</span><br><span class="line">systemctl unmask XX.service         #显示服务</span><br><span class="line"></span><br><span class="line">systemctl list-dependencies XX.service      #获取某个服务的依赖性列表</span><br><span class="line"></span><br><span class="line">systemctl get-default               #查看启动时的默认target</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload             # 重新加载配置文件</span><br><span class="line">systemctl restart foobar            # 重启相关服务</span><br></pre></td></tr></table></figure>

<h2 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h2><p>服务分析工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze                     #查看启动耗时</span><br><span class="line">systemd-analyze blame               #查看各个进程耗费时间</span><br><span class="line">systemd-analyze critical-chain      #分析启动时的关键链</span><br><span class="line">systemd-analyze critical-chain XX.service   #分析某个服务的关键链</span><br></pre></td></tr></table></figure>

<h2 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h2><p>systemd的有些命令功能会和某些命令重合，还有一些不常见的命令，如：hostnamectl、localectl、timedatectl、loginctl。</p>
<h1 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h1><p>Systemd可以管理所有的系统资源，不同的资源统称为unit(单元)。<br>unit一共分成12种.   </p>
<ul>
<li>service : 系统服务</li>
<li>target : 多个unit构成的一个组</li>
<li>device : 硬件设备</li>
<li>mount : 文件系统挂载点</li>
<li>automount : 自动挂载点</li>
<li>path ： 文件或路径</li>
<li>scope ： 不是由systemd启动的外部进程</li>
<li>slice ： 进程组</li>
<li>snapshot : systemd快照，可以切回某个快照</li>
<li>socket : 进程间通信的socket</li>
<li>swap : swap文件</li>
<li>timer : 定时器</li>
</ul>
<h2 id="unit配置文件"><a href="#unit配置文件" class="headerlink" title="unit配置文件"></a>unit配置文件</h2><p>每一个unit都有一个配置文件，告诉systemd怎么启动这个unit。<br>systemd默认从<code>/etc/systemd/system</code>读取配置文件。这里面部分文件是符号链接，指向<code>/lib/systemd/system</code>或者<code>/usr/lib/systemd/system</code>。</p>
<p><code>systemctl enable</code>的本质就是在上面两个目录的文件之间建立符号链接关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable XX.service</span><br><span class="line">等同于</span><br><span class="line">ln -s &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;XX.service &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;XX.service</span><br></pre></td></tr></table></figure>
<p><img src="https://rancho333.gitee.io/pictures/systemd_enable.png"></p>
<p>如果配置文件里面设置了开机启动，<code>systemctl enable</code>命令相当于激活开机启动。</p>
<p>配置文件的后缀名就是该unit的种类，systemd默认后缀名是<code>.service</code>，所以<code>bluetooth</code>等效于<code>bluetooth.service</code>。</p>
<p><code>systemctl list-unit-files</code>会显示每个unit的状态，一共有四种：</p>
<ul>
<li>enabled：已建立启动连接</li>
<li>disabled：未建立启动链接</li>
<li>static: 该配置文件没有[install]部分，无法执行，只能做为其它配置文件的依赖</li>
<li>masked：该配置文件被禁止建立启动链接</li>
</ul>
<h2 id="配置文件的格式"><a href="#配置文件的格式" class="headerlink" title="配置文件的格式"></a>配置文件的格式</h2><p>配置文件示例如下：<br><img src="https://rancho333.gitee.io/pictures/systemd_config_file.png"></p>
<p>配置文件分为Unit、Service、Install等区块，每个区块中都是key-value形式的配置。</p>
<p><code>[Unit]</code>是配置文件的第一个区块，用来定义Unit的元数据，以及配置与其他Unit的关系，主要字段如下：</p>
<ul>
<li>Description: 简短描述</li>
<li>Documentation: 文档地址</li>
<li>Requires: 当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li>
<li>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li>
<li>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li>
<li>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li>
<li>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li>
<li>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</li>
<li>Condition…：当前 Unit 运行必须满足的条件，否则不会运行</li>
<li>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败</li>
</ul>
<p><code>[Service]</code>区块用来Service配置，只有Service类型的Unit才会有这个区块，它的主要字段如下：</p>
<ul>
<li>Type：定义启动时的进程行为。它有以下几种值<ul>
<li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li>
<li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>
<li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>
<li>Type=dbus：当前服务通过D-Bus启动</li>
<li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li>
<li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li>
</ul>
</li>
<li>ExecStart：启动当前服务的命令</li>
<li>ExecStartPre：启动当前服务之前执行的命令</li>
<li>ExecStartPost：启动当前服务之后执行的命令</li>
<li>ExecReload：重启当前服务时执行的命令</li>
<li>ExecStop：停止当前服务时执行的命令</li>
<li>ExecStopPost：停止当其服务之后执行的命令</li>
<li>RestartSec：自动重启当前服务间隔的秒数</li>
<li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li>
<li>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</li>
<li>Environment：指定环境变量</li>
</ul>
<p><code>[Install]</code>通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动，它的主要字段如下：</p>
<ul>
<li>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li>
<li>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li>
<li>Alias：当前 Unit 可用于启动的别名</li>
<li>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li>
</ul>
<p>Unit配置文件的完整key-value清单，参见<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">官方文档</a>。</p>
<h1 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h1><p>计算机启动的时候，需要启动大量的Unit。如果每一次启动，都要一一写明本次启动需要那些Unit，显然非常不方便。Systemd的解决方案就是Target。</p>
<p>Target就是一个Unit组，包含许多相关的Unit。启动某个Target的时候，Systemd就会启动里面所有的Unit。从这个意义上说，Target这个概念类似于“状态点”，启动某个Target就好比启动到某种状态。</p>
<p>传统的Init启动模式中，有Runlevle的概念，和Target的作用很类似。不同的是，Runlevel是互斥的，但是多个Target是可以同时启动的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default           #查看启动时的默认 Target</span><br><span class="line">systemctl list-dependencies multi-user.target   #查看一个 Target 包含的所有 Unit</span><br></pre></td></tr></table></figure>

<p>它与Init的主要差别如下：</p>
<ol>
<li>默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li>
<li>启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</li>
<li>配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</li>
</ol>
<h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><p>Systemd统一管理Unit的启动日志，通过<code>journalctl</code>命令可以查看所有日志，日志的配置文件是<code>/etc/systemd/journald.conf</code>。它的功能很强大，用法也很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">journalctl                      # 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class="line"></span><br><span class="line">journalctl -k                   # 查看内核日志（不显示应用日志）</span><br><span class="line"></span><br><span class="line">journalctl -b                    # 查看系统本次启动的日志</span><br><span class="line">journalctl -b -0</span><br><span class="line"></span><br><span class="line"># 查看指定时间的日志</span><br><span class="line">journalctl --since&#x3D;&quot;2012-10-30 18:17:16&quot;</span><br><span class="line">journalctl --since &quot;20 min ago&quot;</span><br><span class="line">journalctl --since yesterday</span><br><span class="line">journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br><span class="line">journalctl --since 09:00 --until &quot;1 hour ago&quot;</span><br><span class="line"></span><br><span class="line">journalctl -n                   # 显示尾部的最新10行日志</span><br><span class="line">journalctl -n 20                # 显示尾部指定行数的日志</span><br><span class="line"></span><br><span class="line">journalctl -f                   # 实时滚动显示最新日志</span><br><span class="line"></span><br><span class="line">journalctl &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd    # 查看指定服务的日志</span><br><span class="line"></span><br><span class="line">journalctl _PID&#x3D;1               # 查看指定进程的日志</span><br><span class="line"></span><br><span class="line">journalctl &#x2F;usr&#x2F;bin&#x2F;bash        # 查看某个路径的脚本的日志</span><br><span class="line"></span><br><span class="line">journalctl _UID&#x3D;33 --since today    # 查看指定用户的日志</span><br><span class="line"></span><br><span class="line"># 查看某个 Unit 的日志</span><br><span class="line">journalctl -u nginx.service</span><br><span class="line">journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"># 查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class="line"># 0: emerg</span><br><span class="line"># 1: alert</span><br><span class="line"># 2: crit</span><br><span class="line"># 3: err</span><br><span class="line"># 4: warning</span><br><span class="line"># 5: notice</span><br><span class="line"># 6: info</span><br><span class="line"># 7: debug</span><br><span class="line">journalctl -p err -b</span><br><span class="line"></span><br><span class="line">journalctl --disk-usage                  # 显示日志占据的硬盘空间</span><br><span class="line"></span><br><span class="line">journalctl --vacuum-size&#x3D;1G            # 指定日志文件占据的最大空间</span><br><span class="line"></span><br><span class="line">journalctl --vacuum-time&#x3D;1years             # 指定日志文件保存多久</span><br></pre></td></tr></table></figure>

<h1 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h1><p>列举几个在systemd使用过程中可能遇到的问题。</p>
<h2 id="开机启动与启动服务"><a href="#开机启动与启动服务" class="headerlink" title="开机启动与启动服务"></a>开机启动与启动服务</h2><p><code>systemctl enable</code>设置服务开机启动，该服务需要等到下一次开机才会启动。<code>systemctl start</code>表明立即启动该服务。</p>
<h2 id="Unit区块中的启动顺序与依赖关系"><a href="#Unit区块中的启动顺序与依赖关系" class="headerlink" title="Unit区块中的启动顺序与依赖关系"></a>Unit区块中的启动顺序与依赖关系</h2><p>启动顺序由<code>Before</code>和<code>After</code>字段表示。Before表明应该在value表示的服务<em>之前</em>启动，After表示应该在value表示的服务<em>之后</em>启动。这两个字段只涉及到启动顺序而不设计依赖关系。</p>
<p>举例来说，SONiC中的bgp服务需要用redis数据库存储数据。如果在配置文件中只定义在redis之后启动，而没有定义依赖关系。设备启动后，由于某些原因，redis挂掉了，这之后bgp就会无法建立数据库连接。</p>
<p>设置依赖关系，需要使用<code>Wants</code>和<code>Requires</code>字段。Wants字段表明两者之间存在<em>弱依赖</em>关系，即如果value表明的服务启动失败或者停止运行，不影响主服务的继续执行。Requires字段则表明两者之间存在<em>强依赖</em>关系，即如果value表明的服务启动失败或者异常退出，那么主服务也必须退出。注意这两个字段只涉及依赖关系，与启动顺序无关，默认情况下不是同时启动的。</p>
<p>依赖于某一服务才能正常运行，可以同时定义Requires和After字段，如下所示。<br><img src="https://rancho333.gitee.io/pictures/requires_after.png"></p>
<h2 id="Services区块的小问题"><a href="#Services区块的小问题" class="headerlink" title="Services区块的小问题"></a>Services区块的小问题</h2><p>Services区块定义如何启动当前服务。</p>
<p>在所有的启动设置之前加上一个连词号(-),表示<em>抑制错误</em>，即错误发生的时候，不影响其它命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p>
<p><code>KillMode</code>字段定义了Systemd如何停止服务，value可以设置的值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</span><br><span class="line">process：只杀主进程</span><br><span class="line">mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</span><br><span class="line">none：没有进程会被杀掉，只是执行服务的 stop 命令。</span><br></pre></td></tr></table></figure>

<p><code>Restart</code>字段定义了服务退出后，systemd重启该服务的方式，value可以设置的值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">no（默认值）：退出后不会重启</span><br><span class="line">on-success：只有正常退出时（退出状态码为0），才会重启</span><br><span class="line">on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</span><br><span class="line">on-abnormal：只有被信号终止和超时，才会重启</span><br><span class="line">on-abort：只有在收到没有捕捉到的信号终止时，才会重启</span><br><span class="line">on-watchdog：超时退出，才会重启</span><br><span class="line">always：不管是什么退出原因，总是重启</span><br></pre></td></tr></table></figure>
<p>SONiC中很多服务Restart都设置为always，如swss服务。<code>RestartSec</code>字段表示systemd重启服务之前，需要等待的秒数。</p>
<h2 id="Install区块的小问题"><a href="#Install区块的小问题" class="headerlink" title="Install区块的小问题"></a>Install区块的小问题</h2><p>Install区块定义如何安装这个配置文件，即怎样做到开机启动。</p>
<p><code>WanteBy</code>字段表示该服务所在的Target。systemd默认启动的Target可以通过<code>systemctl get-default</code>查看到。服务必须加到这个Target或这个Target的子Target中才能开机启动。</p>
<p>常用的Target有两个，一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code>，SONiC使用的是后者。官方文档有一张非常清晰的<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup">Target依赖关系图</a></p>
<h2 id="Target的配置文件"><a href="#Target的配置文件" class="headerlink" title="Target的配置文件"></a>Target的配置文件</h2><p>在<code>/lib/systemd/system</code>下可以找到Target的配置文件,以<code>graphical.target</code>为例：<br><img src="https://rancho333.gitee.io/pictures/graphical_target.png"><br>其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Requires字段：要求basic.target一起运行。</span><br><span class="line">Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。</span><br><span class="line">After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。</span><br><span class="line">AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>一般而言，配置文件存放在<code>/lib/systemd/system</code>和<code>/usr/lib/systemd/system</code>目录下，通过<code>systemctl enable</code>在<code>/etc/systemd/system</code>创建符号链接指向前者，Systemd会执行etc下的文件，前提是文件中的Install配对了Target。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd入门教程：命令篇</a><br><a target="_blank" rel="noopener" href="https://linux.cn/article-5926-1.html">systemctl 命令完全指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/01/26/Linux%E5%8F%8C%E7%BD%91%E5%8D%A1%E8%AE%BE%E7%BD%AE-%E5%86%85%E5%A4%96%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/26/Linux%E5%8F%8C%E7%BD%91%E5%8D%A1%E8%AE%BE%E7%BD%AE-%E5%86%85%E5%A4%96%E7%BD%91/" class="post-title-link" itemprop="url">Linux双网卡设置-内外网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-26 10:39:15" itemprop="dateCreated datePublished" datetime="2021-01-26T10:39:15+08:00">2021-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>搞了一台树莓派4B来玩，想通过ssh来进行管理。由于公司网络管控，考虑通过内网（eth0）来进行ssh管理，通过外网(wlan0)进行上网。</p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>有线网和无线网都连接好后，通过DHCP获取ip，<code>ip route</code>状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default via 10.204.123.1 dev eth0 proto dhcp src 10.204.123.145 metric 202 </span><br><span class="line">default via 192.168.3.254 dev wlan0 proto dhcp src 192.168.3.38 metric 303 </span><br><span class="line">10.204.123.0&#x2F;24 dev eth0 proto dhcp scope link src 10.204.123.145 metric 202 </span><br><span class="line">192.168.0.0&#x2F;22 dev wlan0 proto dhcp scope link src 192.168.3.38 metric 303</span><br></pre></td></tr></table></figure>
<p>其中10.204.0.0/16网段是内网，设备没有通过认证，不能通过内网上外网。考虑通过该网段与自己的主机相连，其余网络连接走192.168网段。<br>先将默认路由删除，这里需要连接显示器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route del default</span><br></pre></td></tr></table></figure>
<p>因为有两条默认理由，该命令执行两次。</p>
<p>之后添加默认路由和默认网关，可以写到<code>/etc/rc.local</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#foreign net</span><br><span class="line">route add -net 0.0.0.0&#x2F;0 wlan0</span><br><span class="line">route add -net 0.0.0.0&#x2F;0 gw 192.168.3.254</span><br><span class="line"></span><br><span class="line">#local net</span><br><span class="line">route add -net 10.204.123.0&#x2F;16 eth0</span><br><span class="line">route add -net 10.204.123.0&#x2F;16 gw 10.204.123.1</span><br></pre></td></tr></table></figure>
<p>使能之后，<code>ip route</code>状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default via 10.204.123.1 dev eth0 proto dhcp src 10.204.123.145 metric 202 </span><br><span class="line">default via 192.168.3.254 dev wlan0 proto dhcp src 192.168.3.38 metric 303 </span><br><span class="line">10.204.0.0&#x2F;16 via 10.204.123.1 dev eth0 </span><br><span class="line">10.204.0.0&#x2F;16 dev eth0 scope link </span><br><span class="line">10.204.123.0&#x2F;24 dev eth0 proto dhcp scope link src 10.204.123.145 metric 202 </span><br><span class="line">192.168.0.0&#x2F;22 dev wlan0 proto dhcp scope link src 192.168.3.38 metric 303 </span><br></pre></td></tr></table></figure>
<p><code>route -n</code>状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.3.254   0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">10.204.0.0      10.204.123.1    255.255.0.0     UG    0      0        0 eth0</span><br><span class="line">10.204.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">10.204.123.0    0.0.0.0         255.255.255.0   U     202    0        0 eth0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.252.0   U     303    0        0 wlan0</span><br></pre></td></tr></table></figure>
<p>可以看到10.204网段走的是10.204.123.1网关，其余的网段走的都是外网192.168.3.254网关。</p>
<p>如果设备上使能了dhcpcd功能，则需要在获取到ip、路由之后手动配置路由。可以通过wlan0网络（外网）配置eth0（内网）的路由。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/01/19/broadcom-sdk-cmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/broadcom-sdk-cmd/" class="post-title-link" itemprop="url">broadcom_sdk_cmd</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-19 14:58:33" itemprop="dateCreated datePublished" datetime="2021-01-19T14:58:33+08:00">2021-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BCMShell简介"><a href="#BCMShell简介" class="headerlink" title="BCMShell简介"></a>BCMShell简介</h1><p>BCMShell是Broadcom公司对于ASIC的SDK命令解释器。利用该工具可以对ASIC所有的寄存器和内存进行读写操作，还可以利用脚本在ASIC上搭建各种复杂的网络环境。</p>
<h1 id="BCMShell的几种模式"><a href="#BCMShell的几种模式" class="headerlink" title="BCMShell的几种模式"></a>BCMShell的几种模式</h1><h2 id="BCMshell模式"><a href="#BCMshell模式" class="headerlink" title="BCMshell模式"></a>BCMshell模式</h2><p>拿到Broadcom源码后，根据OS上的kernel版本选择对应的内核头文件编译SDK，之后会得到几个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcm.user  bcm.user.dbg  linux-bcm-knet.ko  linux-kernel-bde.ko  linux-user-bde.ko  netserve</span><br></pre></td></tr></table></figure>
<p>参考SDK包运行环境中的<code>auto_load_user.sh</code>，安装对应驱动，启动<code>bcm.user</code>即可进入BCMShell命令行，提示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCM.0&gt; </span><br><span class="line">BCM.0&gt; exit</span><br></pre></td></tr></table></figure>
<p><code>exit</code>退回到shell。<br>如果OS是SONiC，执行<code>bcmsh</code>也可进入，通过<code>bcmcmd cmd</code>可以在shell下在BCMShell中执行命令。</p>
<h2 id="回退到shell模式"><a href="#回退到shell模式" class="headerlink" title="回退到shell模式"></a>回退到shell模式</h2><p>在BCMShell模式中通过命令<code>shell</code>可以进入shell里面执行命令，应该是将bcmshell放到后台运行，在shell中exit即可再次回到bcmshell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BCM.0&gt; </span><br><span class="line">BCM.0&gt; shell</span><br><span class="line">root@sonic:&#x2F;home&#x2F;admin&#x2F;R1241-M0150-01_V0.0.2_Questone2F_SDK# exit</span><br><span class="line">exit</span><br><span class="line">BCM.0&gt; exit</span><br><span class="line">root@sonic:&#x2F;home&#x2F;admin&#x2F;R1241-M0150-01_V0.0.2_Questone2F_SDK# </span><br></pre></td></tr></table></figure>

<h2 id="cint模式"><a href="#cint模式" class="headerlink" title="cint模式"></a>cint模式</h2><p>在BCMShell模式中通过命令<code>cint</code>可以进入到C interpreter模式，可以在里面执行C函数，如gearbox的一些操作可以在里面完成，<code>exit;</code>回退道bcmshell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BCM.0&gt; </span><br><span class="line">BCM.0&gt; cint</span><br><span class="line">Entering C Interpreter. Type &#39;exit;&#39; to quit.</span><br><span class="line"></span><br><span class="line">cint&gt; exit;</span><br><span class="line">BCM.0&gt; </span><br></pre></td></tr></table></figure>

<h1 id="BCMShell的一些特点"><a href="#BCMShell的一些特点" class="headerlink" title="BCMShell的一些特点"></a>BCMShell的一些特点</h1><ol>
<li>不区分大小写</li>
<li>支持缩写</li>
</ol>
<p><code>?</code>可以显示所有命令。以<code>PortStat</code>为例：PortStat和portstat等效，缩写规则是大写字母是可缩写项，PortStat可缩写为ps</p>
<h1 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h1><p>BCMShell命令可以分为五类：</p>
<ol>
<li>帮助命令</li>
<li>show命令</li>
<li>低级命令：对寄存器/RAM进行读写的命令</li>
<li>端口命令：与端口相关的命令</li>
<li>芯片MAC学习，通信协议相关的命令</li>
</ol>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>总共有五种帮助命令使用方法，使用一种即可<code>cmd + ?</code>，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BCM.0&gt; ps ?</span><br><span class="line">Usage (PortStat): Display info about port status in table format.</span><br><span class="line">    Link scan modes:</span><br><span class="line">        SW &#x3D; software</span><br><span class="line">        HW &#x3D; hardware</span><br><span class="line">    Learn operations (source lookup failure control):</span><br><span class="line">        F &#x3D; SLF packets are forwarded</span><br><span class="line">        C &#x3D; SLF packets are sent to the CPU</span><br><span class="line">        A &#x3D; SLF packets are learned in L2 table</span><br><span class="line">        D &#x3D; SLF packets are discarded.</span><br><span class="line">    Pause:</span><br><span class="line">        TX &#x3D; Switch will transmit pause packets</span><br><span class="line">        RX &#x3D; Switch will obey pause packets</span><br></pre></td></tr></table></figure>

<h2 id="show命令"><a href="#show命令" class="headerlink" title="show命令"></a>show命令</h2><p>常用show命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">show c                  查看ASIC各个端口收发包情况，可以加子命令过滤</span><br><span class="line">show ip                 查看ip报文统计计数</span><br><span class="line">show icmp               查看icmp报文统计计数</span><br><span class="line">show arp                查看arp报文统计计数</span><br><span class="line">show udp   </span><br><span class="line">show tcp</span><br><span class="line">show routes             查看子网路由表和主机路由表</span><br><span class="line"></span><br><span class="line">show unit               查看芯片信息</span><br><span class="line">show params             查看当前芯片驱动配置参数</span><br><span class="line">show features           查看当前芯片的特性</span><br></pre></td></tr></table></figure>

<h2 id="低级命令"><a href="#低级命令" class="headerlink" title="低级命令"></a>低级命令</h2><p>低级命令的作用主要是对寄存器和RAM进行读写。</p>
<h3 id="对寄存器进行读写"><a href="#对寄存器进行读写" class="headerlink" title="对寄存器进行读写"></a>对寄存器进行读写</h3><table>
<thead>
<tr>
<th align="left">寄存器类别</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PCIC</td>
<td align="left">PCI配置寄存器</td>
</tr>
<tr>
<td align="left">PCIM</td>
<td align="left">PCI内存映射寄存器</td>
</tr>
<tr>
<td align="left">SOC</td>
<td align="left">交换芯片寄存器与内存</td>
</tr>
<tr>
<td align="left">PHY</td>
<td align="left">PHY寄存器</td>
</tr>
</tbody></table>
<p>寄存器常用命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getreg          获取寄存器的值</span><br><span class="line">listreg         显示所支持的寄存器信息</span><br><span class="line">setreg          设置寄存器的值</span><br></pre></td></tr></table></figure>

<h3 id="对内存表进行读写"><a href="#对内存表进行读写" class="headerlink" title="对内存表进行读写"></a>对内存表进行读写</h3><p>内存表读操作： dump<br>内存表写操作： write</p>
<h2 id="端口命令"><a href="#端口命令" class="headerlink" title="端口命令"></a>端口命令</h2><p>端口命令主要是端口设置<code>PORT</code>命令和端口显示<code>PortStat</code>命令。举例如下：<br>设置xe0 loopback：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BCM.0&gt; port xe0 lb&#x3D;phy</span><br></pre></td></tr></table></figure>

<h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h2><p>高级命令可以对协议等复杂功能进行设置，如ACL，OAM等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l2 show                                             显示mac地址表</span><br><span class="line">l2 add port&#x3D;ge2 macaddress&#x3D;0x000000000001 vlan&#x3D;1   在ge2端口静态添加mac地址</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/01/05/%E5%85%B3%E4%BA%8E%E7%BB%88%E7%AB%AF%E5%9B%9E%E6%98%BE%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/%E5%85%B3%E4%BA%8E%E7%BB%88%E7%AB%AF%E5%9B%9E%E6%98%BE%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">关于终端回显的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-05 14:14:01" itemprop="dateCreated datePublished" datetime="2021-01-05T14:14:01+08:00">2021-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在嵌入式设备调试中，经常会使用console口对设备进行管理。使用vim进行文件编辑时，会发现屏幕回显有问题，例如，行显示不会逐步递增到屏幕底端，列显示时换行错乱。这是tty设置的<code>rows</code>与<code>cols</code>与实际的屏幕尺寸不适配。</p>
<h1 id="对于console连接"><a href="#对于console连接" class="headerlink" title="对于console连接"></a>对于console连接</h1><p>我们可以使用<code>stty -a</code>查看stty的所有配置信息，其中第一行包括波特率，终端的大小（以字符为基准）。也可以直接使用<code>stty size</code>查看终端的大小。</p>
<p><img src="https://rancho333.gitee.io/pictures/stty.png"></p>
<p>对于常见的远程登录软件，如<code>xshell</code>和<code>secure CRT</code>会在软件底端显示出当前终端的大小，我们按照这个数值进行设定即可。之后<code>reset</code>终端设置。如果显示依然不正常，最大化窗口然后再恢复即可。</p>
<h1 id="对于ssh或telent连接"><a href="#对于ssh或telent连接" class="headerlink" title="对于ssh或telent连接"></a>对于ssh或telent连接</h1><p>为什么使用ssh或者telnet连接时不会出现这种终端显示的问题呢，因为ssh当窗口大小发生变化后，会自动的调整stty的数值。可以尝试调整窗口大小，然后<code>stty size</code>查看终端大小与软件显示的窗口大小进行比较。</p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>Linux的TTY子系统其实是一个很复杂的点。其中包括的知识点有<code>行编辑</code>、<code>进程组</code>、<code>会话组</code>、<code>信号控制</code>、<code>流控制与I/O阻塞</code>、<code>TTY配置</code>等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2021/01/04/2021%E5%B9%B4%E5%A4%A9%E5%BC%98%E8%B7%91%E5%9B%A2%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/04/2021%E5%B9%B4%E5%A4%A9%E5%BC%98%E8%B7%91%E5%9B%A2%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">2021年天弘跑团数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-04 11:54:59" itemprop="dateCreated datePublished" datetime="2021-01-04T11:54:59+08:00">2021-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2021年天弘跑团数据统计</p>
<p>1月1号至1月3号</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">日期</th>
<th align="left">方式</th>
<th align="left">距离/km</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Leon</td>
<td align="left">1.1</td>
<td align="left">线上</td>
<td align="left">20.21</td>
</tr>
<tr>
<td align="left">Rancho</td>
<td align="left">1.1+1.2</td>
<td align="left">线上+线下</td>
<td align="left">20.21+10</td>
</tr>
<tr>
<td align="left">Gary</td>
<td align="left">1.1</td>
<td align="left">线上</td>
<td align="left">4.3</td>
</tr>
<tr>
<td align="left">Jason</td>
<td align="left">1.2</td>
<td align="left">线下</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">Ceecee+小朋友</td>
<td align="left">1.2</td>
<td align="left">线下</td>
<td align="left">5+5</td>
</tr>
<tr>
<td align="left">杨坤</td>
<td align="left">1.2</td>
<td align="left">线下</td>
<td align="left">15</td>
</tr>
<tr>
<td align="left">Lisa</td>
<td align="left">1.2</td>
<td align="left">线下</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Lewis+小朋友</td>
<td align="left">1.2</td>
<td align="left">线下</td>
<td align="left">10+5</td>
</tr>
<tr>
<td align="left">吴徐祥</td>
<td align="left">1.2</td>
<td align="left">线下</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left">energy</td>
<td align="left">1.2</td>
<td align="left">线上</td>
<td align="left">4.73</td>
</tr>
<tr>
<td align="left">xiang</td>
<td align="left">1.2</td>
<td align="left">线上</td>
<td align="left">8.25</td>
</tr>
</tbody></table>
<p>2月10号至18号春节跑步打卡数据统计</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">数据</th>
<th align="left">累计/km</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Lewis+小朋友</td>
<td align="left">5.03(10) + 7.68(13)</td>
<td align="left">12.71</td>
</tr>
<tr>
<td align="left">Rancho</td>
<td align="left">10.02(10) + 7.55(13) + 10.02(14) + 10.39(15) + 10.05(16) + 6.07(17) + 14.24(18)</td>
<td align="left">68.34</td>
</tr>
<tr>
<td align="left">Ceecee+小朋友</td>
<td align="left">7.55(13)</td>
<td align="left">7.55</td>
</tr>
<tr>
<td align="left">Xiang</td>
<td align="left">22.26(11) + 22.27(16)</td>
<td align="left">44.53</td>
</tr>
<tr>
<td align="left">Even</td>
<td align="left">8.88(12) + 13.14(14)</td>
<td align="left">22.02</td>
</tr>
<tr>
<td align="left">Leon</td>
<td align="left">8.88(12) + 12.21(13) + 13.14(14) + 15.21(15) + 14.91(17)</td>
<td align="left">64.35</td>
</tr>
<tr>
<td align="left">Jason</td>
<td align="left">9.01(10) + 4.87+7.68+5.16(13) + 9.85(15) + 9.02(17) + 6.06(18)</td>
<td align="left">51.65</td>
</tr>
<tr>
<td align="left">Linda</td>
<td align="left">7.05(13)</td>
<td align="left">7.05</td>
</tr>
<tr>
<td align="left">Jack XU</td>
<td align="left">3.03(14) + 3.03(16)</td>
<td align="left">6.06</td>
</tr>
<tr>
<td align="left">Vivian</td>
<td align="left">5.18(10) + 5.51(13) + 5.22(14) + 5.64(17) + 5.23(18)</td>
<td align="left">26.78</td>
</tr>
<tr>
<td align="left">ian.Yuan</td>
<td align="left">9.61(16) + 6.93(18)</td>
<td align="left">16.54</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/31/SONiC%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84device/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/31/SONiC%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84device/" class="post-title-link" itemprop="url">SONiC添加新的device</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-31 11:16:17" itemprop="dateCreated datePublished" datetime="2020-12-31T11:16:17+08:00">2020-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>SONiC项目中，有时候厂商需要添加自己新的device上去。</p>
<ol>
<li>需要添加那些东西？</li>
<li>怎么编译进文件系统？</li>
<li>SONiC启动时是如何选择对应设备的文件？</li>
</ol>
<p>搞清楚这三个问题后，我们就可以对device进行裁剪（SONiC默认会将device目录下所有文件拷贝进文件系统）。</p>
<h1 id="目录结构及添加内容"><a href="#目录结构及添加内容" class="headerlink" title="目录结构及添加内容"></a>目录结构及添加内容</h1><p>与设备硬件耦合的文件夹有两个，分别是<code>platform</code>与<code>device</code>，<code>platform</code>描述ASIC，厂商设备驱动代码以及new platform API的适配；<code>device</code>描述厂商设备代码，其中包括端口配置，led配置，sai配置等信息，<code>plugins</code>文件夹是一些外设命令适配的python代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sonic-buildimage&#x2F;</span><br><span class="line">    platform&#x2F;            # asic相关，重点关注sai以及sonic-platform.bin</span><br><span class="line">        broadcom&#x2F;        </span><br><span class="line">    device              # 设备相关，对设备硬件特性的控制描述，如端口，led，console；以及和硬件相关的命令的底层适配接口，如填入eeprom的地址，之后使用SONiC的解析器进行解析。对于SONiC的命令体系，可以再写一篇文档</span><br><span class="line">        celestica&#x2F;</span><br></pre></td></tr></table></figure>

<p>在<code>platform</code>中有个<code>sonic-platform</code>的文件夹，这里面包含了eeprom、fan、psu等外设相关的文件，与<code>device</code>里面的文件实际上是有重复的，这可能是SONiC的历史遗留问题，在字节项目中有讨论过后续会将外设相关的处理全部放到<code>platform</code>中去。</p>
<p>对于端口适配这些内容不熟悉，在此只做简单介绍。</p>
<h1 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h1><h2 id="device的编译"><a href="#device的编译" class="headerlink" title="device的编译"></a>device的编译</h2><p><code>device</code>中的数据会打包到<code>sonic-device-data_1.0-1_all.deb</code>, 具体是在<code>src/sonic-device-data/Makefile</code>实现文件拷贝然后打包成deb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$(addprefix $(DEST)&#x2F;, $(MAIN_TARGET)): $(DEST)&#x2F;% :                                       </span><br><span class="line">    pushd .&#x2F;src                     </span><br><span class="line">                                    </span><br><span class="line">    # Remove any stale data         </span><br><span class="line">    rm -rf .&#x2F;device                 </span><br><span class="line">                                    </span><br><span class="line">    # Create a new dir and copy all ONIE-platform-string-named dirs into it              </span><br><span class="line">    mkdir .&#x2F;device                  </span><br><span class="line">    cp -r -L ..&#x2F;..&#x2F;..&#x2F;device&#x2F;*&#x2F;* .&#x2F;device&#x2F;                                               </span><br><span class="line">                                    </span><br><span class="line">    # Create hwsku for virtual switch</span><br><span class="line">    for d in &#96;find -L ..&#x2F;..&#x2F;..&#x2F;device -maxdepth 3 -mindepth 3 -type d | grep -vE &quot;(plugins|led-code)&quot;&#96;; do \</span><br><span class="line">        cp -Lr $$d device&#x2F;x86_64-kvm_x86_64-r0&#x2F; ; \                                      </span><br><span class="line">        cp .&#x2F;sai.vs_profile device&#x2F;x86_64-kvm_x86_64-r0&#x2F;$$(basename $$d)&#x2F;sai.profile; \  </span><br><span class="line">        grep -v ^# device&#x2F;x86_64-kvm_x86_64-r0&#x2F;$$(basename $$d)&#x2F;port_config.ini | awk &#39;&#123;i&#x3D;i+1;print &quot;eth&quot;i&quot;:&quot;$$2&#125;&#39; &gt; device&#x2F;x86_64-kvm_x86_64-r0&#x2F;$$(basename $$d)&#x2F;lanemap.ini</span><br><span class="line">    done;                           </span><br><span class="line">                                    </span><br><span class="line">    # Build the package                                                                                                                                       </span><br><span class="line">    dpkg-buildpackage -rfakeroot -b -us -uc</span><br></pre></td></tr></table></figure>
<p>在<code>src/sonic-device-data/src/Makefile</code>中有config和media的测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    # Execute Broadcom config file test</span><br><span class="line">    pushd ..&#x2F;tests&#x2F;</span><br><span class="line">    for f in $$(find ..&#x2F;..&#x2F;..&#x2F;device -name &quot;*.config.bcm&quot;); do</span><br><span class="line">        .&#x2F;config_checker $$f</span><br><span class="line">    done</span><br><span class="line">    for f in $$(find ..&#x2F;..&#x2F;..&#x2F;device -name media_settings.json); do                                                                                           </span><br><span class="line">        .&#x2F;media_checker $$f</span><br><span class="line">    done</span><br><span class="line">    popd</span><br></pre></td></tr></table></figure>
<p>使用<code>dpkg -X target/debs/stretch/sonic-device-data_1.0-1_all.deb</code>或者在<code>fsroot/usr/share/sonic/device/</code>目录下可以发现<code>device</code>相关的文件。这些文件与设备目录上<code>/usr/share/sonic/device/</code>的文件相对应。<br>在<code>sonic_debian_extension.sh</code>脚本中会将其释放到根文件系统中去。<br><img src="https://rancho333.gitee.io/pictures/device_data.png"><br>注意，在slave.mk中操作一下才能看到脚本，否则它做为中间文件，编译完成后会被自动删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-       $(if $($*_DOCKERS),</span><br><span class="line">-               rm sonic_debian_extension.sh,</span><br><span class="line">-       )</span><br><span class="line">+#      $(if $($*_DOCKERS),</span><br><span class="line">+#              rm sonic_debian_extension.sh,</span><br><span class="line">+#      )</span><br><span class="line"> </span><br><span class="line">        chmod a+x $@</span><br><span class="line">        $(FOOTER)</span><br></pre></td></tr></table></figure>

<p>对于porting而言，可以修改Makefile中cmd的规则，只拷贝需要的device和只进行与之对应的test。</p>
<h2 id="platform的编译"><a href="#platform的编译" class="headerlink" title="platform的编译"></a>platform的编译</h2><p><code>slave.mk</code>是SONiC项目真正的Makefile，所有的编译规则在里面可以找到，<code>platform</code>的入口在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifneq ($(CONFIGURED_PLATFORM), undefined)</span><br><span class="line">include $(PLATFORM_PATH)&#x2F;rules.mk</span><br><span class="line">endif </span><br></pre></td></tr></table></figure>
<p>我们在执行<code>make configure PLATFORM=platform</code>时会指定platform，从而找到对应的rules.mk。</p>
<p><img src="https://rancho333.gitee.io/pictures/rules_mk.png"></p>
<p>这里面关注三个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sai.mk                          # 指定SAI版本以及下载路径</span><br><span class="line">platform-modules-device.mk      # 指定设备platform源文件路径，编译打包成debian</span><br><span class="line">one-image.mk                    # 指定SONiC系统安装镜像名称</span><br></pre></td></tr></table></figure>
<p>sai由ASIC厂商维护，作为设备厂商，我们直接使用即可。Makefile中通过指定url在编译时下载指定版本sai，对于此类重要的模块文件，可以将之缓存到本地，指定本地url进行使用。</p>
<p>对于设备厂商的platform，通过在<code>rules.mk</code>中增删 <em><strong>platform-modules-device.mk</strong></em> 可以实现在文件系统中添加或删除设备厂商platform的<code>device</code>模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;platform&#x2F;broadcom&#x2F;rules.mk b&#x2F;platform&#x2F;broadcom&#x2F;rules.mk</span><br><span class="line">index 8dd7b2c8..91e3afd3 100644</span><br><span class="line">--- a&#x2F;platform&#x2F;broadcom&#x2F;rules.mk</span><br><span class="line">+++ b&#x2F;platform&#x2F;broadcom&#x2F;rules.mk</span><br><span class="line">@@ -1,7 +1,7 @@</span><br><span class="line"> include $(PLATFORM_PATH)&#x2F;sai-modules.mk</span><br><span class="line"> include $(PLATFORM_PATH)&#x2F;sai.mk</span><br><span class="line">-include $(PLATFORM_PATH)&#x2F;platform-modules-dell.mk</span><br><span class="line">-include $(PLATFORM_PATH)&#x2F;platform-modules-arista.mk</span><br><span class="line">+#include $(PLATFORM_PATH)&#x2F;platform-modules-dell.mk</span><br><span class="line">+#include $(PLATFORM_PATH)&#x2F;platform-modules-arista.mk</span><br><span class="line"> include $(PLATFORM_PATH)&#x2F;platform-modules-ingrasys.mk</span><br></pre></td></tr></table></figure>

<p>通过在<code>one-image.mk</code>中增删<code>**_PLATFORM_MODULE</code>可以选择将在<code>platform-modules-device.mk</code>中编译好的对应机型的deb包拷贝到文件系统中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk b&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk</span><br><span class="line">index 8cbf7269..edc51460 100644</span><br><span class="line">--- a&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk</span><br><span class="line">+++ b&#x2F;platform&#x2F;broadcom&#x2F;one-image.mk</span><br><span class="line">@@ -54,8 +54,8 @@ $(SONIC_ONE_IMAGE)_LAZY_INSTALLS +&#x3D; $(DELL_S6000_PLATFORM_MODULE) \</span><br><span class="line">                                $(ALPHANETWORKS_SNH60B0_640F_PLATFORM_MODULE) \</span><br><span class="line">                                $(BRCM_XLR_GTS_PLATFORM_MODULE) \</span><br><span class="line">                                $(DELTA_AG9032V2A_PLATFORM_MODULE) \</span><br><span class="line">-                               $(JUNIPER_QFX5210_PLATFORM_MODULE) \</span><br><span class="line">-                               $(CEL_SILVERSTONE_PLATFORM_MODULE)</span><br><span class="line">+                               #$(JUNIPER_QFX5210_PLATFORM_MODULE) \</span><br><span class="line">+                               #$(CEL_SILVERSTONE_PLATFORM_MODULE)</span><br></pre></td></tr></table></figure>

<p>对于打包好的platform文件，会在<code>sonic_debian_extension.sh</code>中拷贝到文件系统中去<br><img src="https://rancho333.gitee.io/pictures/platform_module.png"></p>
<p>上面这张图片上就是裁剪过后只会拷贝<code>cel-b3010</code>这一款机型的platform。有兴趣的同学可以研究下是如何实现的。</p>
<p>在SONiC的安装镜像第一次启动时，会在<code>rc.local</code>中将其释放到文件系统中去.<br><img src="https://rancho333.gitee.io/pictures/platform_module_2.png"></p>
<p>对于<code>platform-modules-*_amd64.deb</code>，里面包含了device的驱动，会在systemd中添加服务完成驱动的加载。这个deb的生成规则参见<code>platform/broadcom/sonic-platform-modules-cel/debian/</code>，主要修改如下几个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rules</span><br><span class="line">control</span><br></pre></td></tr></table></figure>
<p>以及添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platform-modules-ivystone.init</span><br><span class="line">platform-modules-ivystone.install</span><br><span class="line">platform-modules-ivystone.postinst</span><br></pre></td></tr></table></figure>

<p>注意编译<code>platform-modules-*_amd64.deb</code>的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CEL_DX010_PLATFORM_MODULE &#x3D; platform-modules-dx010_$(CEL_DX010_PLATFORM_MODULE_VERSION)_amd64.deb</span><br><span class="line">$(CEL_DX010_PLATFORM_MODULE)_SRC_PATH &#x3D; $(PLATFORM_PATH)&#x2F;sonic-platform-modules-cel</span><br><span class="line">$(CEL_DX010_PLATFORM_MODULE)_DEPENDS +&#x3D; $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)</span><br><span class="line">$(CEL_DX010_PLATFORM_MODULE)_PLATFORM &#x3D; x86_64-cel_seastone-r0</span><br><span class="line">SONIC_DPKG_DEBS +&#x3D; $(CEL_DX010_PLATFORM_MODULE)</span><br><span class="line">           </span><br><span class="line">CEL_HALIBURTON_PLATFORM_MODULE &#x3D; platform-modules-haliburton_$(CEL_HALIBURTON_PLATFORM_MODULE_VERSION)_amd64.deb</span><br><span class="line">$(CEL_HALIBURTON_PLATFORM_MODULE)_PLATFORM &#x3D; x86_64-cel_e1031-r0</span><br><span class="line">$(eval $(call add_extra_package,$(CEL_DX010_PLATFORM_MODULE),$(CEL_HALIBURTON_PLATFORM_MODULE)))</span><br></pre></td></tr></table></figure>
<p>在slave.mk中会有编译SONIC_DPKG_DEBS的命令，只有CEL_DX010_PLATFORM_MODULE是显示的添加到SONIC_DPKG_DEBS</p>
<h1 id="SONiC启动简述"><a href="#SONiC启动简述" class="headerlink" title="SONiC启动简述"></a>SONiC启动简述</h1><p>对于从onie下面安装SONiC，在onie下面会维护一个<code>machine.conf</code>文件，这里面有设备的详细信息，之后SONiC会根据这里的信息完成初始化的文件加载流程。</p>
<p>对于从SONiC下面直接安装SONiC，修改grub，暂不做深入研究。</p>
<p>对于systemd的初始化，SDK的初始化，platform/chassis的初始化，后续有需要在继续研究。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://rancho333.gitee.io/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/pictures/Rancho.png">
      <meta itemprop="name" content="Rancho">
      <meta itemprop="description" content="No pain, no gain!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rancho Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/ARP%E5%8D%8F%E8%AE%AE%E7%AE%80%E8%BF%B0%E5%8F%8A%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">ARP协议简述及应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-25 13:22:08" itemprop="dateCreated datePublished" datetime="2020-12-25T13:22:08+08:00">2020-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-07 12:06:49" itemprop="dateModified" datetime="2021-04-07T12:06:49+08:00">2021-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这篇文章分为两个部分ARP协议简介以及ARP协议的实际应用。</p>
<h1 id="ARP协议简介"><a href="#ARP协议简介" class="headerlink" title="ARP协议简介"></a>ARP协议简介</h1><h2 id="ARP的作用"><a href="#ARP的作用" class="headerlink" title="ARP的作用"></a>ARP的作用</h2><p>ARP(Address Resolution Protocol，地址解析协议)是将IP地址解析为以太网MAC地址的协议。与之相对的，将MAC地址解析为IP地址的协议称为RARP。</p>
<p>在局域网中，当终端设备需要将数据发送给另一个终端设备时，它必须知道对方网络的IP地址。但是仅仅有IP地址是不够的，因为IP数据必须封装成帧才能通过物理网络发送，因此发送端还必须有接收端的MAC地址，所以需要一个从IP地址到物理地址的映射。ARP就是实现这个功能的协议。</p>
<h2 id="ARP报文的结构"><a href="#ARP报文的结构" class="headerlink" title="ARP报文的结构"></a>ARP报文的结构</h2><p><img src="https://rancho333.gitee.io/pictures/arp_protocol.png"> </p>
<p>对于各个字段的解释如下</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">长度（bit）</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ethernet Address of destination</td>
<td align="left">48</td>
<td align="left">目的以太网地址。发送ARP请求时，为广播MAC地址，0xFF.FF.FF.FF.FF.FF</td>
</tr>
<tr>
<td align="left">Ethernet Address of sneder</td>
<td align="left">48</td>
<td align="left">源以太网地址</td>
</tr>
<tr>
<td align="left">Frame Type</td>
<td align="left">16</td>
<td align="left">表示报文类型。对于ARP请求或应答，该字段为0x0806</td>
</tr>
<tr>
<td align="left">Hardware Type</td>
<td align="left">16</td>
<td align="left">表示硬件地址的类型。对于以太网，该字段为1</td>
</tr>
<tr>
<td align="left">Protocol Type</td>
<td align="left">16</td>
<td align="left">表示发送方要映射的协议地址类型。对于IP地址，该值为0x0800</td>
</tr>
<tr>
<td align="left">Hardware Length</td>
<td align="left">8</td>
<td align="left">表示硬件地址的长度，单位是字节。对于ARP请求或应答来说，该值为6</td>
</tr>
<tr>
<td align="left">Protocol Length</td>
<td align="left">8</td>
<td align="left">表示协议地址的长度，单位是字节。对于ARP请求或应答来说，该值为4</td>
</tr>
<tr>
<td align="left">OP</td>
<td align="left">16</td>
<td align="left">表示操作类型。1 表示ARP请求，2 表示ARP应答，3表示RARP请求，4表示RARP应答</td>
</tr>
<tr>
<td align="left">Ethernet Address of sneder</td>
<td align="left">48</td>
<td align="left">发送方以太网地址。这个字段和ARP报文首部的源以太网地址字段是重复信息</td>
</tr>
<tr>
<td align="left">IP Address of sender</td>
<td align="left">32</td>
<td align="left">发送方IP地址</td>
</tr>
<tr>
<td align="left">Ethernet Address of destination</td>
<td align="left">48</td>
<td align="left">接收方以太网地址，发送ARP请求时，该处填充全0</td>
</tr>
<tr>
<td align="left">IP Address of destination</td>
<td align="left">32</td>
<td align="left">接收方IP地址</td>
</tr>
</tbody></table>
<p>在Linux上可以通过tcpdump工具抓取ARP包</p>
<p><img src="https://rancho333.gitee.io/pictures/arp_data_raw.png"><br>使用wireshark工具可以更为方便的查看报文中的各个字段：</p>
<p><img src="https://rancho333.gitee.io/pictures/arp_data.png"> </p>
<h2 id="ARP地址解析过程"><a href="#ARP地址解析过程" class="headerlink" title="ARP地址解析过程"></a>ARP地址解析过程</h2><p>假设主机A和B在同一个网段，主机A要向主机B发送信息，解析过程如下：</p>
<ul>
<li>主机A查看自己的ARP表，找到则直接使用</li>
<li>如果A在ARP表中没有找到B，则<ul>
<li>缓存IP数据报文</li>
<li>发送ARP请求报文，请求B的MAC地址</li>
</ul>
</li>
<li>主机B比较自己的IP地址与ARP请求报文中的IP地址，两者相同则：<ul>
<li>将A的IP与MAC地址缓存到自己的ARP表中</li>
<li>单播发送ARP应答报文给主机A，其中包含自己的MAC地址</li>
</ul>
</li>
<li>主机A收到ARP响应后，缓存B的MAC到ARP表中，之后发送IP数据报文</li>
</ul>
<p>当主机A和B不在同一网段时，主机A会向网关发送ARP请求。如果网关有主机B的ARP表项，则直接应答A；否则网关广播ARP请求，目标IP地址为主机B的IP地址，网关收到响应报文之后再应答B。</p>
<h2 id="ARP表"><a href="#ARP表" class="headerlink" title="ARP表"></a>ARP表</h2><p>ARP表分为动态ARP表和静态ARP表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">10.204.113.138           ether   00:00:00:00:00:01   C                     ens160</span><br><span class="line">10.204.113.151                   (incomplete)                              ens160</span><br><span class="line">172.17.0.7               ether   02:42:ac:11:00:07   C                     docker0</span><br><span class="line">10.204.112.11            ether   00:e0:ec:47:33:1a   C                     ens160</span><br><span class="line">openbmc-develop.asia.ad  ether   00:e0:4c:06:00:95   C                     ens160</span><br><span class="line">10.204.112.44            ether   6c:b3:11:32:7f:12   C                     ens160</span><br><span class="line">172.17.0.2               ether   02:42:ac:11:00:02   C                     docker0</span><br><span class="line">sonic.asia.ad.celestica  ether   aa:ad:40:03:ba:19   C                     ens160</span><br></pre></td></tr></table></figure>

<h3 id="动态ARP表"><a href="#动态ARP表" class="headerlink" title="动态ARP表"></a>动态ARP表</h3><p>动态ARP表由ARP协议通过ARP报文自动生成与维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。当到达老化时间、接口down时会删除相应的动态ARP表项。</p>
<h3 id="静态ARP表项"><a href="#静态ARP表项" class="headerlink" title="静态ARP表项"></a>静态ARP表项</h3><p>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖。</p>
<p>配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，<br>从而保护了本设备和指定设备间的正常通信。</p>
<p>静态ARP表项分为短静态ARP表项和长静态ARP表项。</p>
<ul>
<li>长静态ARP表项必须配置IP地址、MAC地址、所在VLAN和出接口。长静态ARP表项可直接用于报文转发。</li>
<li>短静态ARP表项只需要配置IP地址和MAC地址。<ul>
<li>如果出接口是三层口，直接用于报文转发</li>
<li>如果出接口是VLAN虚接口，短静态ARP表项不能直接用于报文转发，当要发送IP数据包时，先发送ARP请求报文，如果收到的response中的<br>源IP和源MAC与所配置的相同，则将收到response的接口加入该静态ARP中，之后用于IP数据包转发。</li>
</ul>
</li>
</ul>
<p>当希望设备和指定用户只能使用某个固定的IP地址和MAC地址通信时，可以配置短静态ARP表项，当进一步希望这个用户只在某个VLAN内的某个特定接口上连接时就可以配置长静态ARP表项</p>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>免费ARP是一种特殊的ARP报文，该报文中携带的发送端与目的端IP都是本机IP，发送端MAC时本机MAC，接收端MAC是全f。其本质是keep alive保活/心跳报文的应用。<br>免费ARP报文有以下功能:</p>
<ul>
<li>IP地址冲突检测。如果有冲突，冲突设备会给本机发送一个ARP应答，告知IP地址冲突</li>
<li>设备改变MAC地址，发送免费ARP更新其它设备中的ARP表项</li>
</ul>
<p>定时发送免费ARP的应用场景：</p>
<ul>
<li>防止仿冒网关的ARP攻击（ARP欺骗）<ul>
<li>如果攻击者仿冒网关发送免费ARP报文，可以将原本发送到网关的流量重定向到一个错误的MAC地址，导致用户无法正常访问网络。网关接口上使能免费ARP功能后，主机可以学习到正确的网关。</li>
</ul>
</li>
<li>防止ARP表项老化</li>
<li>防止VRRP虚拟IP地址冲突</li>
<li>及时更新模糊终结VLAN内设备的MAC地址表</li>
</ul>
<h1 id="ARP协议应用"><a href="#ARP协议应用" class="headerlink" title="ARP协议应用"></a>ARP协议应用</h1><p>ARP协议的状态机比较简单，但是应用起来是比较有意思的，一些基础网络问题也是值得思考的。</p>
<h2 id="二层通信与三层通信中ARP的应用"><a href="#二层通信与三层通信中ARP的应用" class="headerlink" title="二层通信与三层通信中ARP的应用"></a>二层通信与三层通信中ARP的应用</h2><p>二三层设备互通中arp是怎样工作的？</p>
<p><img src="https://rancho333.gitee.io/pictures/ping_arp.png"><br>如图所示，两个vlan通过interface vlan路由接口实现互通。下文说明中，交换机和终端设备均为初始状态，不含有arp表项。</p>
<h3 id="A和B之间的互通-二层"><a href="#A和B之间的互通-二层" class="headerlink" title="A和B之间的互通(二层)"></a>A和B之间的互通(二层)</h3><p>以A向B发起ping请求为例。</p>
<ol>
<li>A检查报文的目的IP地址发现和自己在同一个网段；</li>
<li>A—-&gt;B ARP请求报文，该报文在VLAN1内广播<ol>
<li>报文的dst mac是广播mac，src mac是A mac</li>
<li>报文的sender MAC是A mac, sender ip是A ip; target mac是全0，target ip是B ip</li>
</ol>
</li>
<li>B—-&gt;A  ARP回应报文<ol>
<li>报文的dst mac是A mac, src mac是B mac</li>
<li>报文的sender MAC是B mac(A请求的mac), sender ip是B ip; target mac是A mac，taaget ip是A ip</li>
</ol>
</li>
<li>A—-&gt;B  icmp request</li>
<li>B—-&gt;A  icmp reply</li>
</ol>
<h3 id="A和C之间的互通-三层"><a href="#A和C之间的互通-三层" class="headerlink" title="A和C之间的互通(三层)"></a>A和C之间的互通(三层)</h3><p>以A向C发起ping请求为例。</p>
<ol>
<li>A检查报文的目的IP地址，发现和自己不在同一个网段</li>
<li>A—-&gt;switch(int vlan 1) ARP请求报文，该报文在vlan1内广播<ol>
<li>报文的dst mac是广播mac，src mac是A mac</li>
<li>报文的sender MAC是A mac, sender ip是A ip; target mac是全0，target ip是int vlan 1 ip</li>
</ol>
</li>
<li>网关—-&gt; A ARP回应报文<ol>
<li>报文的dst mac是A mac, src mac是int vlan 1 mac</li>
<li>报文的sender MAC是int vlan 1 mac(A请求的mac), sender ip是int vlan 1 ip; target mac是A mac，taaget ip是A ip</li>
</ol>
</li>
<li>A—-&gt;switch icmp request<ol>
<li>报文dst mac是int vlan 1的mac，src mac是A的mac; dst ip是C ip，src ip是A ip</li>
</ol>
</li>
<li>switch收到报文后判断出是三层报文，检查报文的目的IP地址，发现是在自己的直连网段</li>
<li>switch(int vlan 2)—-&gt;C ARP请求报文，该报文在vlan2内广播</li>
<li>C—-&gt;switch(int vlan 2) ARP回应报文</li>
<li>switch(int vlan 2)—-&gt;C icmp request<ol>
<li>报文的dst mac是C的mac, src mac是int vlan 2的mac; dst ip是C ip, src ip是A ip</li>
</ol>
</li>
<li>C—-&gt;A icmp reply, 这以后的处理同前面icmp request的过程基本相同。</li>
</ol>
<p>对报文路由，会对报文的MAC头进行重新封装，而IP层以上的字段基本不变。通过说明报文dst/src MAC的变化，注意ARP在二三层通信中起的作用。后续设备中ARP表有了相应的条目之后，则不会给对方发送ARP请求报文。</p>
<h2 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h2><p>如果ARP请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理ARP功能的设备就可以回答该请求，这个过程称作代理ARP（Proxy ARP）<br>代理ARP功能屏蔽分离的物理网络这一事实，使用户使用起来，好像在同一物理网络上。<br>代理ARP分为普通代理ARP和本地代理ARP，二者的应用场景有所区别。</p>
<ul>
<li>普通代理ARP的应用场景：想要互通的主机分别连接到设备的不同的三层接口上，且这些主机不在同一个广播域中</li>
<li>本地代理ARP的应用环境为：想要互通的主机连接到设备的同一个三层接口在，且这些主机不在同一个广播域中</li>
</ul>
<h3 id="普通代理ARP"><a href="#普通代理ARP" class="headerlink" title="普通代理ARP"></a>普通代理ARP</h3><p>处于同一网段内的主机，当连接到设备的不同三层接口时，可以利用设备的代理ARP功能，通过三层转发实现互通。<br>拓扑如下图所示。设备Router通过两个三层接口Eth1/1和Eth1/2连接两个网络，两个三层接口的IP地址不在同一个网段，但是两个网络内的主机Host A和Host B的地址通过掩码的控制，既与相连设备的接口地址在同一网段，同时二者也处于同一个网段。<br><img src="https://rancho333.gitee.io/pictures/general_arp_agent.png"><br>这种组网场景下，当Host A需要与Host B通信时，由于dst ip与src ip在同一网段，因此Host A会直接对Host B进行ARP请求。但是，两台主机不在同一个广播域中，Host B无法收到Host A的ARP请求报文，当然也就无法应答。<br>通过在Router上启用代理ARP功能，可以解决此问题。启用代理ARP后,Router可以应答Host A的ARP请求。同时，Router相当于Host B的代理，把从其它主机发送过来的报文转发给它。<br>代理ARP的优点是，它可以只被应用在一个设备上（此时设备的作用相当于网关），不会影响到网络中其它设备的路由表。代理ARP功能可以在IP主机没有配置缺省网关或者IP主机没有任何路由能力的情况下使用。</p>
<h3 id="本地代理ARP"><a href="#本地代理ARP" class="headerlink" title="本地代理ARP"></a>本地代理ARP</h3><p>拓扑如图所示。Host A与Host B属于同一个VLAN 2,但他们分别连接到被二层隔离的端口Eth1/3和Eth1/1上，通过在Router上启用本地代理ARP功能，可以实现Host A和Host B的三层互通。<br><img src="https://rancho333.gitee.io/pictures/local_arp_agent.png"></p>
<p>本地代理ARP可以在下列三种情况下实现主机之间的三层互通：</p>
<ul>
<li>想要互通的主机分别连接到同一个VLAN中的不同的二层隔离端口下</li>
<li>使能Super VLAN功能后，想要互通的主机属于不同的Sub VLAN</li>
<li>使能Lsolate-user-vlan功能后，想要互通的主机属于不同的Secondary VLAN</li>
</ul>
<h2 id="ARP-Snooping"><a href="#ARP-Snooping" class="headerlink" title="ARP Snooping"></a>ARP Snooping</h2><p>ARP snooping功能是一个用于二层交换网络环境的特性，通过侦听ARP报文建立ARP Snooping表项，从而提供给ARP快速应答和MFF手动方式等使用。<br>设备上的一个VLAN使能ARP Snooping后，该VLAN内所有端口接收的ARP报文会被重定向到CPu。CPU对重定向上送的ARP报文进行分析，获取ARP报文的src ip, src mac, src vlan和入端口信息，建立记录用户信息的ARP Snooping表项。</p>
<h2 id="ARP快速应答"><a href="#ARP快速应答" class="headerlink" title="ARP快速应答"></a>ARP快速应答</h2><p>在无线产品组网中，AC与AP会建立隧道连接，Client通过AP连接到AC，通过AC，client可以与网关建立连接。当Client发起ARP广播请求时，需要通过AC向所有的AP复制ARP请求，这样会导致ARP广播占用隧道的大量资源，导致性能下降。为了减少ARP广播占用的隧道资源，可以在AC上启用ARP快速应答功能，减少ARP广播报文的影响。</p>
<p>ARP快速应答功能就是根据AC设备收集的用户信息（DHCP Snooping表项或者ARP Snooping表项），在指定的VLAN内，尽可能的对ARP请求进行应答，从而减少ARP广播报文。</p>
<h3 id="ARP快速应答工作机制"><a href="#ARP快速应答工作机制" class="headerlink" title="ARP快速应答工作机制"></a>ARP快速应答工作机制</h3><p>ARP快速应答的工作机制如下：</p>
<ol>
<li>设备接收到ARP请求报文时，如果请求报文的目的IP地址是设备的VLAN虚接口的IP地址，则由ARP特性进行处理</li>
<li>如果不是，则根据报文中的目的IP地址查找DHCP Snooping表项<ol>
<li>如果查找成功，但是查找到的表项的接口和收到请求报文的接口一致，并且接口是以太网接口，则不进行应答，否则立即进行应答</li>
<li>如果查找失败，则继续查找ARP Snooping表项。如果查找成功，但是查找到的表项的接口和收到请求报文的接口一致，并且接口是以太网接口，则不进行应答，否则立即进行应答。</li>
<li>如果两个表项均查找失败，则直接转发请求报文或将报文交于其它特性处理。</li>
</ol>
</li>
</ol>
<h2 id="ARP防御攻击"><a href="#ARP防御攻击" class="headerlink" title="ARP防御攻击"></a>ARP防御攻击</h2><p>ARP协议有简单、易用的优点，但是也因为没有任何安全机制而容易被攻击发起者利用。</p>
<ul>
<li>攻击者可以仿冒用户、仿冒网关发送伪造的ARP报文，使网关或主机的ARP表项不正确，从而对网络进行攻击</li>
<li>攻击者通过向设备发送大量目标IP地址不能解析的IP报文，使得设备试图反复地对目标IP地址进行解析，导致CPU负荷过重及网络流量过大</li>
<li>攻击者向设备发送大量的ARP报文，对设备的CPU形成冲击。<br>目前ARP攻击和ARP病毒已经成为局域网安全的一大威胁。下面简单说明一下ARP攻防原理。</li>
</ul>
<h3 id="ARP防止IP报文攻击功能简介"><a href="#ARP防止IP报文攻击功能简介" class="headerlink" title="ARP防止IP报文攻击功能简介"></a>ARP防止IP报文攻击功能简介</h3><p>如果网络中有主机通过向设备发送大量目标IP地址不能解析的IP报文来攻击设备，则会造成下面的危害：</p>
<ul>
<li>设备向目的网段发送大量的ARP请求报文，加重目的网段的负载</li>
<li>设备会试图反复地对目标IP地址进行解析，增加了CPU的负担</li>
</ul>
<p>为了避免这种IP报文攻击所带来的危害，设备提供了下列两个功能：</p>
<ul>
<li>如果发送攻击报文的源是固定的，可以采用ARP源抑制功能。开启该功能后，如果网络中某主机向设备某端口连续发送目标IP地址不能解析的IP报文，当每5秒内此主机发出IP报文出发ARP请求报文的流量超过设置的阈值，那么对于由此主机发出的IP报文，设备不允许其触发ARP请求，直至5秒后再处理，从而避免了恶意攻击所造成的危害。</li>
<li>如果发送攻击报文的源不固定，设备立即产生一个黑洞路由，使得设备在一段时间内将去往该地址的报文直接丢弃。等待黑洞路由老化时间过后，如有报文触发则再次发起解析，如果解析成功则进行转发，否则仍然产生一个黑洞路由将去往改地址的报文丢弃。这种方式能够有效的防止IP报文的攻击，减轻CPU的负担。</li>
</ul>
<h3 id="ARP报文限速功能"><a href="#ARP报文限速功能" class="headerlink" title="ARP报文限速功能"></a>ARP报文限速功能</h3><p>ARP报文限速功能是指对上送CPU的ARP报文进行限速，可以防止大量ARP报文对CPU进行冲击。例如，在配置了ARP Detection功能后，设备会将收到的ARP报文重定向到CPU进行检查，这样会引入新的问题：如果攻击者恶意构造大量ARP报文发往设备，会导致设备的CPU负担过重，从而造成其它功能无法正常运行甚至设备瘫痪，这个时候可以启用ARP报文限速功能来控制上送CPU的ARP报文的速率。</p>
<p>推荐用户在配置了ARP Detection、ARP Snooping、ARP快速应答、MFF，或者发现有ARP泛洪攻击的情况下，使用ARP报文限速功能。</p>
<h3 id="源MAC地址固定的ARP攻击检测功能"><a href="#源MAC地址固定的ARP攻击检测功能" class="headerlink" title="源MAC地址固定的ARP攻击检测功能"></a>源MAC地址固定的ARP攻击检测功能</h3><p>本特性根据ARP报文的源MAC地址进行统计，在5秒内，如果收到同一源MAC地址的ARP报文超过一定的阈值，则认为存在攻击，系统会将此MAC地址添加到攻击检测表项中。在该攻击检测表项老化之前，如果设置的检查模式为过滤模式，则会打印告警信息并将该源MAC地址发送的ARP报文过滤掉。如果设置为监控模式，则只打印告警信息，不会将源MAC地址发送的ARP报文过滤掉。<br>对于网关或一些重要的服务器，可能会发送大量的ARP报文，为了使这些ARP报文不被过滤掉，可以将这类设备的MAC地址配置成保护MAC，这样，即使该MAC存在攻击也不会被检测过滤。只对上送CPU的ARP报文进行统计。</p>
<h3 id="ARP报文源MAC一致性检查功能简介"><a href="#ARP报文源MAC一致性检查功能简介" class="headerlink" title="ARP报文源MAC一致性检查功能简介"></a>ARP报文源MAC一致性检查功能简介</h3><p>ARP报文源MAC一致性检查功能主要应用于网关设备上，防御以太网数据帧首部中的源MAC地址和ARP报文中sender mac地址不同的ARP攻击。</p>
<p>在配置被特性后，网关设备在进行ARP学习前将对ARP报文进行检查。如果以太网数据帧首部中的源MAC地址和ARP报文中sender mac地址不同，则认为是攻击报文，将其丢弃，否则，继续进行ARP学习。</p>
<h3 id="ARP主动确认功能"><a href="#ARP主动确认功能" class="headerlink" title="ARP主动确认功能"></a>ARP主动确认功能</h3><p>ARP的主动确认功能主要应用于网关设备上，防止攻击者仿冒用户欺骗网关设备。</p>
<p>启用ARP主动确认功能后，设备在新建或更新ARP表项前需进行主动确认，防止产生错误的ARP表项。</p>
<h2 id="MLAG结合VARP实现VRRP"><a href="#MLAG结合VARP实现VRRP" class="headerlink" title="MLAG结合VARP实现VRRP"></a>MLAG结合VARP实现VRRP</h2><p>VRRP(virtual router redundancy protocol，虚拟路由器冗余协议)将可以承担网关功能的一组路由器加入到备份组中，形成一台虚拟路由器，局域网内的终端设备只需将虚拟路由器配置为缺省网关即可。VRRP有两个版本，VRRPv2基于IPv4, VRRPv3基于IPv6。正统的VRRP实现起来可能有些复杂，通过MLAG结合VARP可以较为简单的实现VRRP的功能。拓扑如下。<br><img src="https://rancho333.gitee.io/pictures/varp_mlag_vrrp.png"></p>
<p>原理说明：device作为leaf switch, 下行接host，上行通过mlag连接到两台网关。策略配置之后，host发往网关的流量只会通过mlag中的一个端口发往switch A或switch B, 当mlag中一条线路down掉时，通过另一条线路通信，在switch A和switch B上运行VARP协议，通过配置相同的VIP和VMAC实现网关虚拟化。这里面有两个关键点。</p>
<ul>
<li>主机流量同一时间只会发往一台物理网关</li>
<li>物理网关上配置相同的VIP和VMAC实现网关虚拟化</li>
</ul>
<p>对于VARP说明，可以通过ip地址/mac地址确定唯一三层接口，但是三层接口可以被多个ip地址/mac地址定位到。对于虚拟网关，物理网关除了正常配置的ip与mac地址，还会配置一组相同的vip/vmac，主机将vip作为网关ip。对于物理网关：</p>
<ul>
<li>只有当主机请求vip时才回复vmac</li>
<li>主动发送arp或者转发三层报文时，src mac使用的都是自己真实的router mac</li>
</ul>
<p>对于主机而言，网关是虚拟的，所以使用虚拟网关ip进行通信<br>对于交换机而言，自己与外界通信需要使用自己真实的ip和mac, 这样对方才能根据真实的ip和mac定位到自己。</p>
<p>当MLAG交换机配置了VARP之后，host通过arp去请求VARP虚拟网关ip的mac地址，则MLAG-VARP交换机回应的自然是虚拟网关的mac;host发送icmp request给虚拟网关，虚拟网关使用真实的router-mac去回复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rancho"
      src="/pictures/Rancho.png">
  <p class="site-author-name" itemprop="name">Rancho</p>
  <div class="site-description" itemprop="description">No pain, no gain!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Rancho333" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Rancho333" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rancho</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
